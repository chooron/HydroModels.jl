"""
    HydroBucket{N,S} <: AbstractBucket

A flexible struct for organizing and executing model components.

# Fields
- `fluxes::Vector{<:AbstractHydroFlux}`: List of process functions to be applied.
- `dfluxes::Vector{<:AbstractStateFlux}`: List of state derivative functions for ODE support.
- `flux_funcs::Vector{<:Function}`: Precompiled functions for evaluating all fluxes efficiently.
- `ode_funcs::Union{Nothing,Vector}`: Functions for ODE calculations, or `nothing` if not needed.
- `infos::NamedTuple`: Metadata including input, output, state, parameter, and neural network names.

# Constructor
```julia
HydroBucket(; name=nothing, fluxes, dfluxes=StateFlux[])
```
- `name::Union{Symbol,Nothing}`: Optional identifier for the bucket. Defaults to an autogenerated name.
- `fluxes::Vector{<:AbstractHydroFlux}`: Required. Main computational elements.
- `dfluxes::Vector{<:AbstractStateFlux}`: Optional. State derivatives for ODE support.

# Usage Example
```julia
bucket = HydroBucket(
    name = :example_bucket,
    fluxes = [MyFlux1(), MyFlux2()],
    dfluxes = [MyStateFlux()]
)
```

# Notes
- Type parameters `N` and `S` are set internally and generally not user-specified.
- Designed for modularity and integration in larger modeling systems.
- Efficient function generation and metadata tracking are handled automatically.
"""
struct HydroBucket{N,S,MS} <: AbstractHydroBucket
    "Vector of flux functions describing hydrological processes."
    fluxes::Vector{<:AbstractHydroFlux}
    "Vector of state derivative functions for ODE calculations."
    dfluxes::Vector{<:AbstractStateFlux}
    "Generated function for calculating all hydrological fluxes. (Supports single-node data, multi-nodes data)"
    flux_func::Function
    "Generated function for ordinary differential equations (ODE) calculations, or nothing if no ODE calculations are needed. (Supports single-node data)"
    ode_func::Optional{Function}
    "Metadata about the bucket, including input, output, state, parameter, and neural network names."
    infos::NamedTuple

    function HydroBucket(;
        name::Optional{Symbol}=nothing,
        fluxes::Vector{<:AbstractHydroFlux},
        dfluxes::Vector{<:AbstractStateFlux}=StateFlux[],
        nmul::Optional{Int}=nothing
    )
        inputs, outputs, states = get_vars(fluxes, dfluxes)
        params, nns = reduce(union, get_params.(vcat(fluxes, dfluxes))), reduce(union, get_nns.(fluxes))
        infos = (; inputs=inputs, outputs=outputs, states=states, params=params, nns=nns)
        isnothing(nmul) && (nmul = 1)
        if nmul > 1
            flux_func, ode_func = build_multi_bucket_func(fluxes, dfluxes, infos)
        else
            flux_func, ode_func = build_single_bucket_func(fluxes, dfluxes, infos)
        end
        bucket_name = isnothing(name) ? Symbol("##bucket#", hash(infos)) : name
        return new{bucket_name,!isempty(states),nmul > 1}(fluxes, dfluxes, flux_func, ode_func, infos)
    end
end

"""
    @hydrobucket name begin
        fluxes = begin
            ...
        end
        dfluxes = begin
            ...
        end
    end

Creates a HydroBucket with the specified name, fluxes, and dfluxes.

# Arguments
- `name`: Symbol for the bucket name
- `fluxes`: Array of HydroFlux or NeuralFlux objects
- `dfluxes`: Array of StateFlux objects

# Example
```julia
@hydrobucket :bucket1 begin
    fluxes = [flux1, flux2]
    dfluxes = [dflux1, dflux2]
end
```
"""
macro hydrobucket(args...)
    name = length(args) == 1 ? nothing : args[1]
    expr = length(args) == 1 ? args[1] : args[2]

    @assert Meta.isexpr(expr, :block) "Expected a begin...end block after bucket name"
    fluxes_expr, dfluxes_expr, nmul_val = nothing, nothing, nothing
    for assign in filter(x -> !(x isa LineNumberNode), expr.args)
        @assert Meta.isexpr(assign, :(=)) "Expected assignments in the form 'fluxes = begin...end'"
        lhs, rhs = assign.args
        if lhs == :fluxes
            @assert Meta.isexpr(rhs, :block) "Expected 'fluxes' to be defined in a begin...end block"
            fluxes_expr = Expr(:vect, filter(x -> !(x isa LineNumberNode), rhs.args)...)
        elseif lhs == :dfluxes
            @assert Meta.isexpr(rhs, :block) "Expected 'dfluxes' to be defined in a begin...end block"
            dfluxes_expr = Expr(:vect, filter(x -> !(x isa LineNumberNode), rhs.args)...)
        elseif lhs == :nmul
            nmul_val = rhs
        else
            error("Unknown assignment: $lhs. Expected 'fluxes' or 'dfluxes'")
        end
    end

    kwargs = [:($:(name=$name)), :($:(fluxes=$fluxes_expr)), :($:(nmul=$nmul_val))]
    if !isnothing(dfluxes_expr)
        push!(kwargs, :($:(dfluxes=$dfluxes_expr)))
    end
    return esc(:(HydroBucket(;$(kwargs...))))
end

"""
    multiply(bucket::HydroBucket, nmul=10)::HydroBucket

Multiplies a HydroBucket by a given number of nodes.

# Arguments
- `bucket`: HydroBucket to be multiplied
- `nmul`: Number of nodes to multiply by

# Returns
- HydroBucket with the same fluxes and dfluxes as the input bucket, but with the specified number of nodes
"""
function multiply(bucket::HydroBucket, nmul=10)::HydroBucket
    HydroBucket(name=get_name(bucket), fluxes=bucket.fluxes, dfluxes=bucket.dfluxes, nmul=nmul)
end

"""
    (bucket::HydroBucket{N,S})(input::AbstractArray{T,2}, params::ComponentVector; kwargs...)
    (bucket::HydroBucket{N,S})(input::AbstractArray{T,3}, params::ComponentVector; kwargs...)

Evaluate the HydroBucket model with input data and parameters.

# Arguments
- `input`: Array of input data. Use 2D (variables × time) for single node, or 3D (variables × nodes × time) for multiple nodes.
- `params`: ComponentVector of model parameters and initial states.
- `kwargs`: Optional keyword arguments (e.g., solver, interp, timeidx, ptyidx, styidx, initstates).

# Returns
- Output array: (states+outputs) × time (2D) or (states+outputs) × nodes × time (3D).
- For 2D input: Array of size (states+outputs) × time
- For 3D input: Array of size (states+outputs) × nodes × time

# Description
This function executes the bucket model by:
1. Setting up interpolation for input time series
2. Preparing parameters and initial states
3. Solving ODEs if the model has state variables (S=true)
4. Computing fluxes using the model's flux functions
5. Combining states and fluxes into the output array

## Single Node Operation (2D input)
- Processes one location's time series
- Uses provided parameters and initial states
- Solves ODEs if model has states
- Returns combined states and fluxes

## Multi-Node Operation (3D input)
- Processes multiple locations simultaneously
- Supports both shared and distributed parameters
- Handles state evolution for each node
- Returns results for all nodes
"""
function (ele::HydroBucket{N,true,false})(input::AbstractArray{T,2}, params::ComponentVector; kwargs...) where {T,N}
    #* get kwargs
    solver = get(kwargs, :solver, ManualSolver(mutable=true))
    interp = get(kwargs, :interp, DirectInterpolation)
    timeidx = get(kwargs, :timeidx, collect(1:size(input, 2)))

    #* prepare initstates and parameters
    initstates = get(kwargs, :initstates, zeros(eltype(params), length(get_state_names(ele))))
    initstates_ = initstates isa ComponentVector ? Vector(initstates[get_state_names(ele)]) : initstates
    param_vec, params_axes = Vector(params), getaxes(params)

    #* solve ode functions
    itpfuncs = interp(input, timeidx)
    solved_states = solver(
        (u, p, t) -> ele.ode_func(itpfuncs(t), u, ComponentVector(p, params_axes)),
        param_vec, initstates_, timeidx
    )

    #* concatenate states and fluxes
    flux_output = ele.flux_func(input, solved_states, params)
    vcat(solved_states, stack(flux_output, dims=1))
end

function (ele::HydroBucket{N,true,true})(input::AbstractArray{T,3}, params::ComponentVector; kwargs...) where {T,N}
    input_dims, num_nodes, time_len = size(input)

    #* get kwargs
    ptyidx = get(kwargs, :ptyidx, collect(1:num_nodes))
    styidx = get(kwargs, :styidx, collect(1:num_nodes))
    solver = get(kwargs, :solver, ManualSolver(mutable=true))
    device = get(kwargs, :device, solver.dev)
    interp = get(kwargs, :interp, DirectInterpolation)
    timeidx = get(kwargs, :timeidx, collect(1:time_len))

    #* prepare initstates, parameters and nns
    initstates = get(kwargs, :initstates, zeros(eltype(params), length(get_state_names(ele)), num_nodes)) |> device
    initstates_ = initstates isa ComponentVector ? initstates[get_state_names(ele)] : initstates
    initstates_expand = expand_component_initstates(initstates_, styidx) |> device
    new_params = expand_component_params(params, get_param_names(ele), ptyidx) |> device
    params_vec, params_axes = Vector(new_params) |> device, getaxes(new_params)

    #* solve ode problem
    itpfuncs = interp(reshape(input, input_dims * num_nodes, :), timeidx)
    solved_states = solver(
        (u, p, t) -> ele.ode_func(
            reshape(itpfuncs(t), input_dims, num_nodes),
            u, ComponentVector(p, params_axes)
        ),
        params_vec, initstates_expand, timeidx
    )
    solved_states_reshape = reshape(solved_states, length(get_state_names(ele)), num_nodes, time_len)    
    #* run other functions
    output = ele.flux_func(input, solved_states_reshape, new_params)
    cat(solved_states_reshape, stack(output, dims=1), dims=1)
end

function (ele::HydroBucket{N,false,false})(input::AbstractArray{T,2}, params::ComponentVector; kwargs...) where {T,N}
    stack(ele.flux_func(input, nothing, params), dims=1)
end

function (ele::HydroBucket{N,false,true})(input::AbstractArray{T,3}, params::ComponentVector; kwargs...) where {T,N}
    ptyidx = get(kwargs, :ptyidx, 1:size(input, 2))
    device = get(kwargs, :device, identity)
    new_params = expand_component_params(params, get_param_names(ele), ptyidx) |> device
    stack(ele.flux_func(input, nothing, new_params), dims=1)
end
