"""
    HydroBucket{N,S} <: AbstractBucket

A flexible struct for organizing and executing model components.

# Fields
- `fluxes::Vector{<:AbstractHydroFlux}`: List of process functions to be applied.
- `dfluxes::Vector{<:AbstractStateFlux}`: List of state derivative functions for ODE support.
- `flux_funcs::Vector{<:Function}`: Precompiled functions for evaluating all fluxes efficiently.
- `ode_funcs::Union{Nothing,Vector}`: Functions for ODE calculations, or `nothing` if not needed.
- `infos::NamedTuple`: Metadata including input, output, state, parameter, and neural network names.

# Constructor
```julia
HydroBucket(; name=nothing, fluxes, dfluxes=StateFlux[])
```
- `name::Union{Symbol,Nothing}`: Optional identifier for the bucket. Defaults to an autogenerated name.
- `fluxes::Vector{<:AbstractHydroFlux}`: Required. Main computational elements.
- `dfluxes::Vector{<:AbstractStateFlux}`: Optional. State derivatives for ODE support.

# Usage Example
```julia
bucket = HydroBucket(
    name = :example_bucket,
    fluxes = [MyFlux1(), MyFlux2()],
    dfluxes = [MyStateFlux()]
)
```

# Notes
- Type parameters `N` and `S` are set internally and generally not user-specified.
- Designed for modularity and integration in larger modeling systems.
- Efficient function generation and metadata tracking are handled automatically.
"""
struct HydroBucket{N,S} <: AbstractBucket
    "Vector of flux functions describing hydrological processes."
    fluxes::Vector{<:AbstractHydroFlux}
    "Vector of state derivative functions for ODE calculations."
    dfluxes::Vector{<:AbstractStateFlux}
    "Generated function for calculating all hydrological fluxes. (Supports single-node data, multi-nodes data)"
    flux_funcs::Vector{<:Function}
    "Generated function for ordinary differential equations (ODE) calculations, or nothing if no ODE calculations are needed. (Supports single-node data)"
    ode_funcs::Union{Nothing,Vector}
    "Metadata about the bucket, including input, output, state, parameter, and neural network names."
    infos::NamedTuple

    function HydroBucket(;
        name::Union{Symbol,Nothing}=nothing,
        fluxes::Vector{<:AbstractHydroFlux},
        dfluxes::Vector{<:AbstractStateFlux}=StateFlux[],
    )
        inputs, outputs, states = get_vars(fluxes, dfluxes)
        params, nns = reduce(union, get_params.(vcat(fluxes, dfluxes))), reduce(union, get_nns.(fluxes))
        infos = (; inputs=inputs, outputs=outputs, states=states, params=params, nns=nns)
        single_flux_func, single_ode_func = build_single_bucket_func(fluxes, dfluxes, infos)
        multi_flux_func, multi_ode_func = build_multi_bucket_func(fluxes, dfluxes, infos)
        bucket_name = isnothing(name) ? Symbol("##bucket#", hash(infos)) : name
        return new{bucket_name,!isempty(states)}(fluxes, dfluxes, [single_flux_func, multi_flux_func], [single_ode_func, multi_ode_func], infos)
    end
end

"""
    @hydrobucket name begin
        fluxes = begin
            ...
        end
        dfluxes = begin
            ...
        end
    end

Creates a HydroBucket with the specified name, fluxes, and dfluxes.

# Arguments
- `name`: Symbol for the bucket name
- `fluxes`: Array of HydroFlux or NeuralFlux objects
- `dfluxes`: Array of StateFlux objects

# Example
```julia
@hydrobucket :bucket1 begin
    fluxes = [flux1, flux2]
    dfluxes = [dflux1, dflux2]
end
```
"""
macro hydrobucket(args...)
    name = length(args) == 1 ? nothing : args[1]
    expr = length(args) == 1 ? args[1] : args[2]

    @assert Meta.isexpr(expr, :block) "Expected a begin...end block after bucket name"
    fluxes_expr, dfluxes_expr = nothing, nothing
    for assign in filter(x -> !(x isa LineNumberNode), expr.args)
        @assert Meta.isexpr(assign, :(=)) "Expected assignments in the form 'fluxes = begin...end'"
        lhs, rhs = assign.args
        if lhs == :fluxes
            @assert Meta.isexpr(rhs, :block) "Expected 'fluxes' to be defined in a begin...end block"
            fluxes_expr = Expr(:vect, filter(x -> !(x isa LineNumberNode), rhs.args)...)
        elseif lhs == :dfluxes
            @assert Meta.isexpr(rhs, :block) "Expected 'dfluxes' to be defined in a begin...end block"
            dfluxes_expr = Expr(:vect, filter(x -> !(x isa LineNumberNode), rhs.args)...)
        else
            error("Unknown assignment: $lhs. Expected 'fluxes' or 'dfluxes'")
        end
    end
    @assert !isnothing(fluxes_expr) "'fluxes' must be specified"

    if isnothing(dfluxes_expr)
        return esc(:(HydroBucket(name=$(name), fluxes=$fluxes_expr)))
    else
        return esc(:(HydroBucket(name=$(name), fluxes=$fluxes_expr, dfluxes=$dfluxes_expr)))
    end
end

"""
    (bucket::HydroBucket{N,S})(input::AbstractArray{T,2}, params::ComponentVector; kwargs...)
    (bucket::HydroBucket{N,S})(input::AbstractArray{T,3}, params::ComponentVector; kwargs...)

Evaluate the HydroBucket model with input data and parameters.

# Arguments
- `input`: Array of input data. Use 2D (variables × time) for single node, or 3D (variables × nodes × time) for multiple nodes.
- `params`: ComponentVector of model parameters and initial states.
- `kwargs`: Optional keyword arguments (e.g., solver, interp, timeidx, ptyidx, styidx, initstates).

# Returns
- Output array: (states+outputs) × time (2D) or (states+outputs) × nodes × time (3D).
- For 2D input: Array of size (states+outputs) × time
- For 3D input: Array of size (states+outputs) × nodes × time

# Description
This function executes the bucket model by:
1. Setting up interpolation for input time series
2. Preparing parameters and initial states
3. Solving ODEs if the model has state variables (S=true)
4. Computing fluxes using the model's flux functions
5. Combining states and fluxes into the output array

## Single Node Operation (2D input)
- Processes one location's time series
- Uses provided parameters and initial states
- Solves ODEs if model has states
- Returns combined states and fluxes

## Multi-Node Operation (3D input)
- Processes multiple locations simultaneously
- Supports both shared and distributed parameters
- Handles state evolution for each node
- Returns results for all nodes
"""
function (ele::HydroBucket{N,true})(input::AbstractArray{T,2}, params::ComponentVector; kwargs...) where {T,N}
    #* get kwargs
    solver = get(kwargs, :solver, ManualSolver(mutable=true))
    interp = get(kwargs, :interp, DirectInterpolation)
    timeidx = get(kwargs, :timeidx, collect(1:size(input, 2)))
    #* prepare initstates
    initstates = get(kwargs, :initstates, zeros(eltype(params), length(get_state_names(ele))))
    initstates_ = initstates isa ComponentVector ? Vector(initstates[get_state_names(ele)]) : initstates
    #* get params axes
    param_vec, params_axes = Vector(params), getaxes(params)
    #* solve ode functions
    itpfuncs = interp(input, timeidx)
    solved_states = solver(
        (u, p, t) -> ele.ode_funcs[1](itpfuncs(t), u, ComponentVector(p, params_axes)),
        param_vec, initstates_, timeidx
    )
    #* concatenate states and fluxes
    flux_output = ele.flux_funcs[1](input, solved_states, params)
    vcat(solved_states, stack(flux_output, dims=1))
end

function (ele::HydroBucket{N,true})(input::AbstractArray{T,3}, params::ComponentVector; kwargs...) where {T,N}
    input_dims, num_nodes, _ = size(input)

    #* get kwargs
    ptyidx = get(kwargs, :ptyidx, collect(1:num_nodes))
    styidx = get(kwargs, :styidx, collect(1:num_nodes))
    solver = get(kwargs, :solver, ManualSolver(mutable=true))
    device = get(kwargs, :device, solver.dev)
    interp = get(kwargs, :interp, DirectInterpolation)
    timeidx = get(kwargs, :timeidx, collect(1:size(input, 3)))

    #* prepare initstates
    initstates = get(kwargs, :initstates, zeros(eltype(params), length(get_state_names(ele)), num_nodes)) |> device
    initstates_ = initstates isa ComponentVector ? initstates[get_state_names(ele)] : initstates
    initstates_mat = expand_component_initstates(initstates_, styidx) |> device

    #* prepare states parameters and nns
    new_params = expand_component_params(params, get_param_names(ele), ptyidx) |> device
    params_vec, params_axes = Vector(new_params) |> device, getaxes(new_params)

    itpfuncs = interp(reshape(input, input_dims * num_nodes, :), timeidx)
    solved_states = solver(
        (u, p, t) -> ele.ode_funcs[2](
            reshape(itpfuncs(t), input_dims, num_nodes),
            u,
            ComponentVector(p, params_axes)
        ),
        params_vec, initstates_mat, timeidx
    )

    #* run other functions
    output = ele.flux_funcs[2](input, solved_states, new_params)
    cat(solved_states, stack(output, dims=1), dims=1)
end

(ele::HydroBucket{N,false})(input::AbstractArray{T,2}, params::ComponentVector; kwargs...) where {T,N} = begin
    stack(ele.flux_funcs[1](input, nothing, params), dims=1)
end

function (ele::HydroBucket{N,false})(input::AbstractArray{T,3}, params::ComponentVector; kwargs...) where {T,N}
    ptyidx = get(kwargs, :ptyidx, 1:size(input, 2))
    device = get(kwargs, :device, identity)
    new_params = expand_component_params(params, get_param_names(ele), ptyidx) |> device
    stack(ele.flux_funcs[2](input, nothing, new_params), dims=1)
end
