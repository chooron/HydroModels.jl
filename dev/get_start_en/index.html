<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Get Started with HydroModels.jl · HydroModels.jl</title><meta name="title" content="Get Started with HydroModels.jl · HydroModels.jl"/><meta property="og:title" content="Get Started with HydroModels.jl · HydroModels.jl"/><meta property="twitter:title" content="Get Started with HydroModels.jl · HydroModels.jl"/><meta name="description" content="Documentation for HydroModels.jl."/><meta property="og:description" content="Documentation for HydroModels.jl."/><meta property="twitter:description" content="Documentation for HydroModels.jl."/><meta property="og:url" content="https://chooron.github.io/HydroModels.jl/dev/get_start_en/"/><meta property="twitter:url" content="https://chooron.github.io/HydroModels.jl/dev/get_start_en/"/><link rel="canonical" href="https://chooron.github.io/HydroModels.jl/dev/get_start_en/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/icon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">HydroModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Get Started with HydroModels.jl</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Build-a-ExpHydro-Model"><span>Build a ExpHydro Model</span></a></li><li><a class="tocitem" href="#Run-a-ExpHydro-Model"><span>Run a ExpHydro Model</span></a></li><li><a class="tocitem" href="#Conclusion"><span>Conclusion</span></a></li></ul></li><li><a class="tocitem" href="../concepts_en/">Basic Concepts</a></li><li><span class="tocitem">Model Implementations</span><ul><li><a class="tocitem" href="../implements/build_exphydro_model_en/">construct the ExpHydro Model</a></li><li><a class="tocitem" href="../implements/build_m50_model_en/">construct the M50 Model</a></li><li><a class="tocitem" href="../implements/build_discharge_route_en/">construct the discharge route model</a></li></ul></li><li><span class="tocitem">Extend Contents</span><ul><li><a class="tocitem" href="../extent/why_not_MTK_en/">Why not using ModelingToolkit.jl directly</a></li><li><a class="tocitem" href="../extent/framework_comparision_en/">Framework Comparision</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Get Started with HydroModels.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Get Started with HydroModels.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/chooron/HydroModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/chooron/HydroModels.jl/blob/main/docs/src/get_start_en.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Getting-Started-With-HydroModels.jl"><a class="docs-heading-anchor" href="#Getting-Started-With-HydroModels.jl">Getting Started With HydroModels.jl</a><a id="Getting-Started-With-HydroModels.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-Started-With-HydroModels.jl" title="Permalink"></a></h1><p><code>HydroModels.jl</code> is a modern hydrological modeling framework based on the Julia language. Built upon and extending the SUPERFLEX design philosophy, it offers flexible model construction capabilities, efficient computational performance, and support for deep learning model integration. This tutorial will demonstrate how to build and run hydrological models using <code>HydroModels.jl</code>.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><pre><code class="language-julia hljs">] add HydroModels</code></pre><h2 id="Build-a-ExpHydro-Model"><a class="docs-heading-anchor" href="#Build-a-ExpHydro-Model">Build a ExpHydro Model</a><a id="Build-a-ExpHydro-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Build-a-ExpHydro-Model" title="Permalink"></a></h2><h3 id="Introduction-to-ExpHydro-Model"><a class="docs-heading-anchor" href="#Introduction-to-ExpHydro-Model">Introduction to ExpHydro Model</a><a id="Introduction-to-ExpHydro-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-to-ExpHydro-Model" title="Permalink"></a></h3><p><code>ExpHydro</code> is a simple hydrological model consisting of a snow module and a soil module. Its mathematical expressions are as follows.</p><p class="math-container">\[\begin{aligned}
&amp; \text{Snowpack Bucket:} \\
&amp; pet = 29.8 \cdot lday \cdot 24 \cdot 0.611 \cdot \frac{\exp(17.3 \cdot temp)}{temp + 237.3} \cdot \frac{1}{temp + 273.2} &amp;&amp; (1) \\
&amp; snowfall = H(T_{min} - temp) \cdot prcp &amp;&amp; (2) \\
&amp; rainfall = H(temp - T_{m,n}) \cdot prcp,&amp;&amp; (3) \\
&amp; melt = H(temp - T_{max}) \cdot H(snowpack) \cdot \min(snowpack, D_f \cdot (temp - T_{max})) &amp;&amp; (4) \\
&amp; \frac{d(snowpack)}{dt} = snowfall - melt &amp;&amp; (5) \\
\\
&amp; \text{Soilwater Bucket:} \\
&amp; evap = H(soilwater) \cdot pet \cdot \min(1.0, \frac{soilwater}{S_{max}}) &amp;&amp; (6) \\
&amp; baseflow = H(soilwater) \cdot Q_{max} \cdot \exp(-f \cdot \max(0.0, S_{max} - soilwater)) &amp;&amp; (7) \\
&amp; surfaceflow = \max(0.0, soilwater - S_{max}) &amp;&amp; (8) \\
&amp; flow = baseflow + ,urfaceflow &amp;&amp; (9) \\
&amp; \frac{d(soilwater)}{dt} = rainfall + melt - evap - flow &amp;&amp; (10)
\end{aligned}\]</p><p>where <span>$H(x)$</span> represents the Heaviside step function that equals 1 when <span>$x &gt; 0$</span> and 0 otherwise; <span>$T_{min}$</span>, <span>$T_{max}$</span>, <span>$D_f$</span>, <span>$S_{max}$</span>, <span>$Q_{max}$</span>, and <span>$f$</span> are model parameters; <span>$temp$</span>, <span>$lday$</span>, and <span>$prcp$</span> are input variables; <span>$snowpack$</span> and <span>$soilwater$</span> are state variables; and the remaining variables are intermediate calculation variables.</p><h3 id="Build-an-ExpHydro-Model-in-HydroModels.jl"><a class="docs-heading-anchor" href="#Build-an-ExpHydro-Model-in-HydroModels.jl">Build an ExpHydro Model in HydroModels.jl</a><a id="Build-an-ExpHydro-Model-in-HydroModels.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Build-an-ExpHydro-Model-in-HydroModels.jl" title="Permalink"></a></h3><p>After understanding the basic principles of the <code>ExpHydro</code> model, we can use <code>HydroModels.jl</code> to build this model.</p><h4 id="Import-Packages"><a class="docs-heading-anchor" href="#Import-Packages">Import Packages</a><a id="Import-Packages-1"></a><a class="docs-heading-anchor-permalink" href="#Import-Packages" title="Permalink"></a></h4><p>First, import the HydroModels.jl package:</p><pre><code class="language-julia hljs">using HydroModels</code></pre><h4 id="Define-Variables-and-Parameters"><a class="docs-heading-anchor" href="#Define-Variables-and-Parameters">Define Variables and Parameters</a><a id="Define-Variables-and-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Define-Variables-and-Parameters" title="Permalink"></a></h4><p>Define the model parameters, state variables, and other variables (including precipitation, evaporation, snowmelt, surface flow, etc.):</p><pre><code class="language-julia hljs">@variables temp lday pet prcp 
@variables snowfall rainfall melt evap baseflow surfaceflow flow
@variables snowpack soilwater
@parameters Tmin Tmax Df Smax Qmax f</code></pre><h4 id="Build-Flux-Formulas-by-HydroFlux"><a class="docs-heading-anchor" href="#Build-Flux-Formulas-by-HydroFlux">Build Flux Formulas by HydroFlux</a><a id="Build-Flux-Formulas-by-HydroFlux-1"></a><a class="docs-heading-anchor-permalink" href="#Build-Flux-Formulas-by-HydroFlux" title="Permalink"></a></h4><p>Next, we need to construct the various computational formulas of the model, including state equations and intermediate variable calculations. Let&#39;s use the snowmelt formula as an example to demonstrate how to use <code>HydroFlux</code>:</p><pre><code class="language-julia hljs"># define the step function
step_func(x) = (tanh(5.0 * x) + 1.0) * 0.5

melt_flux = HydroFlux([snowpack, temp] =&gt; [melt], [Tmax, Df], exprs=[step_func(temp - Tmax) * step_func(snowpack) * min(snowpack, Df * (temp - Tmax))])</code></pre><p>When constructing <code>HydroFlux</code>, several points need attention:</p><ol><li>Ensure all variables and parameters used in the expression are declared in the inputs</li><li>Input and output variables are connected through the <code>Pair</code> type (=&gt;)</li><li>Parameters are passed as vectors</li><li>Expressions are passed as vectors to the <code>exprs</code> parameter</li></ol><p><code>HydroFlux</code> first accepts a <code>Pair</code> type consisting of input and output variables, then takes a <code>Vector</code> of parameters, and finally accepts the snowmelt formula expression through <code>exprs</code> to complete the construction of the snowmelt formula.</p><p>It&#39;s important to note that when building <code>HydroFlux</code>, you must ensure that all variables and parameters in <code>expr</code> are included in the input variables and parameters. If there are variables or parameters in <code>exprs</code> that haven&#39;t been provided to <code>HydroFlux</code>, errors may occur during subsequent calculations due to undefined variables. In such cases, you&#39;ll need to check if the <code>HydroFlux</code> construction is correct.</p><p>Of course, when building HydroFlux, parameter variables are not always necessary. If parameters are not needed, they can be omitted, as shown in the potential evapotranspiration calculation formula:</p><pre><code class="language-julia hljs">pet_flux = HydroFlux([temp, lday] =&gt; [pet], exprs=[29.8 * lday * 24 * 0.611 * exp(17.3 * temp) / (temp + 237.3) * 1 / (temp + 273.2)])</code></pre><p>This formula uses <code>temp</code> and <code>lday</code> as input variables and calculates <code>pet</code> as the output variable. Since this formula doesn&#39;t involve parameters, there&#39;s no need to pass parameter variables.</p><p>It&#39;s worth noting that <code>HydroFlux</code>&#39;s <code>exprs</code> parameter can only accept a <code>Vector</code> of expressions. This is because <code>HydroFlux</code> sometimes needs to support multiple output variables, thus requiring multiple expressions, and the number of expressions must match the number of outputs. Here&#39;s an example using the rain-snow separation formula:</p><pre><code class="language-julia hljs">HydroFlux([prcp, temp] =&gt; [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp])</code></pre><p>This formula uses <code>prcp</code> and <code>temp</code> as input variables and calculates <code>snowfall</code> and <code>rainfall</code> as output variables, while using <code>Tmin</code> as a parameter. Since this formula outputs two variables (<code>snowfall</code> and <code>rainfall</code>), two expressions must be provided to represent the calculation formulas for each output variable.</p><h4 id="Build-State-Formulas-by-StateFlux"><a class="docs-heading-anchor" href="#Build-State-Formulas-by-StateFlux">Build State Formulas by StateFlux</a><a id="Build-State-Formulas-by-StateFlux-1"></a><a class="docs-heading-anchor-permalink" href="#Build-State-Formulas-by-StateFlux" title="Permalink"></a></h4><p>Generally, state equations are constructed as the sum of input fluxes minus the sum of output fluxes. Therefore, we can use a <code>Pair</code> to represent this input-output relationship and include the state variable to build a <code>StateFlux</code>. Here&#39;s an example with the snowpack state equation:</p><pre><code class="language-julia hljs">snowpack_flux = StateFlux([snowfall] =&gt; [melt], snowpack)</code></pre><p>This formula uses <code>snowfall</code> as the input variable and calculates <code>snowpack</code> as the output variable, while incorporating the state variable <code>snowpack</code> to construct the snowpack state equation.</p><p>Typically, before constructing state equations, it&#39;s preferable to build all involved fluxes using <code>HydroFlux</code> first, then combine them using <code>StateFlux</code> with input-output flux <code>Pair</code>s and state variables to get an intuitive <code>StateFlux</code>. However, to avoid introducing unnecessary variables, you can also directly construct more complex <code>StateFlux</code> equations. In fact, this construction method is highly consistent with <code>HydroFlux</code> - it similarly takes input and output variables as <code>StateFlux</code> inputs, names the state variables and required parameters, and finally constructs the state equation. Let&#39;s rebuild the snowpack state equation:</p><pre><code class="language-julia hljs">snowpack_flux = StateFlux([prcp, temp, melt], snowpack, [Tmin], expr=step_func(Tmin - temp) * prcp-melt)</code></pre><p>In this state equation, instead of directly calculating <code>snowfall</code>, we perform the calculation using <code>prcp</code> and <code>temp</code>, combining with the state equation <code>dsnowpack/dt=snowfall-melt</code> to construct a complex state equation that omits the <code>snowfall</code> intermediate variable.</p><h4 id="Build-Snowfall-Bucket"><a class="docs-heading-anchor" href="#Build-Snowfall-Bucket">Build Snowfall Bucket</a><a id="Build-Snowfall-Bucket-1"></a><a class="docs-heading-anchor-permalink" href="#Build-Snowfall-Bucket" title="Permalink"></a></h4><p>After completing the necessary <code>HydroFlux</code> and <code>StateFlux</code> constructions, we can build a <code>HydroBucket</code>. Using the snowpack <code>Bucket</code> as an example, we need to pass the constructed <code>HydroFlux</code> and <code>StateFlux</code> to <code>HydroBucket</code>.</p><p>First, store the relevant <code>HydroFlux</code> and <code>StateFlux</code> in a <code>Vector</code>:</p><pre><code class="language-julia hljs">fluxes_1 = [
    HydroFlux([temp, lday] =&gt; [pet], exprs=[29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)]),
    HydroFlux([prcp, temp] =&gt; [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp]),
    HydroFlux([snowpack, temp] =&gt; [melt], [Tmax, Df], exprs=[step_func(temp - Tmax) * step_func(snowpack) * min(snowpack, Df * (temp - Tmax))]),
]
dfluxes_1 = [StateFlux([snowfall] =&gt; [melt], snowpack),]
snowpack_bucket = HydroBucket(name=:surface, fluxes=fluxes_1, dfluxes=dfluxes_1)</code></pre><p>Then use these <code>Vector</code> variables as input to build a hydrological computation module, i.e., <code>HydroBucket</code>:</p><pre><code class="language-julia hljs">snowpack_bucket = HydroBucket(name=:surface, fluxes=fluxes_1, dfluxes=dfluxes_1)</code></pre><p>Through <code>HydroBucket</code>, we can complete the construction of a hydrological computation module. During the construction of <code>HydroBucket</code>, the program executes some automatic construction methods to express the ordinary differential equations and other variable calculation functions in the computation module. For implementation details, please refer to the implementation section.</p><h4 id="Build-Exphydro-Model"><a class="docs-heading-anchor" href="#Build-Exphydro-Model">Build Exphydro Model</a><a id="Build-Exphydro-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Build-Exphydro-Model" title="Permalink"></a></h4><p>Following the same logic, we can build the soil computation module, then concatenate the two modules into a <code>Vector</code> type and input it to <code>HydroModel</code> to complete the construction of the <code>ExpHydro</code> model. The complete construction code is as follows:</p><pre><code class="language-julia hljs">#* import packages
using HydroModels

#* define variables and parameters
@variables temp lday pet prcp 
@variables snowfall rainfall melt evap baseflow surfaceflow flow
@variables snowpack soilwater
@parameters Tmin Tmax Df Smax Qmax f

step_func(x) = (tanh(5.0 * x) + 1.0) * 0.5

#* define snowpack bucket
fluxes_1 = [
    HydroFlux([temp, lday] =&gt; [pet], exprs=[29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)]),
    HydroFlux([prcp, temp] =&gt; [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp]),
    HydroFlux([snowpack, temp] =&gt; [melt], [Tmax, Df], exprs=[step_func(temp - Tmax) * step_func(snowpack) * min(snowpack, Df * (temp - Tmax))]),
]
dfluxes_1 = [StateFlux([snowfall] =&gt; [melt], snowpack),]
snowpack_bucket = HydroBucket(name=:surface, fluxes=fluxes_1, dfluxes=dfluxes_1)

#* define soilwater bucket
fluxes_2 = [
    HydroFlux([soilwater, pet] =&gt; [evap], [Smax], exprs=[step_func(soilwater) * pet * min(1.0, soilwater / Smax)]),
    HydroFlux([soilwater] =&gt; [baseflow], [Smax, Qmax, f], exprs=[step_func(soilwater) * Qmax * exp(-f * (max(0.0, Smax - soilwater)))]),
    HydroFlux([soilwater] =&gt; [surfaceflow], [Smax], exprs=[max(0.0, soilwater - Smax)]),
    HydroFlux([baseflow, surfaceflow] =&gt; [flow], exprs=[baseflow + surfaceflow]),
]
dfluxes_2 = [StateFlux([rainfall, melt] =&gt; [evap, flow], soilwater)]
soilwater_bucket = HydroBucket(name=:soil, fluxes=fluxes_2, dfluxes=dfluxes_2)

#* define the Exp-Hydro model
exphydro_model = HydroModel(name=:exphydro, components=[snowpack_bucket, soilwater_bucket])</code></pre><p>This completes the construction of an <code>ExpHydro</code> model. When we print this type, we can see the basic information contained in the model:</p><pre><code class="language-txt hljs">HydroModel: exphydro
   Components: surface, soil
   Inputs: [temp, lday, prcp]
   States: [snowpack, soilwater]
   Outputs: [pet, snowfall, rainfall, melt, evap, baseflow, surfaceflow, flow]
   Parameters: [Tmin, Tmax, Df, Smax, Qmax, f]
   Components:
       Fluxes: 0 fluxes
       Buckets: 2 buckets
       Routes: 0 routes</code></pre><p>This information shows the model&#39;s name, component names, input variables, state variables, output variables, parameter variables, and the number of <code>Flux</code>es, <code>Bucket</code>s, and <code>Route</code>s contained in the model.</p><h4 id="Define-Neural-Network-by-Lux.jl"><a class="docs-heading-anchor" href="#Define-Neural-Network-by-Lux.jl">Define Neural Network by Lux.jl</a><a id="Define-Neural-Network-by-Lux.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Define-Neural-Network-by-Lux.jl" title="Permalink"></a></h4><p><code>HydroModels.jl</code> supports neural network definition through <code>Lux.jl</code>. Here&#39;s an example using a simple fully connected neural network:</p><pre><code class="language-julia hljs">using Lux

# define the ET NN and Q NN
ep_nn = Lux.Chain(
    Lux.Dense(3 =&gt; 16, tanh),
    Lux.Dense(16 =&gt; 16, leakyrelu),
    Lux.Dense(16 =&gt; 1, leakyrelu),
    name=:epnn
)

q_nn = Lux.Chain(
    Lux.Dense(2 =&gt; 16, tanh),
    Lux.Dense(16 =&gt; 16, leakyrelu),
    Lux.Dense(16 =&gt; 1, leakyrelu),
    name=:qnn
)</code></pre><p>After constructing two fully connected neural networks <code>ep_nn</code> and <code>q_nn</code> using <code>Lux.jl</code>, we can build neural network formulas using <code>NeuralFlux</code> provided by <code>HydroModel.jl</code>:</p><pre><code class="language-julia hljs">@variables norm_snw norm_slw norm_temp norm_prcp
@variables log_evap_div_lday log_flow

ep_nn_flux = NeuralFlux([norm_snw, norm_slw, norm_temp] =&gt; [log_evap_div_lday], ep_nn)
q_nn_flux = NeuralFlux([norm_slw, norm_prcp] =&gt; [log_flow], q_nn)</code></pre><p><code>NeuralFlux</code> is a derivative type of <code>HydroFlux</code>. It similarly accepts a <code>Pair</code> of input and output variables, but unlike <code>HydroFlux</code>, it doesn&#39;t require model parameters and calculation formulas. Instead, it needs the neural network to be passed as a parameter to <code>NeuralFlux</code> to construct the neural network formula. It&#39;s important to note that the input and output variable dimensions must match those of the <code>NeuralFlux</code>.</p><p>After completing the construction of <code>NeuralFlux</code>, we can pass it along with other <code>HydroFlux</code>es to <code>HydroBucket</code> to build a neural network-coupled hydrological model:</p><pre><code class="language-julia hljs">soil_fluxes = [
    #* normalize
    HydroFlux([snowpack, soilwater, prcp, temp] =&gt; [norm_snw, norm_slw, norm_prcp, norm_temp],
        [snowpack_mean, soilwater_mean, prcp_mean, temp_mean, snowpack_std, soilwater_std, prcp_std, temp_std],
        exprs=[(var - mean) / std for (var, mean, std) in zip([snowpack, soilwater, prcp, temp],
            [snowpack_mean, soilwater_mean, prcp_mean, temp_mean],
            [snowpack_std, soilwater_std, prcp_std, temp_std]
        )]),
    ep_nn_flux,
    q_nn_flux
]</code></pre><p>This soil module includes normalization formulas, evaporation formulas, and runoff formulas. Next, we can pass these formulas to <code>HydroBucket</code> and combine them with state equations to complete the construction of the soil module:</p><pre><code class="language-julia hljs">state_expr = rainfall + melt - step_func(soilwater) * lday * exp(log_evap_div_lday) - step_func(soilwater) * exp(log_flow)
soil_dfluxes = [StateFlux([soilwater, rainfall, melt, lday, log_evap_div_lday, log_flow], soilwater, expr=state_expr)]
soilwater_bucket = HydroBucket(name=:soil, fluxes=soil_fluxes, dfluxes=soil_dfluxes)
m50_model = HydroModel(name=:m50, components=[snowpack_bucket, soilwater_bucket])</code></pre><h2 id="Run-a-ExpHydro-Model"><a class="docs-heading-anchor" href="#Run-a-ExpHydro-Model">Run a ExpHydro Model</a><a id="Run-a-ExpHydro-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Run-a-ExpHydro-Model" title="Permalink"></a></h2><p>After completing the model construction, since the model is <code>callable</code>, we can input the data and parameters into the model to obtain output results.</p><h3 id="Prepare-Input-Data"><a class="docs-heading-anchor" href="#Prepare-Input-Data">Prepare Input Data</a><a id="Prepare-Input-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Prepare-Input-Data" title="Permalink"></a></h3><p>The model accepts input observation data of type <code>AbstractMatrix</code>, with dimensions being the number of input variables multiplied by the number of time steps. For example, if there are 3 input variables and 1000 time steps, the input observation data dimensions would be (3, 1000). It&#39;s important to note that the index of input variables in the dimension will affect the model calculation results, as the model cannot automatically identify which row in the Matrix corresponds to which input variable. Therefore, users can first prepare a <code>Dict</code> or <code>NamedTuple</code> type, then use <code>HydroModels.get_input_names(model)</code> to get the names of the model&#39;s input variables, and combine these names with the <code>Dict</code> or <code>NamedTuple</code> to construct the <code>Matrix</code> type input data:</p><pre><code class="language-julia hljs">input = (lday=df[ts, &quot;dayl(day)&quot;], temp=df[ts, &quot;tmean(C)&quot;], prcp=df[ts, &quot;prcp(mm/day)&quot;])
input_arr = Matrix(reduce(hcat, collect(input[HydroModels.get_input_names(exphydro_model)]))&#39;)</code></pre><h3 id="Prepare-Parameters-and-Initial-States"><a class="docs-heading-anchor" href="#Prepare-Parameters-and-Initial-States">Prepare Parameters and Initial States</a><a id="Prepare-Parameters-and-Initial-States-1"></a><a class="docs-heading-anchor-permalink" href="#Prepare-Parameters-and-Initial-States" title="Permalink"></a></h3><p>For parameter preparation, <code>HydroModels.jl</code> accepts parameters of type <code>ComponentVector</code> (<code>using ComponentArrays</code>), storing parameter names and values in the <code>ComponentVector</code>, for example:</p><pre><code class="language-julia hljs">f, Smax, Qmax, Df, Tmax, Tmin = 0.01674478, 1709.461015, 18.46996175, 2.674548848, 0.175739196, -2.092959084
params = ComponentVector(f=f, Smax=Smax, Qmax=Qmax, Df=Df, Tmax=Tmax, Tmin=Tmin)</code></pre><p>For initial state preparation, <code>HydroModels.jl</code> similarly accepts initial states of type <code>ComponentVector</code>, storing state names and values in the <code>ComponentVector</code>, for example:</p><pre><code class="language-julia hljs">init_states = ComponentVector(snowpack=0.0, soilwater=1303.004248)</code></pre><p>Then store the parameters and initial states in a single <code>ComponentVector</code> (sometimes initial states are also treated as parameters to be optimized, so they need to be stored together with parameters for unified management):</p><pre><code class="language-julia hljs">pas = ComponentVector(params=params, initstates=init_states)</code></pre><h3 id="Run-the-ExpHydro-Model"><a class="docs-heading-anchor" href="#Run-the-ExpHydro-Model">Run the ExpHydro Model</a><a id="Run-the-ExpHydro-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Run-the-ExpHydro-Model" title="Permalink"></a></h3><p>Finally, we can input the data and parameters into the model to obtain the output results:</p><pre><code class="language-julia hljs">result = exphydro_model(input_arr, pas)</code></pre><p>The model output is also of type <code>AbstractMatrix</code>, with dimensions being the number of output variables (including state variables) multiplied by the number of time steps. For example, if there are 8 output variables and 1000 time steps, the output dimensions would be (8, 1000). If you want to export the results as a <code>DataFrame</code> type, you can use <code>HydroModels.get_output_names(model)</code> to get the names of the output variables, then combine them with a <code>Dict</code> or <code>NamedTuple</code> to construct a <code>DataFrame</code>:</p><pre><code class="language-julia hljs">states_and_output_names = vcat(HydroModels.get_state_names(exphydro_model), HydroModels.get_output_names(exphydro_model))
output = NamedTuple{Tuple(states_and_output_names)}(eachslice(result, dims=1))
df = DataFrame(output)</code></pre><p>The calculation results look like this:</p><pre><code class="language-txt hljs">10000×10 DataFrame
   Row │ snowpack  soilwater  pet      snowfall  rainfall  melt      evap      baseflow   surfaceflow  flow      
       │ Float64   Float64    Float64  Float64   Float64   Float64   Float64   Float64    Float64      Float64   
───────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────
     1 │    0.0         0.0      3.1        0.0   1305.22  1.13779   0.868735  0.0212194          0.0  0.0212194
     2 │    0.0         0.0      4.24       0.0   1308.28  1.51019   1.15578   0.0223371          0.0  0.0223371
     3 │    0.0         0.0      8.02       0.0   1315.03  1.63204   1.25547   0.0250095          0.0  0.0250095
     4 │    0.0         0.0     15.27       0.0   1329.34  1.21771   0.946937  0.0317802          0.0  0.0317802
     5 │    0.0         0.0      8.48       0.0   1336.99  1.02779   0.803845  0.0361228          0.0  0.0361228
   ⋮   │    ⋮          ⋮         ⋮        ⋮         ⋮         ⋮         ⋮          ⋮           ⋮           ⋮
  9996 │  254.264       0.0      0.0       -0.0   1521.37  0.221762  0.197362  0.791897           0.0  0.791897
  9997 │  266.324      12.06     0.0       -0.0   1520.37  0.238907  0.21248   0.778688           0.0  0.778688
  9998 │  277.874      11.55     0.0       -0.0   1519.33  0.288362  0.256291  0.765307           0.0  0.765307
  9999 │  279.714       1.84     0.0       -0.0   1518.29  0.311022  0.27624   0.752073           0.0  0.752073
 10000 │  279.854       0.14     0.0       -0.0   1517.38  0.176836  0.156967  0.740711           0.0  0.740711</code></pre><h3 id="Plot-the-Results"><a class="docs-heading-anchor" href="#Plot-the-Results">Plot the Results</a><a id="Plot-the-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-the-Results" title="Permalink"></a></h3><p>The model results are compared with the actual values ​​and plotted into a line graph as follows.</p><p><img src="../assets/exphydro_predict.png" alt="exphydro model predict"/></p><h3 id="Running-with-Config"><a class="docs-heading-anchor" href="#Running-with-Config">Running with Config</a><a id="Running-with-Config-1"></a><a class="docs-heading-anchor-permalink" href="#Running-with-Config" title="Permalink"></a></h3><p>The model computation is not limited to these basic features. To support necessary settings during the computation process, <code>HydroModel</code> can accept a <code>config</code> parameter.</p><p>For example, by default, the model uses only the Euler method to solve ordinary differential equations. However, sometimes a more accurate solving method is needed, which can be set using the <code>config</code> parameter.</p><p>To demonstrate this functionality, we need to additionally import <code>OrdinaryDiffEq.jl</code> and <code>HydroModelTools.jl</code>, then set the solving method:</p><pre><code class="language-julia hljs">using OrdinaryDiffEq
using HydroModelTools
using DataInterpolations

config = (solver=ODESolver(alg=Tsit5(), abstol=1e-3, reltol=1e-3), interp=LinearInterpolation)
output = exphydro_model(input_arr, pas, config=config)</code></pre><p>The <code>config</code> parameter is set as a <code>NamedTuple</code> type, where the <code>solver</code> parameter is used to set the solving method, and the <code>interp</code> parameter is used to set the interpolation method. <code>ODESolver</code> is a solver wrapper class provided by <code>HydroModelTools.jl</code> that performs some data conversion on the solution results. It accepts solving methods from <code>OrdinaryDiffEq.jl</code> as parameters and sets the solving method parameters.</p><p>[Would you like me to continue with the neural network implementation section?]</p><h3 id="Run-the-Neural-Network-Enhanced-Model"><a class="docs-heading-anchor" href="#Run-the-Neural-Network-Enhanced-Model">Run the Neural Network Enhanced Model</a><a id="Run-the-Neural-Network-Enhanced-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Run-the-Neural-Network-Enhanced-Model" title="Permalink"></a></h3><p>Earlier we built an <code>ExpHydro</code> model coupled with neural networks, and now we can use this model to calculate results.</p><p>First, we need to prepare the model parameters. In addition to the <code>ExpHydro</code> model parameters, we also need to prepare neural network parameters:</p><pre><code class="language-julia hljs">using StableRNGs

ep_nn_params = Vector(ComponentVector(LuxCore.initialparameters(ep_nn)))
q_nn_params = Vector(ComponentVector(LuxCore.initialparameters(q_nn)))</code></pre><p>Models based on <code>Lux.jl</code> can decouple parameters from model structure, which is the primary reason we chose to use <code>Lux.jl</code> to build neural networks. After using <code>LuxCore.initialparameters</code>, we convert the parameters (<code>NamedTuple</code>) to <code>Vector</code> type, then combine them with the model parameters and initial states to build the complete model parameters:</p><pre><code class="language-julia hljs">nn_pas = ComponentVector(epnn=ep_nn_params, qnn=q_nn_params)
pas = ComponentVector(params=params, initstates=init_states, nns=nn_pas)</code></pre><p>It&#39;s important to note that we need to use the key name <code>nns</code> to store the neural network parameters, keeping them independent from model parameters and initial states. Additionally, the neural network parameters <code>nn_pas</code> need to use model names and parameters as key-value pairs.</p><p>Finally, we can input the model parameters into the model to obtain the output results:</p><pre><code class="language-julia hljs">output = m50_model(input_arr, pas)</code></pre><h2 id="Conclusion"><a class="docs-heading-anchor" href="#Conclusion">Conclusion</a><a id="Conclusion-1"></a><a class="docs-heading-anchor-permalink" href="#Conclusion" title="Permalink"></a></h2><p>This tutorial has provided a detailed introduction to the basic usage of <code>HydroModels.jl</code>, including:</p><ul><li>Model building process</li><li>Parameter and initial state configuration</li><li>Model execution and computation</li></ul><p>Through this tutorial, users can quickly master the core functionality of <code>HydroModels.jl</code> and begin building their own hydrological models.</p><p><code>HydroModels.jl</code> also offers more advanced features, including:</p><ul><li>Semi-distributed and distributed hydrological model construction and computation</li><li>Neural network-coupled parameter-adaptive models</li><li><code>GR4J</code> model with unit hydrograph routing</li><li>Model parameter optimization</li><li>Model extension functionality based on <code>Wrapper</code></li></ul><p>These advanced features will be covered in subsequent tutorials.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../concepts_en/">Basic Concepts »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Wednesday 15 January 2025 06:13">Wednesday 15 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
