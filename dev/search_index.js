var documenterSearchIndex = {"docs":
[{"location":"implements/build_m50_model_en/#Embedding-Neural-Networks-in-ExpHydro-Model:-Implementation-of-[M50](https://hess.copernicus.org/articles/26/5085/2022/)-Model","page":"construct a M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"","category":"section"},{"location":"implements/build_m50_model_en/","page":"construct a M50 Model","title":"construct a M50 Model","text":"marv-in proposed the M50 and M100 models in their paper, with code stored in HydroNODE, pioneering the integration of neural networks into hydrological models (notably by replacing ExpHydro model's calculation formulas while participating in balance equation solving). This model inspired our repository, and recognizing the current complexity in model development, our primary goal is to simplify the process of embedding neural networks into hydrological models. Below, we'll compare the source code with our repository's implementation of M50 and M100 models, showcasing a new approach to model construction.","category":"page"},{"location":"implements/build_m50_model_en/#M50-Implementation-in-HydroNODE","page":"construct a M50 Model","title":"M50 Implementation in HydroNODE","text":"","category":"section"},{"location":"implements/build_m50_model_en/","page":"construct a M50 Model","title":"construct a M50 Model","text":"First, let's examine the implementation of M50 and M100 models in HydroNODE:","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct a M50 Model","title":"construct a M50 Model","text":"# define the ODE problem\nfunction NeuralODE_M50_core!(dS,S,p,t)\n\n    Tmin, Tmax, Df = (p_bucket_precal...,)\n\n    Lday = itp_Lday(t)\n    P    = itp_P(t)\n    T    = itp_T(t)\n\n    g_ET = ann_ET([norm_S0(S[1]), norm_S1(S[2]), norm_T(T)],p[:p1]) #p[idcs_params_ann_ET])\n    g_Q = ann_Q([norm_S1(S[2]), norm_P(P)],p[:p2]) #p[idcs_params_ann_Q])\n\n    melting = M(S[1], T, Df, Tmax)\n    dS[1] = Ps(P, T, Tmin) - melting\n    dS[2] = Pr(P, T, Tmin) + melting - step_fct(S[2])*Lday*exp(g_ET[1])- step_fct(S[2])*exp(g_Q[1])\n\nend\n# build and solve ODE problem\nprob = ODEProblem(NeuralODE_M50_core!, S_init, Float64.((t_out[1], maximum(t_out))), p)\nsol = solve(prob, BS3(), dt=1.0, saveat=t_out, reltol=1e-3, abstol=1e-3, sensealg=BacksolveAdjoint(autojacvec=ZygoteVJP()))\n# calculate Qout\nP_interp = norm_P.(itp_P.(t_out))\nS1_ = norm_S1.(sol[2,:])\nQout_ =  exp.(ann_Q(permutedims([S1_ P_interp]),p[:p2])[1,:])","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct a M50 Model","title":"construct a M50 Model","text":"In the HydroNODE code, we can see that model construction consists of three steps:","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct a M50 Model","title":"construct a M50 Model","text":"ODE function definition\nODE problem construction and solution\nCalculation of Qout from intermediate states","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct a M50 Model","title":"construct a M50 Model","text":"While this code follows the standard style of the DifferentialEquations.jl library, it requires manual construction of model calculation formulas (M, Ps, Pr) and their combination with state equation expressions (dS). The model has high coupling, and obtaining intermediate calculation fluxes like Qout requires additional calls to corresponding calculation formulas, making the code relatively complex to write.","category":"page"},{"location":"implements/build_m50_model_en/#M50-Implementation-in-HydroModels.jl","page":"construct a M50 Model","title":"M50 Implementation in HydroModels.jl","text":"","category":"section"},{"location":"implements/build_m50_model_en/","page":"construct a M50 Model","title":"construct a M50 Model","text":"Compared to conventional conceptual hydrological models, the M50 model uses neural networks to replace hydrological flux calculation formulas (ET and Q). These neural networks differ significantly from standard calculation formulas, so HydroModels.jl uses NeuralFlux to represent neural networks. The NeuralFlux for ET and Q predictions is shown below:","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct a M50 Model","title":"construct a M50 Model","text":"# define the ET NN and Q NN\nep_nn = Lux.Chain(\n    Lux.Dense(3 => 16, tanh),\n    Lux.Dense(16 => 16, leakyrelu),\n    Lux.Dense(16 => 1, leakyrelu),\n    name=:epnn\n)\nep_nn_params = Vector(ComponentVector(first(Lux.setup(StableRNGs.LehmerRNG(1234), ep_nn))))\nq_nn = Lux.Chain(\n    Lux.Dense(2 => 16, tanh),\n    Lux.Dense(16 => 16, leakyrelu),\n    Lux.Dense(16 => 1, leakyrelu),\n    name=:qnn\n)\nq_nn_params = Vector(ComponentVector(first(Lux.setup(StableRNGs.LehmerRNG(1234), q_nn))))\n\n\nep_nn_flux = NeuralFlux([norm_snw, norm_slw, norm_temp] => [log_evap_div_lday], ep_nn)\nq_nn_flux = NeuralFlux([norm_slw, norm_prcp] => [log_flow], q_nn)","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct a M50 Model","title":"construct a M50 Model","text":"A special aspect of building the M50 model is the need to wrap embedded neural networks using the NeuralFlux model, providing input-output information for the neural networks and converting them into expressions during construction.","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct a M50 Model","title":"construct a M50 Model","text":"Then we can build the remaining parts of the M50 model:","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct a M50 Model","title":"construct a M50 Model","text":"# define the snow pack reservoir\nsnow_funcs = [\n    HydroFlux([temp, lday] => [pet], exprs=[29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)]),\n    HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp]),\n    HydroFlux([snowpack, temp] => [melt], [Tmax, Df], exprs=[step_func(temp - Tmax) * min(snowpack, Df * (temp - Tmax))]),\n]\nsnow_dfuncs = [StateFlux([snowfall] => [melt], snowpack)]\nsnow_ele = HydroBucket(name=:exphydro_snow, funcs=snow_funcs, dfuncs=snow_dfuncs)\n\n# define the soil water reservoir\nsoil_funcs = [\n    #* normalize\n    HydroFlux([snowpack, soilwater, prcp, temp] => [norm_snw, norm_slw, norm_prcp, norm_temp],\n        [snowpack_mean, soilwater_mean, prcp_mean, temp_mean, snowpack_std, soilwater_std, prcp_std, temp_std],\n        exprs=[(var - mean) / std for (var, mean, std) in zip([snowpack, soilwater, prcp, temp],\n            [snowpack_mean, soilwater_mean, prcp_mean, temp_mean],\n            [snowpack_std, soilwater_std, prcp_std, temp_std]\n        )]),\n    ep_nn_flux,\n    q_nn_flux\n]\nstate_expr = rainfall + melt - step_func(soilwater) * lday * exp(log_evap_div_lday) - step_func(soilwater) * exp(log_flow)\nsoil_dfuncs = [StateFlux([soilwater, rainfall, melt, lday, log_evap_div_lday, log_flow], soilwater, Num[], expr=state_expr)]\nsoil_ele = HydroBucket(name=:m50_soil, funcs=soil_funcs, dfuncs=soil_dfuncs)\nconvert_flux = HydroFlux([log_flow] => [flow], exprs=[exp(log_flow)])\n# define the Exp-Hydro model\nm50_model = HydroModel(name=:m50, components=[snow_ele, soil_ele, convert_flux]);","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct a M50 Model","title":"construct a M50 Model","text":"In the code above, we present a complete implementation of the M50 model, starting with the Snowpack Bucket implementation from ExpHydro, followed by the Soilwater Bucket implementation with neural network embedding. In the Soilwater Bucket module implementation, we can use defined NeuralFlux (ep_nn_flux and q_nn_flux) to express embedded neural networks, combining them with other HydroFlux components and using StateFlux to construct the Soilwater Bucket.","category":"page"},{"location":"extent/framework comparision_zh/#比较superflexpy,-MARRMoT-和-HydroModels.jl三种库对于自定义模型的编程风格","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"","category":"section"},{"location":"extent/framework comparision_zh/","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"本内容对应了论文的4.1节的内容,我们在这里希望能够讨论三种软件库对于模型计算公式的自定义的编程风格的差异. 我们以GR4J模型的实习过程为例,对模型计算公式的自定义的编程风格进行比较.","category":"page"},{"location":"extent/framework comparision_zh/#[Superflexpy](https://github.com/dalmo1991/superflexPy/tree/master)","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"Superflexpy","text":"","category":"section"},{"location":"extent/framework comparision_zh/","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"Superflexpy是基于SUPERFLEX思想下的python代码实现, 针对于水文模型中一些计算功能的实现, 该框架一般而言是直接使用python语法表述模型的计算公式, 如下所示.","category":"page"},{"location":"extent/framework comparision_zh/","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"@staticmethod\ndef _flux_function_python(S, S0, ind, P, x1, alpha, beta, ni, PET, dt):\n    if ind is None:\n        return (\n            [\n                P * (1 - (S / x1) ** alpha), # Ps\n                -PET * (2 * (S / x1) - (S / x1) ** alpha), # Evaporation\n                -((x1 ** (1 - beta)) / ((beta - 1) * dt)) * (ni ** (beta - 1)) * (S**beta), # Perc\n            ],\n            0.0,\n            S0 + P * (1 - (S / x1) ** alpha) * dt,\n        )\n    else:\n        return (\n            [\n                P[ind] * (1 - (S / x1[ind]) ** alpha[ind]), # Ps\n                -PET[ind] * (2 * (S / x1[ind]) - (S / x1[ind]) ** alpha[ind]), # Evaporation\n                -((x1[ind] ** (1 - beta[ind])) / ((beta[ind] - 1) * dt[ind]))\n                * (ni[ind] ** (beta[ind] - 1))\n                * (S ** beta[ind]), # Perc\n            ],\n            0.0,\n            S0 + P[ind] * (1 - (S / x1[ind]) ** alpha[ind]) * dt[ind],\n            [\n                -(P[ind] * alpha[ind] / x1[ind]) * ((S / x1[ind]) ** (alpha[ind] - 1)),\n                -(PET[ind] / x1[ind]) * (2 - alpha[ind] * ((S / x1[ind]) ** (alpha[ind] - 1))),\n                -beta[ind]\n                * ((x1[ind] ** (1 - beta[ind])) / ((beta[ind] - 1) * dt[ind]))\n                * (ni[ind] ** (beta[ind] - 1))\n                * (S ** (beta[ind] - 1)),\n            ],\n        )\n\n@staticmethod\n@nb.jit(\n    \"Tuple((UniTuple(f8, 3), f8, f8, UniTuple(f8, 3)))\"\n    \"(optional(f8), f8, i4, f8[:], f8[:], f8[:], f8[:], f8[:], f8[:], f8[:])\",\n    nopython=True,\n)\ndef _flux_function_numba(S, S0, ind, P, x1, alpha, beta, ni, PET, dt):\n    return (\n        (\n            P[ind] * (1 - (S / x1[ind]) ** alpha[ind]),  # Ps\n            -PET[ind] * (2 * (S / x1[ind]) - (S / x1[ind]) ** alpha[ind]),  # Evaporation\n            -((x1[ind] ** (1 - beta[ind])) / ((beta[ind] - 1) * dt[ind]))\n            * (ni[ind] ** (beta[ind] - 1))\n            * (S ** beta[ind]),  # Perc\n        ),\n        0.0,\n        S0 + P[ind] * (1 - (S / x1[ind]) ** alpha[ind]) * dt[ind],\n        (\n            -(P[ind] * alpha[ind] / x1[ind]) * ((S / x1[ind]) ** (alpha[ind] - 1)),\n            -(PET[ind] / x1[ind]) * (2 - alpha[ind] * ((S / x1[ind]) ** (alpha[ind] - 1))),\n            -beta[ind]\n            * ((x1[ind] ** (1 - beta[ind])) / ((beta[ind] - 1) * dt[ind]))\n            * (ni[ind] ** (beta[ind] - 1))\n            * (S ** (beta[ind] - 1)),\n        ),\n    )","category":"page"},{"location":"extent/framework comparision_zh/","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"可以看出, superflexpy框架在实现GR4J的production模块计算时origin code,不仅需要分别构建numpy和numba的计算代码,在函数中需要给出模型中涉及的水文通量Ps,Evaporation,Perc,同时还要给出状态变量的平衡方程,一个代码中需要耦合多个计算过程的实现代码,不仅导致代码的复用的灵活性较差(仅能在模块层面进行复用),模型编写的代码量和重复度也较高.","category":"page"},{"location":"extent/framework comparision_zh/#[MARRMoT](https://github.com/wknoben/MARRMoT)","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"MARRMoT","text":"","category":"section"},{"location":"extent/framework comparision_zh/","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"MARRMoT是一个由MATLAB语言开发的水文模型框架,该框架根据不同水文模型会分别构建模型类型,储存模型涉及的计算公式和状态变化方程,GR4J模型在该框架下的实现代码(简化了变量命名)如下所示.","category":"page"},{"location":"extent/framework comparision_zh/","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"function [dS, fluxes] = model_fun(obj, S)\n    % definitions\n    ...\n    % fluxes functions\n    flux_pn   = max(P-Ep,0);\n    flux_en   = max(Ep-P,0);\n    flux_ef   = P - flux_pn;\n    flux_ps   = saturation_4(S1,x1,flux_pn);\n    flux_es   = evap_11(S1,x1,flux_en);\n    flux_perc = percolation_3(S1,x1);\n    flux_q9   = route(.9.*(flux_pn - flux_ps + flux_perc), uh_q9);\n    flux_q1   = route(.1.*(flux_pn - flux_ps + flux_perc), uh_q1);\n    flux_fr   = recharge_2(3.5,S2,x3,x2);\n    flux_fq   = flux_fr;\n    flux_qr   = baseflow_3(S2,x3);\n    flux_qt   = flux_qr + max(flux_q1 + flux_fq,0);\n    % this flux is not included in original MARRMoT,\n    % but it is useful to calculate the water balance\n    flux_ex = flux_fr + max(flux_q1 + flux_fq,0) - flux_q1;      \n    % stores ODEs\n    dS1 = flux_ps - flux_es - flux_perc;\n    dS2 = flux_q9 + flux_fr - flux_qr;\n    % outputs\n    dS = [dS1 dS2];\n    fluxes = [flux_pn,   flux_en, flux_ef, flux_ps, flux_es,...\n                flux_perc, flux_q9, flux_q1, flux_fr, flux_fq,...\n                flux_qr,   flux_qt, flux_ex];\nend","category":"page"},{"location":"extent/framework comparision_zh/","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"可以看出,MARRMoT框架将每一个Flux计算公式由函数进行表达,因此使用者可以直接调取函数进行计算(可以根据提供的文档进行调用),这种方式相比superflexpy的确简化了很多代码编写需求. 然而MARRMoT对于模块的重复率支持性较差,不能够像superflexpy那样进行复用. 同时将变量赋值,通量计算和状态变化方程以一个函数包括,计算内容的解耦性较差.","category":"page"},{"location":"extent/framework comparision_zh/#HydroModels.jl","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"HydroModels.jl","text":"","category":"section"},{"location":"extent/framework comparision_zh/","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"#* define the production store\nprod_funcs = [\n    HydroFlux([prcp, ep] => [pn, en], exprs=[prcp - min(prcp, ep), ep - min(prcp, ep)]),\n    HydroFlux([pn, soilwater] => [ps], [x1], exprs=[max(0.0, pn * (1 - (soilwater / x1)^2))]),\n    HydroFlux([en, soilwater] => [es], [x1], exprs=[en * (2 * soilwater / x1 - (soilwater / x1)^2)]),\n    HydroFlux([soilwater] => [perc], [x1], exprs=[((x1)^(-4)) / 4 * ((4 / 9)^(4)) * (soilwater^5)]),\n    HydroFlux([pn, ps, perc] => [pr], exprs=[pn - ps + perc]),\n    HydroFlux([pr] => [slowflow, fastflow], exprs=[0.9 * pr, 0.1 * pr]),\n]\nprod_dfuncs = [StateFlux([ps] => [es, perc], soilwater)]\nprod_ele = HydroBucket(name=:gr4j_prod, funcs=prod_funcs, dfuncs=prod_dfuncs)\n\n#* uh function\nuh_flux_1 = HydroModels.UnitHydrograph([slowflow] => [slowflow_routed], x4, uhfunc=HydroModels.UHFunction(:UH_1_HALF), solvetype=:SPARSE)\nuh_flux_2 = HydroModels.UnitHydrograph([fastflow] => [fastflow_routed], x4, uhfunc=HydroModels.UHFunction(:UH_2_FULL), solvetype=:SPARSE)\n\n#* define the routing store\nrst_funcs = [\n    HydroFlux([routingstore] => [exch], [x2, x3], exprs=[x2 * abs(routingstore / x3)^3.5]),\n    HydroFlux([routingstore, slowflow, exch] => [routedflow], [x3], exprs=[x3^(-4) / 4 * (routingstore + slowflow + exch)^5]),\n    HydroFlux([routedflow, fastflow_routed, exch] => [flow], exprs=[routedflow + max(fastflow_routed + exch, 0.0)]),\n]\nrst_dfuncs = [StateFlux([exch, slowflow] => [routedflow], routingstore)]\nrst_ele = HydroBucket(name=:gr4j_rst, funcs=rst_funcs, dfuncs=rst_dfuncs)\n\ngr4j_model = HydroModel(name=:gr4j, components=[prod_ele, uh_flux_1, uh_flux_2, rst_ele])","category":"page"},{"location":"extent/framework comparision_zh/","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"回到HydroModels.jl框架中对于GR4J模型的实现, 在该代码中我们依次对production store, unit hydrograph, routing store进行了定义, 在这个过程中,在变量对应的前提下,模型能够实现可复用的能力. 在这个搭建过程中, 包括HydroFlux, StateFlux, UnitHydrograph, HydroModel, HydroBucket等类的实例化,这些类型的实例化方式不是像前两者一样使用函数的方式构建的, 而是通过符号编程的方式对计算公式进行表达, 在模型构建完成后是通过输入数据和参数进行模型计算,可以看出这种设计思路是将模型结构与公式同参数和数据完全解耦,有着极高的可复用性.","category":"page"},{"location":"implements/build_m50_model_zh/#Embedding-Neural-Networks-in-ExpHydro-Model:-Implementation-of-[M50](https://hess.copernicus.org/articles/26/5085/2022/)-Model","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"","category":"section"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"marv-in在论文中提出了M50和M100两个模型,代码储存于HydroNODE中,开创了神经网络嵌入水文模型的先河(重点在于实现神经网络替换了ExpHydro模型的计算公式,并参与到平衡方程的求解中),这个模型也是对该仓库的启蒙,我们发现当前模型编写仍存在一定难度,因此我们创建这个仓库的首要目的就是简化神经网络嵌入水文模型这个过程,下面我们将对比源代码与本仓库在M50和M100模型上的实现差异,为使用者展现出一种新的模型搭建方式.","category":"page"},{"location":"implements/build_m50_model_zh/#HydroNODE中M50的实现方法","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"HydroNODE中M50的实现方法","text":"","category":"section"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"首先我们展示了HydroNODE中M50和M100模型的实现:","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"# define the ODE problem\nfunction NeuralODE_M50_core!(dS,S,p,t)\n\n    Tmin, Tmax, Df = (p_bucket_precal...,)\n\n    Lday = itp_Lday(t)\n    P    = itp_P(t)\n    T    = itp_T(t)\n\n    g_ET = ann_ET([norm_S0(S[1]), norm_S1(S[2]), norm_T(T)],p[:p1]) #p[idcs_params_ann_ET])\n    g_Q = ann_Q([norm_S1(S[2]), norm_P(P)],p[:p2]) #p[idcs_params_ann_Q])\n\n    melting = M(S[1], T, Df, Tmax)\n    dS[1] = Ps(P, T, Tmin) - melting\n    dS[2] = Pr(P, T, Tmin) + melting - step_fct(S[2])*Lday*exp(g_ET[1])- step_fct(S[2])*exp(g_Q[1])\n\nend\n# build and solve ODE problem\nprob = ODEProblem(NeuralODE_M50_core!, S_init, Float64.((t_out[1], maximum(t_out))), p)\nsol = solve(prob, BS3(), dt=1.0, saveat=t_out, reltol=1e-3, abstol=1e-3, sensealg=BacksolveAdjoint(autojacvec=ZygoteVJP()))\n# calculate Qout\nP_interp = norm_P.(itp_P.(t_out))\nS1_ = norm_S1.(sol[2,:])\nQout_ =  exp.(ann_Q(permutedims([S1_ P_interp]),p[:p2])[1,:])","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"在HydroNODE的代码中可以看出,模型构建分为以下三个步骤:","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"ODE函数的定义\nODE问题的构建与求解\n以及根据求解的中间状态计算Qout","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"这个代码的构建风格遵循了最标准的DifferentialEquations.jl库的风格,然而这个代码中需要手动搭建模型的计算公式(M,Ps,Pr)并与状态方程表达式组合在一起(dS),模型的耦合性极高,同时,为获取Qout等中间计算通量,还需要额外调用对应的计算公式,代码编写的繁琐性相对较高.","category":"page"},{"location":"implements/build_m50_model_zh/#HydroModels.jl中M50的实现方法","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"HydroModels.jl中M50的实现方法","text":"","category":"section"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"相比较普通的概念式水文模型,M50模型使用神经网络模型替换了水文通量的计算公式(ET和Q),这个神经网络相比普通的计算公式有着明显的差异,因此在HydroModels.jl中采用了NeuralFlux来表示神经网络, 用于ET和Q预测的NeuralFlux如下表示:","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"# define the ET NN and Q NN\nep_nn = Lux.Chain(\n    Lux.Dense(3 => 16, tanh),\n    Lux.Dense(16 => 16, leakyrelu),\n    Lux.Dense(16 => 1, leakyrelu),\n    name=:epnn\n)\nep_nn_params = Vector(ComponentVector(first(Lux.setup(StableRNGs.LehmerRNG(1234), ep_nn))))\nq_nn = Lux.Chain(\n    Lux.Dense(2 => 16, tanh),\n    Lux.Dense(16 => 16, leakyrelu),\n    Lux.Dense(16 => 1, leakyrelu),\n    name=:qnn\n)\nq_nn_params = Vector(ComponentVector(first(Lux.setup(StableRNGs.LehmerRNG(1234), q_nn))))\n\n\nep_nn_flux = NeuralFlux([norm_snw, norm_slw, norm_temp] => [log_evap_div_lday], ep_nn)\nq_nn_flux = NeuralFlux([norm_slw, norm_prcp] => [log_flow], q_nn)","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"构建M50模型相对特殊的一点在于需要针对嵌入的神经网络使用NeuralFlux模型进行包装,为神经网络赋予输入输出的信息,并在构建过程中将神经网络转换为表达式.","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"然后我们可以构建M50模型的其余部分:","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"# define the snow pack reservoir\nsnow_funcs = [\n    HydroFlux([temp, lday] => [pet], exprs=[29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)]),\n    HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp]),\n    HydroFlux([snowpack, temp] => [melt], [Tmax, Df], exprs=[step_func(temp - Tmax) * min(snowpack, Df * (temp - Tmax))]),\n]\nsnow_dfuncs = [StateFlux([snowfall] => [melt], snowpack)]\nsnow_ele = HydroBucket(name=:exphydro_snow, funcs=snow_funcs, dfuncs=snow_dfuncs)\n\n# define the soil water reservoir\nsoil_funcs = [\n    #* normalize\n    HydroFlux([snowpack, soilwater, prcp, temp] => [norm_snw, norm_slw, norm_prcp, norm_temp],\n        [snowpack_mean, soilwater_mean, prcp_mean, temp_mean, snowpack_std, soilwater_std, prcp_std, temp_std],\n        exprs=[(var - mean) / std for (var, mean, std) in zip([snowpack, soilwater, prcp, temp],\n            [snowpack_mean, soilwater_mean, prcp_mean, temp_mean],\n            [snowpack_std, soilwater_std, prcp_std, temp_std]\n        )]),\n    ep_nn_flux,\n    q_nn_flux\n]\nstate_expr = rainfall + melt - step_func(soilwater) * lday * exp(log_evap_div_lday) - step_func(soilwater) * exp(log_flow)\nsoil_dfuncs = [StateFlux([soilwater, rainfall, melt, lday, log_evap_div_lday, log_flow], soilwater, Num[], expr=state_expr)]\nsoil_ele = HydroBucket(name=:m50_soil, funcs=soil_funcs, dfuncs=soil_dfuncs)\nconvert_flux = HydroFlux([log_flow] => [flow], exprs=[exp(log_flow)])\n# define the Exp-Hydro model\nm50_model = HydroModel(name=:m50, components=[snow_ele, soil_ele, convert_flux]);","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"上述代码中我们对M50模型进行了一个完整的表现,首先包括ExpHydro中Snowpack Bucket的实现,其次就是对于神经网络嵌入后Soilwater Bucket的实现. 在Soilwater Bucket模块实现中,可以通过定义的NeuralFlux(ep_nn_flux和q_nn_flux)来表达嵌入的神经网络,并与其他HydroFlux进行组合,结合StateFlux构建Soilwater Bucket.","category":"page"},{"location":"implements/build_exphydro_model_en/#Build-an-ExpHydro-Model","page":"construct a ExpHydro Model","title":"Build an ExpHydro Model","text":"","category":"section"},{"location":"implements/build_exphydro_model_en/#Introduction-to-ExpHydro-Model","page":"construct a ExpHydro Model","title":"Introduction to ExpHydro Model","text":"","category":"section"},{"location":"implements/build_exphydro_model_en/","page":"construct a ExpHydro Model","title":"construct a ExpHydro Model","text":"This section demonstrates how to build a simple hydrological model - the ExpHydro model - using HydroModels.jl, serving as an introduction to conceptual model construction. The ExpHydro model consists of two computational modules: the Snowpack Bucket and the Soilwater Bucket. Their mathematical formulations are as follows:","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct a ExpHydro Model","title":"construct a ExpHydro Model","text":"beginaligned\n textSnowpack Bucket \n pet = 298 cdot lday cdot 24 cdot 0611 cdot fracexp(173 cdot temp)temp + 2373 cdot frac1temp + 2732  (1) \n snowfall = H(T_min - temp) cdot prcp  (2) \n rainfall = H(temp - T_min) cdot prcp  (3) \n melt = H(temp - T_max) cdot H(snowpack) cdot min(snowpack D_f cdot (temp - T_max))  (4) \n fracd(snowpack)dt = snowfall - melt  (5) \n\n textSoilwater Bucket \n evap = H(soilwater) cdot pet cdot min(10 fracsoilwaterS_max)  (6) \n baseflow = H(soilwater) cdot Q_max cdot exp(-f cdot max(00 S_max - soilwater))  (7) \n surfaceflow = max(00 soilwater - S_max)  (8) \n flow = baseflow + surfaceflow  (9) \n fracd(soilwater)dt = rainfall + melt - evap - flow  (10)\nendaligned","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct a ExpHydro Model","title":"construct a ExpHydro Model","text":"Where: H(x) represents the Heaviside step function, equals 1 when x  0, otherwise 0; T_min T_max D_f S_max Q_max f are model parameters;temp lday prcp are input variables;snowpack soilwater are state variables;Other variables are intermediate calculation variables","category":"page"},{"location":"implements/build_exphydro_model_en/#Complete-Model-Construction-Process","page":"construct a ExpHydro Model","title":"Complete Model Construction Process","text":"","category":"section"},{"location":"implements/build_exphydro_model_en/","page":"construct a ExpHydro Model","title":"construct a ExpHydro Model","text":"# import packages\nusing HydroModels\n\n# define variables and parameters\n@variables temp lday pet prcp \n@variables snowfall rainfall melt evap baseflow surfaceflow flow\n@variables snowpack soilwater\n@parameters Tmin Tmax Df Smax Qmax f\n\n# define snowpack bucket\nfluxes_1 = [\n    HydroFlux([temp, lday] => [pet], exprs=[29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)]),\n    HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp]),\n    HydroFlux([snowpack, temp] => [melt], [Tmax, Df], exprs=[step_func(temp - Tmax) * step_func(snowpack) * min(snowpack, Df * (temp - Tmax))]),\n]\ndfluxes_1 = [StateFlux([snowfall] => [melt], snowpack),]\nsnowpack_bucket = HydroBucket(name=:surface, funcs=fluxes_1, dfuncs=dfluxes_1)\n\n# define soilwater bucket\nfluxes_2 = [\n    HydroFlux([soilwater, pet] => [evap], [Smax], exprs=[step_func(soilwater) * pet * min(1.0, soilwater / Smax)]),\n    HydroFlux([soilwater] => [baseflow], [Smax, Qmax, f], exprs=[step_func(soilwater) * Qmax * exp(-f * (max(0.0, Smax - soilwater)))]),\n    HydroFlux([soilwater] => [surfaceflow], [Smax], exprs=[max(0.0, soilwater - Smax)]),\n    HydroFlux([baseflow, surfaceflow] => [flow], exprs=[baseflow + surfaceflow]),\n]\ndfluxes_2 = [StateFlux([rainfall, melt] => [evap, flow], soilwater)]\nsoilwater_bucket = HydroBucket(name=:soil, funcs=fluxes_2, dfuncs=dfluxes_2)\n\n# define the Exp-Hydro model\nexphydro_model = HydroModel(name=:exphydro, components=[snowpack_bucket, soilwater_bucket])","category":"page"},{"location":"implements/build_exphydro_model_en/#Step-by-Step-Analysis","page":"construct a ExpHydro Model","title":"Step-by-Step Analysis","text":"","category":"section"},{"location":"implements/build_exphydro_model_en/","page":"construct a ExpHydro Model","title":"construct a ExpHydro Model","text":"Let's break down the model construction process into detailed steps.","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct a ExpHydro Model","title":"construct a ExpHydro Model","text":"First, we need to import the HydroModels.jl dependency:","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct a ExpHydro Model","title":"construct a ExpHydro Model","text":"using HydroModels","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct a ExpHydro Model","title":"construct a ExpHydro Model","text":"By importing the HydroModels module, we gain direct access to types defined in HydroFlux, StateFlux, HydroBucket, and HydroModel modules. Additionally, the package exports macros from ModelingToolkit.jl such as @variables and @parameters, which are used for defining and manipulating variables and parameters in hydrological models:","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct a ExpHydro Model","title":"construct a ExpHydro Model","text":"@variables temp lday prcp \n@variables snowfall rainfall melt evap baseflow surfaceflow flow pet\n@variables snowpack soilwater\n@parameters Tmin Tmax Df Smax Qmax f","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct a ExpHydro Model","title":"construct a ExpHydro Model","text":"In this code segment, we define all variables used in the ExpHydro model, including:","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct a ExpHydro Model","title":"construct a ExpHydro Model","text":"Input variables: temperature (temp), day length (lday), and precipitation (prcp)\nIntermediate calculation variables: pet, snowfall, rainfall, melt, evap, baseflow, surfaceflow, flow\nState variables: snowpack and soilwater\nModel parameters: Tmin, Tmax, Df, Smax, Qmax, and f","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct a ExpHydro Model","title":"construct a ExpHydro Model","text":"The definition of HydroFlux requires determining input/output variables and model parameters based on calculation formulas. For example, in the rain-snow partitioning formula, the input variables are prcp and temp, output variables are snowfall and rainfall, and the model parameter is Tmin. The formula translation to HydroFlux looks like this:","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct a ExpHydro Model","title":"construct a ExpHydro Model","text":"split_flux = HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp])","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct a ExpHydro Model","title":"construct a ExpHydro Model","text":"The definition of StateFlux is based on the balance equation of state variables. Generally, the balance equation equates the rate of change of the state variable to the difference between input and output fluxes. For example, the balance equation for snowpack is the difference between snowfall and melt. The formula translation to StateFlux looks like this:","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct a ExpHydro Model","title":"construct a ExpHydro Model","text":"snowpack_dflux = StateFlux([snowfall] => [melt], snowpack)","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct a ExpHydro Model","title":"construct a ExpHydro Model","text":"Next, we define the model calculation formulas using HydroFlux and StateFlux, and integrate them into HydroBucket to create the Snowpack Bucket and Soilwater Bucket components:","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct a ExpHydro Model","title":"construct a ExpHydro Model","text":"# define snowpack bucket\nfluxes_1 = [\n    HydroFlux([temp, lday] => [pet], exprs=[29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)]),\n    HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp]),\n    HydroFlux([snowpack, temp] => [melt], [Tmax, Df], exprs=[step_func(temp - Tmax) * step_func(snowpack) * min(snowpack, Df * (temp - Tmax))]),\n]\ndfluxes_1 = [StateFlux([snowfall] => [melt], snowpack),]\nsnowpack_bucket = HydroBucket(name=:surface, funcs=fluxes_1, dfuncs=dfluxes_1)\n\n# define soilwater bucket\nfluxes_2 = [\n    HydroFlux([soilwater, pet] => [evap], [Smax], exprs=[step_func(soilwater) * pet * min(1.0, soilwater / Smax)]),\n    HydroFlux([soilwater] => [baseflow], [Smax, Qmax, f], exprs=[step_func(soilwater) * Qmax * exp(-f * (max(0.0, Smax - soilwater)))]),\n    HydroFlux([soilwater] => [surfaceflow], [Smax], exprs=[max(0.0, soilwater - Smax)]),\n    HydroFlux([baseflow, surfaceflow] => [flow], exprs=[baseflow + surfaceflow]),\n]\ndfluxes_2 = [StateFlux([rainfall, melt] => [evap, flow], soilwater)]\nsoilwater_bucket = HydroBucket(name=:soil, funcs=fluxes_2, dfuncs=dfluxes_2)","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct a ExpHydro Model","title":"construct a ExpHydro Model","text":"The construction of HydroBucket consists of HydroFlux and StateFlux, where HydroFlux defines the model's calculation formulas, and StateFlux defines the balance equations for state variables.","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct a ExpHydro Model","title":"construct a ExpHydro Model","text":"Finally, we combine the HydroBucket components into a HydroModel to create the complete ExpHydro model:","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct a ExpHydro Model","title":"construct a ExpHydro Model","text":"# define the Exp-Hydro model\nexphydro_model = HydroModel(name=:exphydro, components=[snowpack_bucket, soilwater_bucket])","category":"page"},{"location":"implements/build_exphydro_model_zh/#构建ExpHydro模型","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"","category":"section"},{"location":"implements/build_exphydro_model_zh/#ExpHydro模型介绍","page":"构建ExpHydro模型","title":"ExpHydro模型介绍","text":"","category":"section"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"本节将基于 HydroModels.jl 构建一个结构较为简单的水文模型-ExpHydro 模型,以此来开启概念式模型搭建的教程。 首先对 ExpHydro 模型进行介绍,该模型由 Snowpack Bucket 和 Soilwater Bucket 两个计算模块组成,其计算公式如下：","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"beginaligned\n textSnowpack Bucket \n pet = 298 cdot lday cdot 24 cdot 0611 cdot fracexp(173 cdot temp)temp + 2373 cdot frac1temp + 2732  (1) \n snowfall = H(T_min - temp) cdot prcp  (2) \n rainfall = H(temp - T_min) cdot prcp  (3) \n melt = H(temp - T_max) cdot H(snowpack) cdot min(snowpack D_f cdot (temp - T_max))  (4) \n fracd(snowpack)dt = snowfall - melt  (5) \n\n textSoilwater Bucket \n evap = H(soilwater) cdot pet cdot min(10 fracsoilwaterS_max)  (6) \n baseflow = H(soilwater) cdot Q_max cdot exp(-f cdot max(00 S_max - soilwater))  (7) \n surfaceflow = max(00 soilwater - S_max)  (8) \n flow = baseflow + surfaceflow  (9) \n fracd(soilwater)dt = rainfall + melt - evap - flow  (10)\nendaligned","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"其中:","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"H(x)\n表示Heaviside阶跃函数，当 x  0 时为1，否则为0\nT_min T_max D_f S_max Q_max f\n为模型参数\ntemp lday prcp\n为输入变量\nsnowpack soilwater\n为状态变量\n其余变量为中间计算变量","category":"page"},{"location":"implements/build_exphydro_model_zh/#完整的模型构建过程","page":"构建ExpHydro模型","title":"完整的模型构建过程","text":"","category":"section"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"# import packages\nusing HydroModels\n\n# define variables and parameters\n@variables temp lday pet prcp \n@variables snowfall rainfall melt evap baseflow surfaceflow flow\n@variables snowpack soilwater\n@parameters Tmin Tmax Df Smax Qmax f\n\n# define snowpack bucket\nfluxes_1 = [\n    HydroFlux([temp, lday] => [pet], exprs=[29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)]),\n    HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp]),\n    HydroFlux([snowpack, temp] => [melt], [Tmax, Df], exprs=[step_func(temp - Tmax) * step_func(snowpack) * min(snowpack, Df * (temp - Tmax))]),\n]\ndfluxes_1 = [StateFlux([snowfall] => [melt], snowpack),]\nsnowpack_bucket = HydroBucket(name=:surface, funcs=fluxes_1, dfuncs=dfluxes_1)\n\n# define soilwater bucket\nfluxes_2 = [\n    HydroFlux([soilwater, pet] => [evap], [Smax], exprs=[step_func(soilwater) * pet * min(1.0, soilwater / Smax)]),\n    HydroFlux([soilwater] => [baseflow], [Smax, Qmax, f], exprs=[step_func(soilwater) * Qmax * exp(-f * (max(0.0, Smax - soilwater)))]),\n    HydroFlux([soilwater] => [surfaceflow], [Smax], exprs=[max(0.0, soilwater - Smax)]),\n    HydroFlux([baseflow, surfaceflow] => [flow], exprs=[baseflow + surfaceflow]),\n]\ndfluxes_2 = [StateFlux([rainfall, melt] => [evap, flow], soilwater)]\nsoilwater_bucket = HydroBucket(name=:soil, funcs=fluxes_2, dfuncs=dfluxes_2)\n\n# define the Exp-Hydro model\nexphydro_model = HydroModel(name=:exphydro, components=[snowpack_bucket, soilwater_bucket])","category":"page"},{"location":"implements/build_exphydro_model_zh/#分段剖析","page":"构建ExpHydro模型","title":"分段剖析","text":"","category":"section"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"接下来我们将分块对模型构建过程进行介绍.","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"首先需要引入HydroModels.jl的依赖:","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"using HydroModels","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"通过导入HydroModels模块,可以直接访问HydroFlux,StateFlux,HydroBucket,HydroModel等模块定义的类型,同时还该包导出了ModelingToolkit.jl包中@variables,@parameters等宏,可以用于水文模型中变量和参数的定义和操作, 如下所示:","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"@variables temp lday prcp \n@variables snowfall rainfall melt evap baseflow surfaceflow flow pet\n@variables snowpack soilwater\n@parameters Tmin Tmax Df Smax Qmax f","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"在这段代码中,需要将ExpHydro模型中所有变量进行定义,包括输入变量温度(temp),日照时长(lday)和降水(prcp),同时给出了ExpHydro模型中所有变量的中间计算变量,如pet, snowfall, rainfall, melt, evap, baseflow, surfaceflow, flow等,以及ExpHydro模型的状态变量snowpack和soilwater,以及ExpHydro模型的参数Tmin, Tmax, Df, Smax, Qmax和f.","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"HydroFlux的定义需要根据计算公式确定模型的输入输出变量和模型参数,例如在模型的雨雪划分计算公式,该公式的输入变量为prcp和temp,输出变量为snowfall和rainfall,模型参数为Tmin, 公式转译为HydroFlux的结果如下所示:","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"split_flux = HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp])","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"StateFlux的定义是根据状态变量的平衡方程, 一般来说平衡方程是状态变量的变化率等于输入输出通量的差值得到,例如snowpack的平衡方程是snowfall和melt的差值, 公式转译为StateFlux的结果如下所示:","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"snowpack_dflux = StateFlux([snowfall] => [melt], snowpack)","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"接着根据模型计算公式通过HydroFlux和StateFlux进行定义, 并将其整合为HydroBucket,得到Snowpack Bucket和Soilwater Bucket如下所示:","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"# define snowpack bucket\nfluxes_1 = [\n    HydroFlux([temp, lday] => [pet], exprs=[29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)]),\n    HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp]),\n    HydroFlux([snowpack, temp] => [melt], [Tmax, Df], exprs=[step_func(temp - Tmax) * step_func(snowpack) * min(snowpack, Df * (temp - Tmax))]),\n]\ndfluxes_1 = [StateFlux([snowfall] => [melt], snowpack),]\nsnowpack_bucket = HydroBucket(name=:surface, funcs=fluxes_1, dfuncs=dfluxes_1)\n\n# define soilwater bucket\nfluxes_2 = [\n    HydroFlux([soilwater, pet] => [evap], [Smax], exprs=[step_func(soilwater) * pet * min(1.0, soilwater / Smax)]),\n    HydroFlux([soilwater] => [baseflow], [Smax, Qmax, f], exprs=[step_func(soilwater) * Qmax * exp(-f * (max(0.0, Smax - soilwater)))]),\n    HydroFlux([soilwater] => [surfaceflow], [Smax], exprs=[max(0.0, soilwater - Smax)]),\n    HydroFlux([baseflow, surfaceflow] => [flow], exprs=[baseflow + surfaceflow]),\n]\ndfluxes_2 = [StateFlux([rainfall, melt] => [evap, flow], soilwater)]\nsoilwater_bucket = HydroBucket(name=:soil, funcs=fluxes_2, dfuncs=dfluxes_2)","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"HydroBucket的构建由HydroFlux和StateFlux组成, 其中HydroFlux用于定义模型的计算公式,StateFlux用于定义状态变量的平衡方程.","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"最后将HydroBucket组合成HydroModel,作为components输入到模型中,得到ExpHydro模型如下所示:","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"# define the Exp-Hydro model\nexphydro_model = HydroModel(name=:exphydro, components=[snowpack_bucket, soilwater_bucket])","category":"page"},{"location":"tutorials/run_a_exphydro_model/#ExpHydro-Model-Tutorial","page":"Run ExpHydro Model","title":"ExpHydro Model Tutorial","text":"","category":"section"},{"location":"tutorials/run_a_exphydro_model/#Overview","page":"Run ExpHydro Model","title":"Overview","text":"","category":"section"},{"location":"tutorials/run_a_exphydro_model/","page":"Run ExpHydro Model","title":"Run ExpHydro Model","text":"This tutorial demonstrates how to use the ExpHydro model for hydrological calculations, including:","category":"page"},{"location":"tutorials/run_a_exphydro_model/","page":"Run ExpHydro Model","title":"Run ExpHydro Model","text":"Lumped calculation (Single HRU)\nDistributed calculation (Multiple HRUs)","category":"page"},{"location":"tutorials/run_a_exphydro_model/#Dependencies","page":"Run ExpHydro Model","title":"Dependencies","text":"","category":"section"},{"location":"tutorials/run_a_exphydro_model/","page":"Run ExpHydro Model","title":"Run ExpHydro Model","text":"First, import the required Julia packages:","category":"page"},{"location":"tutorials/run_a_exphydro_model/","page":"Run ExpHydro Model","title":"Run ExpHydro Model","text":"using CSV            # Data reading\nusing DataFrames     # Data processing\nusing ComponentArrays # Parameter organization\nusing BenchmarkTools # Performance testing\nusing NamedTupleTools # Named tuple utilities\nusing Plots         # Result visualization","category":"page"},{"location":"tutorials/run_a_exphydro_model/#Model-Setup","page":"Run ExpHydro Model","title":"Model Setup","text":"","category":"section"},{"location":"tutorials/run_a_exphydro_model/#Parameter-Configuration","page":"Run ExpHydro Model","title":"Parameter Configuration","text":"","category":"section"},{"location":"tutorials/run_a_exphydro_model/","page":"Run ExpHydro Model","title":"Run ExpHydro Model","text":"The ExpHydro model contains 6 key parameters defined using ComponentVector:","category":"page"},{"location":"tutorials/run_a_exphydro_model/","page":"Run ExpHydro Model","title":"Run ExpHydro Model","text":"Parameter Value Description\nf 0.01674478 Infiltration parameter\nSmax 1709.461015 Maximum soil water storage\nQmax 18.46996175 Maximum discharge\nDf 2.674548848 Degree-day factor\nTmax 0.175739196 Maximum temperature threshold\nTmin -2.092959084 Minimum temperature threshold","category":"page"},{"location":"tutorials/run_a_exphydro_model/","page":"Run ExpHydro Model","title":"Run ExpHydro Model","text":"# Define model parameters\nparams = ComponentVector(\n    f = 0.01674478,    # Infiltration parameter\n    Smax = 1709.461015, # Maximum soil water storage\n    Qmax = 18.46996175, # Maximum discharge\n    Df = 2.674548848,   # Degree-day factor\n    Tmax = 0.175739196, # Maximum temperature threshold\n    Tmin = -2.092959084 # Minimum temperature threshold\n)","category":"page"},{"location":"tutorials/run_a_exphydro_model/#Initial-States","page":"Run ExpHydro Model","title":"Initial States","text":"","category":"section"},{"location":"tutorials/run_a_exphydro_model/","page":"Run ExpHydro Model","title":"Run ExpHydro Model","text":"Set initial states for the two calculation modules:","category":"page"},{"location":"tutorials/run_a_exphydro_model/","page":"Run ExpHydro Model","title":"Run ExpHydro Model","text":"# Define initial states\ninistates = ComponentVector(\n    snowpack = 0.0,           # Snow accumulation\n    soilwater = 1303.004248   # Soil water content\n)","category":"page"},{"location":"tutorials/run_a_exphydro_model/#Data-Preparation","page":"Run ExpHydro Model","title":"Data Preparation","text":"","category":"section"},{"location":"tutorials/run_a_exphydro_model/","page":"Run ExpHydro Model","title":"Run ExpHydro Model","text":"The model uses hydrometeorological data from \"data/exphydro/01013500.csv\":","category":"page"},{"location":"tutorials/run_a_exphydro_model/","page":"Run ExpHydro Model","title":"Run ExpHydro Model","text":"# Read input data\nfile_path = \"data/exphydro/01013500.csv\"\ndata = CSV.File(file_path)\ndf = DataFrame(data)\nts = collect(1:10000)  # Time series length","category":"page"},{"location":"tutorials/run_a_exphydro_model/","page":"Run ExpHydro Model","title":"Run ExpHydro Model","text":"Input variables include:","category":"page"},{"location":"tutorials/run_a_exphydro_model/","page":"Run ExpHydro Model","title":"Run ExpHydro Model","text":"Day length (dayl)\nMean temperature (tmean)\nPrecipitation (prcp)","category":"page"},{"location":"tutorials/run_a_exphydro_model/#Model-Testing","page":"Run ExpHydro Model","title":"Model Testing","text":"","category":"section"},{"location":"tutorials/run_a_exphydro_model/#Single-Node-Testing","page":"Run ExpHydro Model","title":"Single Node Testing","text":"","category":"section"},{"location":"tutorials/run_a_exphydro_model/","page":"Run ExpHydro Model","title":"Run ExpHydro Model","text":"# Configure solver\nsolver = HydroModels.ManualSolver()\n\n# Run model with benchmarking\nresult = model(input, params, config=(solver=solver, timeidx=ts), convert_to_ntp=true)\n\n# Visualize results\nplot(result.flow, label=\"Simulated\")\nplot!(df[ts, \"flow(mm)\"], label=\"Observed\")","category":"page"},{"location":"tutorials/run_a_exphydro_model/#Single-Node-Benchmarking","page":"Run ExpHydro Model","title":"Single Node Benchmarking","text":"","category":"section"},{"location":"tutorials/run_a_exphydro_model/","page":"Run ExpHydro Model","title":"Run ExpHydro Model","text":"# Performance testing using BenchmarkTools\n@btime model(input, params, config=(solver=solver, timeidx=ts), convert_to_ntp=true);","category":"page"},{"location":"tutorials/run_a_exphydro_model/#Multi-Node-Testing","page":"Run ExpHydro Model","title":"Multi-Node Testing","text":"","category":"section"},{"location":"tutorials/run_a_exphydro_model/","page":"Run ExpHydro Model","title":"Run ExpHydro Model","text":"Multi-node setup for distributed computing:","category":"page"},{"location":"tutorials/run_a_exphydro_model/","page":"Run ExpHydro Model","title":"Run ExpHydro Model","text":"# Setup multiple nodes\nnode_num = 10  # Number of nodes\ninputs = repeat([input], node_num)\nptypes = [Symbol(:node, i) for i in 1:node_num]\n\n# Configure parameters and states for multiple nodes\nparams_multi = ComponentVector(NamedTuple{Tuple(ptypes)}(repeat([params], node_num)))\ninit_states_multi = ComponentVector(NamedTuple{Tuple(ptypes)}(repeat([inistates], node_num)))\n\n# Run multi-node simulation\nresults = model(inputs, params_multi, config=(solver=solver, timeidx=ts), convert_to_ntp=true)","category":"page"},{"location":"tutorials/run_a_exphydro_model/#Multi-Node-Benchmarking","page":"Run ExpHydro Model","title":"Multi-Node Benchmarking","text":"","category":"section"},{"location":"tutorials/run_a_exphydro_model/","page":"Run ExpHydro Model","title":"Run ExpHydro Model","text":"```julia","category":"page"},{"location":"tutorials/run_a_exphydro_model/#Multi-node-performance-testing","page":"Run ExpHydro Model","title":"Multi-node performance testing","text":"","category":"section"},{"location":"tutorials/run_a_exphydro_model/","page":"Run ExpHydro Model","title":"Run ExpHydro Model","text":"@btime model(inputs, paramsmulti, config=(solver=solver, timeidx=ts), convertto_ntp=true);","category":"page"},{"location":"implements/build_discharge_route_en/#Building-a-Discharge-Routing-Model","page":"construct discharge route model","title":"Building a Discharge Routing Model","text":"","category":"section"},{"location":"implements/build_discharge_route_en/#Mathematical-Formulation","page":"construct discharge route model","title":"Mathematical Formulation","text":"","category":"section"},{"location":"implements/build_discharge_route_en/","page":"construct discharge route model","title":"construct discharge route model","text":"The discharge routing model is based on the following equations:","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct discharge route model","title":"construct discharge route model","text":"beginaligned\nfracdS_rfndt = Q_rfup - Q_rfn  (1) \nQ_rfn = fracS_rfntextLAG_rf + Q_rfn-1  (2) \nQ_rfup = sum_i in up(n) Q_rfi  (3) \nQ_rf = Q_rfn + (R_sw + R_gw) cdot A_gc  (4)\nendaligned","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct discharge route model","title":"construct discharge route model","text":"where n is the reach index, ranging from 1c_max; Delta S_rfn is the storage change in reach n; Q_rfn is the outflow from reach n; S_rfn is the storage in reach n; textLAG_rf is the routing lag parameter; Q_rfup is the inflow from upstream reaches; R_sw and R_gw are surface and groundwater runoff; A_gc is the grid cell area; c_max is the maximum number of reaches.","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct discharge route model","title":"construct discharge route model","text":"The equations describe: (1) storage change in the reach, (2) reach outflow calculation, (3) upstream inflow accumulation, and (4) final discharge calculation. This approach determines the inflow to each Hydrological Response Unit (HRU) based on its upstream inputs, which can be represented using two different routing functions. The outflow from the current HRU is calculated using the current reach storage S_rfn and combined with the HRU's R_sw and R_gw (after area conversion) to obtain the final discharge Q_rf.","category":"page"},{"location":"implements/build_discharge_route_en/#Implementation-in-HydroModels.jl","page":"construct discharge route model","title":"Implementation in HydroModels.jl","text":"","category":"section"},{"location":"implements/build_discharge_route_en/#Modified-Calculation-Formula","page":"construct discharge route model","title":"Modified Calculation Formula","text":"","category":"section"},{"location":"implements/build_discharge_route_en/","page":"construct discharge route model","title":"construct discharge route model","text":"In the HydroModels.jl framework, this storage-based discharge calculation method is represented by the HydroRoute type, which solves the problem continuously through ODE equations. The implementation differs from the original formula in that it assumes no instantaneous changes when calculating Q_rfn, transforming equation (2) into:","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct discharge route model","title":"construct discharge route model","text":"beginaligned\nQ_rfn = S_rfn cdot frac1textLAG_rf + 1  (5)\nendaligned","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct discharge route model","title":"construct discharge route model","text":"The Q_rfn-1 term is removed because in continuous change, S_rfn is constantly evolving, making it unnecessary to consider Q_rfn-1 in calculating Q_rfn. Additionally, there are dimensional differences between S_rfn and Q_rfn, and including Q_rfn would add an instantaneous state variable, which is unsuitable as a state variable. In HydroRoute construction, the primary focus is expressing the outflow calculation formula. Like HydroBucket, HydroRoute accepts HydroFlux to represent the Q_rfn calculation formula:","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct discharge route model","title":"construct discharge route model","text":"# Define parameters and variables\n@variables q q_routed s_river\n@parameters lag\n# Define routing flux\nrflux = HydroFlux([q, s_river] => [q_routed], [lag], exprs=[s_river / (1 + lag) + q])","category":"page"},{"location":"implements/build_discharge_route_en/#Flow-Accumulation-Functions","page":"construct discharge route model","title":"Flow Accumulation Functions","text":"","category":"section"},{"location":"implements/build_discharge_route_en/","page":"construct discharge route model","title":"construct discharge route model","text":"The method of obtaining upstream flow inputs is another crucial component of the routing model. Flow accumulation functions are typically used to calculate the upstream inflow for each HRU. This accumulation can be represented using either Grid-Based or Vector-Based approaches, corresponding to two types of HydroRoute construction in HydroModels.jl: GridRoute and VectorRoute.","category":"page"},{"location":"implements/build_discharge_route_en/#Vector-Based-Routing-Model","page":"construct discharge route model","title":"Vector-Based Routing Model","text":"","category":"section"},{"location":"implements/build_discharge_route_en/","page":"construct discharge route model","title":"construct discharge route model","text":"The Vector-Based routing model is based on watershed subdivision and topological relationships, using an adjacency matrix for flow accumulation:","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct discharge route model","title":"construct discharge route model","text":"# Build river network topology\nnetwork = DiGraph(9)\nadd_edge!(network, 1, 2)\nadd_edge!(network, 2, 5)\nadd_edge!(network, 3, 5)\nadd_edge!(network, 4, 5)\nadd_edge!(network, 5, 8)\nadd_edge!(network, 6, 9)\nadd_edge!(network, 7, 8)\nadd_edge!(network, 8, 9)\nvroute = HydroModels.VectorRoute(rfunc=rflux, rstate=s_river, network=network)","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct discharge route model","title":"construct discharge route model","text":"The code uses Graphs.jl's DiGraph data structure to represent watershed topology, which, along with the constructed rflux and s_river, completes the Vector-Based routing model construction.","category":"page"},{"location":"implements/build_discharge_route_en/#Grid-Based-Routing-Model","page":"construct discharge route model","title":"Grid-Based Routing Model","text":"","category":"section"},{"location":"implements/build_discharge_route_en/","page":"construct discharge route model","title":"construct discharge route model","text":"The Grid-Based routing model represents HRU connectivity using a D8 flow direction matrix. The construction is based on the D8 matrix and corresponding HRU coordinates:","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct discharge route model","title":"construct discharge route model","text":"# Build river network topology\nflwdir = [1 4 8; 1 4 4; 1 1 2]\npositions = [[1, 1], [1, 2], [1, 3], [2, 1], [2, 2], [2, 3], [3, 1], [3, 2], [3, 3]]\ngroute = HydroModels.GridRoute(rfunc=rflux, rstate=s_river, flwdir=flwdir, positions=positions)","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct discharge route model","title":"construct discharge route model","text":"The code uses matrix data to represent flow direction and HRU coordinates, which, combined with the constructed rflux and s_river, completes the Grid-Based routing model construction.","category":"page"},{"location":"tutorials/run_a_bucket/#HydroModels-Bucket-Model-Implementation-Example","page":"Run a Bucket Model","title":"HydroModels Bucket Model Implementation Example","text":"","category":"section"},{"location":"tutorials/run_a_bucket/#Overview","page":"Run a Bucket Model","title":"Overview","text":"","category":"section"},{"location":"tutorials/run_a_bucket/","page":"Run a Bucket Model","title":"Run a Bucket Model","text":"This document demonstrates the implementation and usage of a hydrological bucket model using the HydroModels framework. The code showcases both single-node and multi-node simulations using the ExpHydro model structure.","category":"page"},{"location":"tutorials/run_a_bucket/#Dependencies","page":"Run a Bucket Model","title":"Dependencies","text":"","category":"section"},{"location":"tutorials/run_a_bucket/","page":"Run a Bucket Model","title":"Run a Bucket Model","text":"using CSV\nusing DataFrames\nusing ComponentArrays\nusing BenchmarkTools\nusing HydroModels\nusing ModelingToolkit","category":"page"},{"location":"tutorials/run_a_bucket/#Model-Configuration","page":"Run a Bucket Model","title":"Model Configuration","text":"","category":"section"},{"location":"tutorials/run_a_bucket/#Parameter-Setup","page":"Run a Bucket Model","title":"Parameter Setup","text":"","category":"section"},{"location":"tutorials/run_a_bucket/","page":"Run a Bucket Model","title":"Run a Bucket Model","text":"The model uses the following parameters for the hydrological simulation:","category":"page"},{"location":"tutorials/run_a_bucket/","page":"Run a Bucket Model","title":"Run a Bucket Model","text":"f: 0.01674478 (Infiltration parameter)\nSmax: 1709.461015 (Maximum soil water storage)\nQmax: 18.46996175 (Maximum discharge)\nDf: 2.674548848 (Degree-day factor)\nTmax: 0.175739196 (Maximum temperature threshold)\nTmin: -2.092959084 (Minimum temperature threshold)","category":"page"},{"location":"tutorials/run_a_bucket/#Initial-States","page":"Run a Bucket Model","title":"Initial States","text":"","category":"section"},{"location":"tutorials/run_a_bucket/","page":"Run a Bucket Model","title":"Run a Bucket Model","text":"Initial conditions for the model:","category":"page"},{"location":"tutorials/run_a_bucket/","page":"Run a Bucket Model","title":"Run a Bucket Model","text":"snowpack: 0.0\nsoilwater: 1303.004248","category":"page"},{"location":"tutorials/run_a_bucket/#Data-Input","page":"Run a Bucket Model","title":"Data Input","text":"","category":"section"},{"location":"tutorials/run_a_bucket/","page":"Run a Bucket Model","title":"Run a Bucket Model","text":"The model uses time series data from a CSV file located at \"data/exphydro/01013500.csv\" containing:","category":"page"},{"location":"tutorials/run_a_bucket/","page":"Run a Bucket Model","title":"Run a Bucket Model","text":"Day length (dayl)\nMean temperature (tmean)\nPrecipitation (prcp)","category":"page"},{"location":"tutorials/run_a_bucket/#Implementation-Examples","page":"Run a Bucket Model","title":"Implementation Examples","text":"","category":"section"},{"location":"tutorials/run_a_bucket/#1.-Single-Node-Simulation","page":"Run a Bucket Model","title":"1. Single Node Simulation","text":"","category":"section"},{"location":"tutorials/run_a_bucket/","page":"Run a Bucket Model","title":"Run a Bucket Model","text":"# Setup input data\ninput = (lday=df[ts, \"dayl(day)\"], temp=df[ts, \"tmean(C)\"], prcp=df[ts, \"prcp(mm/day)\"])\nsolver = HydroModels.ManualSolver{true}()\nconfig = (solver=solver,)\n\n# Convert input to required format\ninput_arr = Matrix(reduce(hcat, collect(input[ele.meta.inputs]))')\n\n# Run simulation\nresults = ele(input_arr, pas, config=config, convert_to_ntp=true)","category":"page"},{"location":"tutorials/run_a_bucket/#2.-Multi-Node-Simulation","page":"Run a Bucket Model","title":"2. Multi-Node Simulation","text":"","category":"section"},{"location":"tutorials/run_a_bucket/","page":"Run a Bucket Model","title":"Run a Bucket Model","text":"# Setup for multiple nodes\nnode_num = 10\nnode_names = [Symbol(:node, i) for i in 1:node_num]\n\n# Create parameter and state vectors for all nodes\nnode_params = ComponentVector(NamedTuple{Tuple(node_names)}(repeat([params], length(node_names))))\nnode_initstates = ComponentVector(NamedTuple{Tuple(node_names)}(repeat([init_states], length(node_names))))\nnode_pas = ComponentVector(params=node_params, initstates=node_initstates)\n\n# Prepare input data for multiple nodes\ninput_arr = reduce(hcat, collect(input[HydroModels.get_input_names(ele)]))\nnode_input = reduce((m1, m2) -> cat(m1, m2, dims=3), repeat([input_arr], length(node_names)))\nnode_input = permutedims(node_input, (2, 3, 1))\n\n# Run simulation with multiple nodes\nrun_kwgs = (ptypes=node_names, timeidx=ts)\nresult = ele(node_input, node_pas, kwargs=run_kwgs)","category":"page"},{"location":"tutorials/run_a_bucket/#Model-Structure","page":"Run a Bucket Model","title":"Model Structure","text":"","category":"section"},{"location":"tutorials/run_a_bucket/","page":"Run a Bucket Model","title":"Run a Bucket Model","text":"The model uses a bucket structure defined in exphydro.jl with two main components:","category":"page"},{"location":"tutorials/run_a_bucket/","page":"Run a Bucket Model","title":"Run a Bucket Model","text":"Surface water component (bucket_1):\nHandles precipitation partitioning (rainfall/snowfall)\nComputes potential evapotranspiration\nManages snowmelt processes\nSoil water component:\nManages soil water storage\nComputes actual evaporation\nGenerates baseflow and surface flow","category":"page"},{"location":"tutorials/run_a_bucket/#Usage-Notes","page":"Run a Bucket Model","title":"Usage Notes","text":"","category":"section"},{"location":"tutorials/run_a_bucket/","page":"Run a Bucket Model","title":"Run a Bucket Model","text":"The code demonstrates flexibility in handling both single-node and multi-node simulations\nInput data should be properly formatted with required columns (dayl, tmean, prcp)\nParameters and initial states can be adjusted based on specific catchment characteristics\nThe model uses a manual solver for time-stepping","category":"page"},{"location":"tutorials/run_a_bucket/#Time-Series-Processing","page":"Run a Bucket Model","title":"Time Series Processing","text":"","category":"section"},{"location":"tutorials/run_a_bucket/","page":"Run a Bucket Model","title":"Run a Bucket Model","text":"The example processes 10,000 time steps (ts = collect(1:10000)) and can be adjusted based on data availability and simulation requirements.","category":"page"},{"location":"implements/build_discharge_route_zh/#构建河道汇流模型","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"","category":"section"},{"location":"implements/build_discharge_route_zh/#[discharge-route-model](https://gmd.copernicus.org/articles/14/7795/2021/)汇流模型介绍","page":"构建河道汇流模型","title":"discharge route model汇流模型介绍","text":"","category":"section"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"河道汇流模型是描述水流在河道中运动过程的数学模型，主要用于计算河道中的流量变化。下面给出了一个简单的河道汇流模型的数学表达式:","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"beginaligned\nDelta S_rfn = Q_rfn-1 - Q_rfn  (1) \nQ_rfn = (S_rfn + Q_rfn-1) cdot frac1textLAG_rf + 1  (2) \nQ_rf0 = sum Q_rfup  (3) \nQ_rf = Q_rfc_max + (R_sw + R_gw) cdot 0001 cdot A_gc  (4)\nendaligned","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"其中,n表示河段编号，取值范围为1c_max;Delta S_rfn表示第 n 段河道的蓄水量变化;Q_rfn表示第 n 段河道的出流量;S_rfn表示第 n 段河道的蓄水量;textLAG_rf 表示河道汇流滞时参数;Q_rfup表示上游河道的入流量;R_sw和R_gw分别表示地表径流和地下径流;A_gc表示栅格面积;c_max表示河道最大分段数.","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"公式(1)描述了河道蓄水量的变化，公式(2)表示河道出流量的计算，公式(3)给出了河道入流量的计算方法，公式(4)则是最终河道出流量的计算公式。 这种构建方式是根据每个 hydrological response unit(HRU)的上游输入确定当前的 HRU 入流量,这个确定方式可以由两种路由函数来表示. 当前 HRU 的出流量则是以当前的河道蓄水量S_rfn计算得到,并于 HRU 的 R{sw}和 R{gw}进行相加(经面积转换)得到最终的出流量Q_rf.","category":"page"},{"location":"implements/build_discharge_route_zh/#HydroModels.jl-框架下的河道汇流模型构建","page":"构建河道汇流模型","title":"HydroModels.jl 框架下的河道汇流模型构建","text":"","category":"section"},{"location":"implements/build_discharge_route_zh/#计算公式的改造","page":"构建河道汇流模型","title":"计算公式的改造","text":"","category":"section"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"HydroModels.jl 框架中为这种基于河道蓄水状态计算时段出流量的方法以 HydroRoute 类型进行表示,通过构建 ODE 方程的方式对这个问题进行连续性求解.与原公式实现有所不同的是,,并认为在计算Q_rfn时不存在瞬时变化,所以将公式(2)转换为如下式子:","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"beginaligned\nQ_rfn = S_rfn cdot frac1textLAG_rf + 1  (5)\nendaligned","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"式中,去掉了Q_rfn-1项.因为认为,在持续性变化中,S_rfn是一直处于变化状态的,所以在计算Q_rfn时不需要考虑Q_rfn-1的变化.此外于S_rfn与Q_rfn的量纲存在差异,同时如果将式中如果考虑Q_rfn会额外增加一个状态变量,这个变量是一个瞬时值,也不适合作为状态变量来使用. 在 HydroRoute 构造中,其首要的就是针对出流计算公式进行表达,与 HydroBucket 一样,HydroRoute 可以接受 HydroFlux 以此表示Q_rfn的计算公式,如下所示:","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"# 定义涉及的参数和变量\n@variables q q_routed s_river\n@parameters lag\n# 定义\nrflux = HydroFlux([q, s_river] => [q_routed], [lag], exprs=[s_river / (1 + lag) + q])","category":"page"},{"location":"implements/build_discharge_route_zh/#流量累积函数表示","page":"构建河道汇流模型","title":"流量累积函数表示","text":"","category":"section"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"获取 HRU 上游流量输入的方式是构成汇流模型的另一个部分,通常可以设置 Aggregation 函数来获取每个 HRU 的上游入流流量. 这个 Aggregation 函数可以由 Grid-Based 和 Vector-Based 两种方式来表示. 在 HydroModels.jl 框架中分别对应了两种 HydroRoute 的构造方式: GridRoute 和 VectorRoute.","category":"page"},{"location":"implements/build_discharge_route_zh/#表示-Vector-Based-的河道汇流模型","page":"构建河道汇流模型","title":"表示 Vector-Based 的河道汇流模型","text":"","category":"section"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"Vector-Based 的河道汇流模型是以流域子流域划分结果及其连接的拓扑关系为基础,通过构建 adjacency 矩阵得到流量累积函数:","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"# 构建河网拓扑结构\nnetwork = DiGraph(9)\nadd_edge!(network, 1, 2)\nadd_edge!(network, 2, 5)\nadd_edge!(network, 3, 5)\nadd_edge!(network, 4, 5)\nadd_edge!(network, 5, 8)\nadd_edge!(network, 6, 9)\nadd_edge!(network, 7, 8)\nadd_edge!(network, 8, 9)\nvroute = HydroModels.VectorRoute(rfunc=rflux, rstate=s_river, network=network)","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"代码中是采用 Graphs.jl 的 DiGraph 数据结构来表示流域拓扑,作为模型的输入参数,连同构建的 rflux 和 s_river,一同完成 Vector-Based 的河道汇流模型的构造.","category":"page"},{"location":"implements/build_discharge_route_zh/#表示-Grid-Based-的河道汇流模型","page":"构建河道汇流模型","title":"表示 Grid-Based 的河道汇流模型","text":"","category":"section"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"Grid-Based 的河道汇流模型是 HRU 之间的连同关系所表示的, 同常是使用 d8 流向矩阵来表示其连同关系,以此 Grid-Based 的河道汇流模型的构造便是根据 d8 流向矩阵和对应的 HRU 坐标来进行构造的:","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"# 构建河网拓扑结构\nflwdir = [1 4 8; 1 4 4; 1 1 2]\npositions = [[1, 1], [1, 2], [1, 3], [2, 1], [2, 2], [2, 3], [3, 1], [3, 2], [3, 3]]\ngroute = HydroModels.GridRoute(rfunc=rflux, rstate=s_river, flwdir=flwdir, positions=positions)","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"代码中是采用矩阵数据表示流向矩阵和HRU 坐标,作为模型的输入参数,连同构建的 rflux 和 s_river,一同完成 Grid-Based 的河道汇流模型的构造.","category":"page"},{"location":"extent/share_parameters/#Share-parameters-in-multiple-HRUs","page":"Share parameters in multiple HRUs","title":"Share parameters in multiple HRUs","text":"","category":"section"},{"location":"extent/framework_comparision_en/#Comparing-Programming-Styles-for-Custom-Models-in-superflexpy,-MARRMoT,-and-HydroModels.jl","page":"Modeling Framework Comparisons","title":"Comparing Programming Styles for Custom Models in superflexpy, MARRMoT, and HydroModels.jl","text":"","category":"section"},{"location":"extent/framework_comparision_en/","page":"Modeling Framework Comparisons","title":"Modeling Framework Comparisons","text":"This content corresponds to Section 4.1 of the paper, where we discuss the differences in programming styles for custom model implementation across these three software libraries. Using the GR4J model implementation as an example, we compare the programming styles for customizing model computation formulas.","category":"page"},{"location":"extent/framework_comparision_en/#[Superflexpy](https://github.com/dalmo1991/superflexPy/tree/master)","page":"Modeling Framework Comparisons","title":"Superflexpy","text":"","category":"section"},{"location":"extent/framework_comparision_en/","page":"Modeling Framework Comparisons","title":"Modeling Framework Comparisons","text":"Superflexpy is a Python implementation based on the SUPERFLEX concept. For implementing hydrological model computations, this framework typically uses Python syntax to express model calculation formulas, as shown below.","category":"page"},{"location":"extent/framework_comparision_en/","page":"Modeling Framework Comparisons","title":"Modeling Framework Comparisons","text":"@staticmethod\ndef _flux_function_python(S, S0, ind, P, x1, alpha, beta, ni, PET, dt):\n    if ind is None:\n        return (\n            [\n                P * (1 - (S / x1) ** alpha), # Ps\n                -PET * (2 * (S / x1) - (S / x1) ** alpha), # Evaporation\n                -((x1 ** (1 - beta)) / ((beta - 1) * dt)) * (ni ** (beta - 1)) * (S**beta), # Perc\n            ],\n            0.0,\n            S0 + P * (1 - (S / x1) ** alpha) * dt,\n        )\n    else:\n        return (\n            [\n                P[ind] * (1 - (S / x1[ind]) ** alpha[ind]), # Ps\n                -PET[ind] * (2 * (S / x1[ind]) - (S / x1[ind]) ** alpha[ind]), # Evaporation\n                -((x1[ind] ** (1 - beta[ind])) / ((beta[ind] - 1) * dt[ind]))\n                * (ni[ind] ** (beta[ind] - 1))\n                * (S ** beta[ind]), # Perc\n            ],\n            0.0,\n            S0 + P[ind] * (1 - (S / x1[ind]) ** alpha[ind]) * dt[ind],\n            [\n                -(P[ind] * alpha[ind] / x1[ind]) * ((S / x1[ind]) ** (alpha[ind] - 1)),\n                -(PET[ind] / x1[ind]) * (2 - alpha[ind] * ((S / x1[ind]) ** (alpha[ind] - 1))),\n                -beta[ind]\n                * ((x1[ind] ** (1 - beta[ind])) / ((beta[ind] - 1) * dt[ind]))\n                * (ni[ind] ** (beta[ind] - 1))\n                * (S ** (beta[ind] - 1)),\n            ],\n        )\n\n@staticmethod\n@nb.jit(\n    \"Tuple((UniTuple(f8, 3), f8, f8, UniTuple(f8, 3)))\"\n    \"(optional(f8), f8, i4, f8[:], f8[:], f8[:], f8[:], f8[:], f8[:], f8[:])\",\n    nopython=True,\n)\ndef _flux_function_numba(S, S0, ind, P, x1, alpha, beta, ni, PET, dt):\n    return (\n        (\n            P[ind] * (1 - (S / x1[ind]) ** alpha[ind]),  # Ps\n            -PET[ind] * (2 * (S / x1[ind]) - (S / x1[ind]) ** alpha[ind]),  # Evaporation\n            -((x1[ind] ** (1 - beta[ind])) / ((beta[ind] - 1) * dt[ind]))\n            * (ni[ind] ** (beta[ind] - 1))\n            * (S ** beta[ind]),  # Perc\n        ),\n        0.0,\n        S0 + P[ind] * (1 - (S / x1[ind]) ** alpha[ind]) * dt[ind],\n        (\n            -(P[ind] * alpha[ind] / x1[ind]) * ((S / x1[ind]) ** (alpha[ind] - 1)),\n            -(PET[ind] / x1[ind]) * (2 - alpha[ind] * ((S / x1[ind]) ** (alpha[ind] - 1))),\n            -beta[ind]\n            * ((x1[ind] ** (1 - beta[ind])) / ((beta[ind] - 1) * dt[ind]))\n            * (ni[ind] ** (beta[ind] - 1))\n            * (S ** (beta[ind] - 1)),\n        ),\n    )","category":"page"},{"location":"extent/framework_comparision_en/","page":"Modeling Framework Comparisons","title":"Modeling Framework Comparisons","text":"As shown, when implementing the GR4J production module calculations origin code, the superflexpy framework requires separate construction of numpy and numba computation code. The function must specify hydrological fluxes Ps, Evaporation, Perc, and state variable balance equations. This approach couples multiple computational process implementations in a single code block, resulting in reduced code reusability (only reusable at the module level) and increased code volume and redundancy.","category":"page"},{"location":"extent/framework_comparision_en/#[MARRMoT](https://github.com/wknoben/MARRMoT)","page":"Modeling Framework Comparisons","title":"MARRMoT","text":"","category":"section"},{"location":"extent/framework_comparision_en/","page":"Modeling Framework Comparisons","title":"Modeling Framework Comparisons","text":"MARRMoT is a hydrological modeling framework developed in MATLAB. This framework constructs model types separately based on different hydrological models, storing the calculation formulas and state change equations involved. The simplified implementation code for the GR4J model in this framework is shown below.","category":"page"},{"location":"extent/framework_comparision_en/","page":"Modeling Framework Comparisons","title":"Modeling Framework Comparisons","text":"function [dS, fluxes] = model_fun(obj, S)\n    % definitions\n    ...\n    % fluxes functions\n    flux_pn   = max(P-Ep,0);\n    flux_en   = max(Ep-P,0);\n    flux_ef   = P - flux_pn;\n    flux_ps   = saturation_4(S1,x1,flux_pn);\n    flux_es   = evap_11(S1,x1,flux_en);\n    flux_perc = percolation_3(S1,x1);\n    flux_q9   = route(.9.*(flux_pn - flux_ps + flux_perc), uh_q9);\n    flux_q1   = route(.1.*(flux_pn - flux_ps + flux_perc), uh_q1);\n    flux_fr   = recharge_2(3.5,S2,x3,x2);\n    flux_fq   = flux_fr;\n    flux_qr   = baseflow_3(S2,x3);\n    flux_qt   = flux_qr + max(flux_q1 + flux_fq,0);\n    % this flux is not included in original MARRMoT,\n    % but it is useful to calculate the water balance\n    flux_ex = flux_fr + max(flux_q1 + flux_fq,0) - flux_q1;      \n    % stores ODEs\n    dS1 = flux_ps - flux_es - flux_perc;\n    dS2 = flux_q9 + flux_fr - flux_qr;\n    % outputs\n    dS = [dS1 dS2];\n    fluxes = [flux_pn,   flux_en, flux_ef, flux_ps, flux_es,...\n                flux_perc, flux_q9, flux_q1, flux_fr, flux_fq,...\n                flux_qr,   flux_qt, flux_ex];\nend","category":"page"},{"location":"extent/framework_comparision_en/","page":"Modeling Framework Comparisons","title":"Modeling Framework Comparisons","text":"As evident, the MARRMoT framework expresses each Flux calculation formula through functions, allowing users to directly call functions for calculations (according to provided documentation). This approach significantly simplifies code writing requirements compared to superflexpy. However, MARRMoT has poor support for module reusability and cannot be reused like superflexpy. Additionally, combining variable assignments, flux calculations, and state change equations in one function results in poor decoupling of computational content.","category":"page"},{"location":"extent/framework_comparision_en/#HydroModels.jl","page":"Modeling Framework Comparisons","title":"HydroModels.jl","text":"","category":"section"},{"location":"extent/framework_comparision_en/","page":"Modeling Framework Comparisons","title":"Modeling Framework Comparisons","text":"#* define the production store\nprod_funcs = [\n    HydroFlux([prcp, ep] => [pn, en], exprs=[prcp - min(prcp, ep), ep - min(prcp, ep)]),\n    HydroFlux([pn, soilwater] => [ps], [x1], exprs=[max(0.0, pn * (1 - (soilwater / x1)^2))]),\n    HydroFlux([en, soilwater] => [es], [x1], exprs=[en * (2 * soilwater / x1 - (soilwater / x1)^2)]),\n    HydroFlux([soilwater] => [perc], [x1], exprs=[((x1)^(-4)) / 4 * ((4 / 9)^(4)) * (soilwater^5)]),\n    HydroFlux([pn, ps, perc] => [pr], exprs=[pn - ps + perc]),\n    HydroFlux([pr] => [slowflow, fastflow], exprs=[0.9 * pr, 0.1 * pr]),\n]\nprod_dfuncs = [StateFlux([ps] => [es, perc], soilwater)]\nprod_ele = HydroBucket(name=:gr4j_prod, funcs=prod_funcs, dfuncs=prod_dfuncs)\n\n#* uh function\nuh_flux_1 = HydroModels.UnitHydrograph([slowflow] => [slowflow_routed], x4, uhfunc=HydroModels.UHFunction(:UH_1_HALF), solvetype=:SPARSE)\nuh_flux_2 = HydroModels.UnitHydrograph([fastflow] => [fastflow_routed], x4, uhfunc=HydroModels.UHFunction(:UH_2_FULL), solvetype=:SPARSE)\n\n#* define the routing store\nrst_funcs = [\n    HydroFlux([routingstore] => [exch], [x2, x3], exprs=[x2 * abs(routingstore / x3)^3.5]),\n    HydroFlux([routingstore, slowflow, exch] => [routedflow], [x3], exprs=[x3^(-4) / 4 * (routingstore + slowflow + exch)^5]),\n    HydroFlux([routedflow, fastflow_routed, exch] => [flow], exprs=[routedflow + max(fastflow_routed + exch, 0.0)]),\n]\nrst_dfuncs = [StateFlux([exch, slowflow] => [routedflow], routingstore)]\nrst_ele = HydroBucket(name=:gr4j_rst, funcs=rst_funcs, dfuncs=rst_dfuncs)\n\ngr4j_model = HydroModel(name=:gr4j, components=[prod_ele, uh_flux_1, uh_flux_2, rst_ele])","category":"page"},{"location":"extent/framework_comparision_en/","page":"Modeling Framework Comparisons","title":"Modeling Framework Comparisons","text":"Returning to the GR4J model implementation in HydroModels.jl framework, we sequentially define the production store, unit hydrograph, and routing store. In this process, the model can achieve reusability while maintaining variable correspondence. The construction process includes instantiation of classes such as HydroFlux, StateFlux, UnitHydrograph, HydroModel, and HydroBucket. Unlike the previous two frameworks that use functional construction, these class instantiations express calculation formulas through symbolic programming. After model construction, calculations are performed through input data and parameters, demonstrating a design philosophy that completely decouples model structure and formulas from parameters and data, achieving high reusability.","category":"page"},{"location":"#HydroModels.jl","page":"Home","title":"HydroModels.jl","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HydroModels.jl is a modern hydrological modeling framework that extends and enhances SUPERFLEX's design philosophy. Built on Julia language and the SciML (Scientific Machine Learning) ecosystem, it combines flexible model construction with computational efficiency, particularly supporting deep learning integration in hydrological modeling.","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Flexible Model Construction: Supports development of lumped, semi-distributed, and distributed hydrological models\nDeep Learning Integration: Enables neural network integration for enhanced flux calculations and dynamic parameter estimation\nComputational Efficiency: Leverages Julia's high-performance capabilities and the SciML ecosystem\nGradient-Based Optimization: Supports advanced parameter optimization techniques\nComprehensive Framework: Provides tools for both traditional hydrological modeling and modern machine learning approaches","category":"page"},{"location":"#Framework-Capabilities","page":"Home","title":"Framework Capabilities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HydroModels.jl offers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Easy implementation and customization of hydrological models\nIntegration with Julia's scientific computing ecosystem\nSupport for various modeling approaches:\nTraditional conceptual models\nNeural network enhanced models\nDistributed hydrological systems","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"HydroModels\")","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HydroModels.jl is an open-source project available on Github. We welcome contributions from the community to help advance deep learning applications in hydrology.","category":"page"}]
}
