var documenterSearchIndex = {"docs":
[{"location":"get_start_zh/#Getting-Started-With-HydroModels.jl","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"","category":"section"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"HydroModels.jl 是一个基于 Julia 语言的现代水文模型框架.它在 SUPERFLEX 设计理念的基础上进行了扩展和增强,具有灵活的模型构建能力和高效的计算性能,并支持深度学习模型集成.本教程将介绍如何使用 HydroModels.jl 构建和运行水文模型.","category":"page"},{"location":"get_start_zh/#Installation,.","page":"Getting Started With HydroModels.jl","title":"Installation,.","text":"","category":"section"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"] add HydroModels","category":"page"},{"location":"get_start_zh/#Build-a-ExpHydro-Model","page":"Getting Started With HydroModels.jl","title":"Build a ExpHydro Model","text":"","category":"section"},{"location":"get_start_zh/#Introduction-to-ExpHydro-Model","page":"Getting Started With HydroModels.jl","title":"Introduction to ExpHydro Model","text":"","category":"section"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"ExpHydro 是一个由积雪模块和土壤模块组成的简单水文模型.其数学表达式如下：","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"beginaligned\n textSnowpack Bucket \n pet = 298 cdot lday cdot 24 cdot 0611 cdot fracexp(173 cdot temp)temp + 2373 cdot frac1temp + 2732  (1) \n nowfall = H(T_min - temp) cdot prcp  (2) \n rainfall = H(temp - T_mn) cdot prcp (3) \n melt = H(temp - T_max) cdot H(snowpack) cdot min(snowpack D_f cdot (temp - T_max))  (4) \n fracd(snowpack)dt = snowfall - melt  (5) \n\n textSoilwater Bucket \n evap = H(soilwater) cdot pet cdot min(10 fracsoilwaterS_max)  (6) \n baseflow = H(soilwater) cdot Q_max cdot exp(-f cdot max(00 S_max - soilwater))  (7) \n surfaceflow = max(00 soilwater - S_max)  (8) \n flow = baseflow + urfaceflow  (9) \n fracd(soilwater)dt = rainfall + melt - evap - flow  (10)\nendaligned","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":",,,. 其中：","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"H(x)\n表示 Heaviside 阶跃函数,当 x  0 时为 1,否则为 0,.\nT_min T_max D_f S_max Q_max f\n为模型参数\ntemp lday prcp\n为输入变量\nsnowpack soilwater\n为状态变量\n其他变量为中间计算变量","category":"page"},{"location":"get_start_zh/#Build-a-ExpHydro-Model-in-HydroModels.jl","page":"Getting Started With HydroModels.jl","title":"Build a ExpHydro Model in HydroModels.jl","text":"","category":"section"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"了解 ExpHydro 模型的基本原理后, 我们可以使用 HydroModels.jl 来构建这个模型.","category":"page"},{"location":"get_start_zh/#Import-Packages","page":"Getting Started With HydroModels.jl","title":"Import Packages","text":"","category":"section"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"首先导入 HydroModels.jl 包.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"using HydroModels","category":"page"},{"location":"get_start_zh/#Define-Variables-and-Parameters","page":"Getting Started With HydroModels.jl","title":"Define Variables and Parameters","text":"","category":"section"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"定义模型所需参数、状态变量和其他变量(包括降雨、蒸发、融雪、地表流等).","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"@variables temp lday pet prcp \n@variables snowfall ra(nf)ll melt evap baseflow surfaceflow flow\n@variables snowpack soilwater\n@parameters Tmin Tmax Df Smax Qmax f","category":"page"},{"location":"get_start_zh/#Build-Flux-Formulas-by-HydroFlux","page":"Getting Started With HydroModels.jl","title":"Build Flux Formulas by HydroFlux","text":"","category":"section"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"接下来,我们需要构建模型的各个计算公式,包括状态方程和中间变量计算公式.以融雪公式为例,介绍 HydroFlux 的使用方法：","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"melt_flux = HydroFlux([snowpack, temp] => [melt], [Tmax, Df], exprs=[step_func(temp - Tmax) * step_func(snowpack) * min(snowpack, Df * (temp - Tmax))])","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"在构建 HydroFlux 时,需要注意以下几点：","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"确保表达式中使用的所有变量和参数都已在输入中声明\n输入变量和输出变量通过 Pair 类型（=>）连接\n参数以向量形式传入\n表达式以向量形式传入 exprs 参数","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"HydroFlux 首先接受输入变量和输出变量所构成的 Pair 类型,然后再将参数构成的 Vector 传递给 HydroFlux,最后根据融雪公式的表达式传递给 exprs,完成融雪公式的构建.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"需要注意的是,在构建 HydroFlux 时,一定要确保 expr 中包含的变量和参数均在输入变量和参数中,如果 exprs 中存在没有向 HydroFlux 提供的输入变量和参数,在后续计算中很有可能会出现变量不存在的错误,这时你就需要检查 HydroFlux 的构建是否正确.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"当然,构建 HydroFlux 时,参数变量不是必要的,如果不需要参数,可以省略参数变量,例如潜在蒸发量的计算公式：","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"pet_flux = HydroFlux([temp, lday] => [pet], exprs=[29.8 * lday * 24 * 0.611 * exp(17.3 * temp) / (temp + 237.3) * 1 / (temp + 273.2)])","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"该公式就是以 temp 和 lday 作为输入变量,并计算了 pet 作为输出变量,由于该公式不涉及参数,因此不需要传递参数变量.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"值得注意的是,HydroFlux 的 exprs 接受的类型只能是以表达式所组成的 Vector,这是考虑到 HydroFlux 有时需要支持多个输出变量,因而需要支持多个表达式,两者的数目必须相同.这里以雨雪划分公式为例.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp])","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"该公式以 prcp 和 temp 作为输入变量,并计算了 snowfall 和 rainfall 作为输出变量,同时使用了 Tmin 作为参数,由于该公式输出了两个变量 snowfall 和 rainfall,因此需要传递两个表达式,以此分别表示两个输出变量的计算公式.","category":"page"},{"location":"get_start_zh/#Build-State-Formulas-by-StateFlux","page":"Getting Started With HydroModels.jl","title":"Build State Formulas by StateFlux","text":"","category":"section"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"一般而言状态方程是由输入 Flux 之和减去输出 Flux 之和所构建的,因此可以通过 Pair 来表示这个输入输出关系,并输入状态变量,以此构建 StateFlux,例如雪层状态方程.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"snowpack_flux = StateFlux([snowfall] => [melt], snowpack)","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"该公式以 snowfall 作为输入变量,并计算了 snowpack 作为输出变量,同时输入了状态变量 snowpack,以此构建了雪层状态方程.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"一般而言在构建状态方程前,都倾向于将涉及的 Flux 由 HydroFlux 全部构建,然后通过 StateFlux 结合输入输出通量的 Pair 和状态变量得到一个直观的 StateFlux.但有时为了避免引入多余的变量,也可以直接构建较为复杂的 StateFlux.事实上这个构建方式于 HydroFlux 高度一致,同样是将输入输出变量均作为 StateFlux 的输入,然后命名状态变量和所需的参数,最后就构建状态方程, 我们重新构建雪层状态方程.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"snowpack_flux = StateFlux([prcp, temp, melt], snowpack, [Tmin], expr=step_func(Tmin - temp) * prcp-melt)","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"在这个状态方程中没有直接计算 snowfall,而是通过 prcp 和 temp 完成计算,结合 dsnowpack/dt=snowfall-melt 的状态方程构建一个忽略 snowfall 中间变量的复杂状态方程.","category":"page"},{"location":"get_start_zh/#Build-Snowfall-Bucket","page":"Getting Started With HydroModels.jl","title":"Build Snowfall Bucket","text":"","category":"section"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"在完成必要的 HydroFlux 和 StateFlux 构建后,就可以构建一个 HydroBucket,以雪层 Bucket 为例,需要将构建的 HydroFlux 和 StateFlux 传递给 HydroBucket.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"首先将涉及的 HydroFlux 与 StateFlux 用 Vector 进行存储.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"fluxes_1 = [\n    HydroFlux([temp, lday] => [pet], exprs=[29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)]),\n    HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp]),\n    HydroFlux([snowpack, temp] => [melt], [Tmax, Df], exprs=[step_func(temp - Tmax) * step_func(snowpack) * min(snowpack, Df * (temp - Tmax))]),\n]\ndfluxes_1 = [StateFlux([snowfall] => [melt], snowpack)]","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"接着就将这些 Vector 变量作为输入构建一个水文计算模块,即 HydroBucket.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"snowpack_bucket = HydroBucket(name=:surface, fluxes=fluxes_1, dfluxes=dfluxes_1)","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"通过 HydroBucket 就可以完成对一个水文计算模块的构建,在 HydroBucket 的构建中,程序会执行一些自动构建方法,以此表达计算模块中的常微分方程和其余变量的计算函数,详情请参考实施细节.","category":"page"},{"location":"get_start_zh/#Build-Exphydro-Model","page":"Getting Started With HydroModels.jl","title":"Build Exphydro Model","text":"","category":"section"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"按照相同的逻辑,就可以构建模型中的土壤计算模块,接着将两个模块拼接到一块构建 Vector 类型,并输入至 HydroModel 中,就完成了 ExpHydro 模型的构建,完整构建代码如下","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"#* import packages\nusing HydroModels\n\n#* define variables and parameters\n@variables temp lday pet prcp \n@variables snowfall rainfall melt evap baseflow surfaceflow flow\n@variables snowpack soilwater\n@parameters Tmin Tmax Df Smax Qmax f\n\nstep_func(x) = (tanh(5.0 * x) + 1.0) * 0.5\n\n#* define snowpack bucket\nfluxes_1 = [\n    HydroFlux([temp, lday] => [pet], exprs=[29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)]),\n    HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp]),\n    HydroFlux([snowpack, temp] => [melt], [Tmax, Df], exprs=[step_func(temp - Tmax) * step_func(snowpack) * min(snowpack, Df * (temp - Tmax))]),\n]\ndfluxes_1 = [StateFlux([snowfall] => [melt], snowpack),]\nsnowpack_bucket = HydroBucket(name=:surface, fluxes=fluxes_1, dfluxes=dfluxes_1)\n\n#* define soilwater bucket\nfluxes_2 = [\n    HydroFlux([soilwater, pet] => [evap], [Smax], exprs=[step_func(soilwater) * pet * min(1.0, soilwater / Smax)]),\n    HydroFlux([soilwater] => [baseflow], [Smax, Qmax, f], exprs=[step_func(soilwater) * Qmax * exp(-f * (max(0.0, Smax - soilwater)))]),\n    HydroFlux([soilwater] => [surfaceflow], [Smax], exprs=[max(0.0, soilwater - Smax)]),\n    HydroFlux([baseflow, surfaceflow] => [flow], exprs=[baseflow + surfaceflow]),\n]\ndfluxes_2 = [StateFlux([rainfall, melt] => [evap, flow], soilwater)]\nsoilwater_bucket = HydroBucket(name=:soil, fluxes=fluxes_2, dfluxes=dfluxes_2)\n\n#* define the Exp-Hydro model\nexphydro_model = HydroModel(name=:exphydro, components=[snowpack_bucket, soilwater_bucket])","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"这样就完成了一个 ExpHydro 模型的构建,打印这个类型,可以看到模型包含的基本信息.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"HydroModel: exphydro\n   Components: surface, soil\n   Inputs: [temp, lday, prcp]\n   States: [snowpack, soilwater]\n   Outputs: [pet, snowfall, rainfall, melt, evap, baseflow, surfaceflow, flow]\n   Parameters: [Tmin, Tmax, Df, Smax, Qmax, f]\n   Components:\n       Fluxes: 0 fluxes\n       Buckets: 2 buckets\n       Routes: 0 routes","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"这些信息中展示了模型的名称,包含的组建名称,输入变量,状态变量,输出变量和参数变量,以及包含的 Flux,Bucket 和 Route 的数量.","category":"page"},{"location":"get_start_zh/#Embedding-Neural-Network-into-ExpHydro-Model","page":"Getting Started With HydroModels.jl","title":"Embedding Neural Network into ExpHydro Model","text":"","category":"section"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"ExpHydro 模型近年来作为一个基础水文模型被大量应用于神经网络耦合水文模型的研究,例如 M50,M100,ENN 等.这些模型都是将 ExpHydro 模型作为基础模型,然后通过神经网络替换模型的部分计算公式（如蒸发和产流）,以此实现提升模型预测精度的目的.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"下面,我们将介绍如何使用 HydroModels.jl 将神经网络嵌入至 ExpHydro 模型中.","category":"page"},{"location":"get_start_zh/#Define-Neural-Network-by-Lux.jl","page":"Getting Started With HydroModels.jl","title":"Define Neural Network by Lux.jl","text":"","category":"section"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"HydroModels.jl 支持通过 Lux.jl 来定义神经网络,这里以一个简单的全连接神经网络为例.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"using Lux\n\n# define the ET NN and Q NN\nep_nn = Lux.Chain(\n    Lux.Dense(3 => 16, tanh),\n    Lux.Dense(16 => 16, leakyrelu),\n    Lux.Dense(16 => 1, leakyrelu),\n    name=:epnn\n)\n\nq_nn = Lux.Chain(\n    Lux.Dense(2 => 16, tanh),\n    Lux.Dense(16 => 16, leakyrelu),\n    Lux.Dense(16 => 1, leakyrelu),\n    name=:qnn\n)","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"首先根据 Lux.jl 构建了两个全连接神经网络模型 ep_nn 和 q_nn,接着就可以通过 HydroModel.jl 提供的 NeuralFlux 来构建神经网络公式.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"@variables norm_snw norm_slw norm_temp norm_prcp\n@variables log_evap_div_lday log_flow\n\nep_nn_flux = NeuralFlux([norm_snw, norm_slw, norm_temp] => [log_evap_div_lday], ep_nn)\nq_nn_flux = NeuralFlux([norm_slw, norm_prcp] => [log_flow], q_nn)","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"NeuralFlux 是 HydroFlux 的一个衍生类型,他同样是接受输入输出变量的 Pair,但不同的是他不需要提供模型参数和计算公式,他需要将神经网络作为参数传递给 NeuralFlux, 以此构建神经网络公式. 值得注意的是,神经网络的输入输出变量维度需要与 NeuralFlux 的输入输出变量维度一致.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"然后完成 NeuralFlux 的构建后, 就可以将其与其余 HydroFlux 一同传递给 HydroBucket,以此构建神经网络耦合的水文模型.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"soil_fluxes = [\n    #* normalize\n    HydroFlux([snowpack, soilwater, prcp, temp] => [norm_snw, norm_slw, norm_prcp, norm_temp],\n        [snowpack_mean, soilwater_mean, prcp_mean, temp_mean, snowpack_std, soilwater_std, prcp_std, temp_std],\n        exprs=[(var - mean) / std for (var, mean, std) in zip([snowpack, soilwater, prcp, temp],\n            [snowpack_mean, soilwater_mean, prcp_mean, temp_mean],\n            [snowpack_std, soilwater_std, prcp_std, temp_std]\n        )]),\n    ep_nn_flux,\n    q_nn_flux\n]\n","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"这个土壤模块的公式包括了标准化公式,蒸发公式和产流公式,接着就可以将这些公式传递给 HydroBucket,结合状态方程完成土壤模块的构建.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"state_expr = rainfall + melt - step_func(soilwater) * lday * exp(log_evap_div_lday) - step_func(soilwater) * exp(log_flow)\nsoil_dfluxes = [StateFlux([soilwater, rainfall, melt, lday, log_evap_div_lday, log_flow], soilwater, expr=state_expr)]\nsoilwater_bucket = HydroBucket(name=:soil, fluxes=soil_fluxes, dfluxes=soil_dfluxes)\nm50_model = HydroModel(name=:m50, components=[snowpack_bucket, soilwater_bucket])","category":"page"},{"location":"get_start_zh/#Run-a-ExpHydro-Model","page":"Getting Started With HydroModels.jl","title":"Run a ExpHydro Model","text":"","category":"section"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"在完成模型的构建后,由于模型是 callable 的, 因此可以将输入和参数输入至模型中,并得到输出结果.","category":"page"},{"location":"get_start_zh/#Prepare-Input-Data","page":"Getting Started With HydroModels.jl","title":"Prepare Input Data","text":"","category":"section"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"模型输入的观测数据限于 AbstractMatrix 类型的数据,维度为输入变量数目乘以时间步数,例如输入变量有 3 个,时间步数为 1000,那么输入的观测数据维度为 (3, 1000).值得注意的是,输入变量的所在维度的索引会对模型计算结果产生影响,因为模型无法自动识别 Matrix 各行对应的输入变量,因此使用者可以先准备好一个 Dict,NamedTuple 类型,然后根据 HydroModels.get_input_names(model) 来获取模型输入变量的名称,将这个名称结合 Dict 或 NamedTuple 构建 Matrix 类型的输入数据.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"input = (lday=df[ts, \"dayl(day)\"], temp=df[ts, \"tmean(C)\"], prcp=df[ts, \"prcp(mm/day)\"])\ninput_arr = Matrix(reduce(hcat, collect(input[HydroModels.get_input_names(exphydro_model)]))')","category":"page"},{"location":"get_start_zh/#Prepare-Parameters-and-Initial-States","page":"Getting Started With HydroModels.jl","title":"Prepare Parameters and Initial States","text":"","category":"section"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"对于参数的准备, HydroModels.jl 是接受 ComponentVector 类型的参数 (using ComponentArrays),通过参数名称和参数值存储在 ComponentVector 中,例如","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"f, Smax, Qmax, Df, Tmax, Tmin = 0.01674478, 1709.461015, 18.46996175, 2.674548848, 0.175739196, -2.092959084\nparams = ComponentVector(f=f, Smax=Smax, Qmax=Qmax, Df=Df, Tmax=Tmax, Tmin=Tmin)","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"对于初始状态的准备, HydroModels.jl 同样是接受 ComponentVector 类型的初始状态,通过状态名称和状态值存储在 ComponentVector 中,例如","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"init_states = ComponentVector(snowpack=0.0, soilwater=1303.004248)","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"接着将参数和初始状态存储至同一个 ComponentVector 中（有时初始状态同样是作为待优化的参数,因此需要将其与参数一并存储,实现统一管理）.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"pas = ComponentVector(params=params, initstates=init_states)","category":"page"},{"location":"get_start_zh/#Run-the-ExpHydro-Model","page":"Getting Started With HydroModels.jl","title":"Run the ExpHydro Model","text":"","category":"section"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"最后将输入数据和参数输入至模型中,就可以得到输出结果.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"result = exphydro_model(input_arr, pas)","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"模型计算输出同样是一个 AbtractMatrix 的类型,维度为输出变量数目（包括状态变量）乘以时间步数,例如输出变量有 8 个,时间步数为 1000,那么输出结果的维度为 (8, 1000).如果你想导出为 DataFrame 类型,可以使用 HydroModels.get_output_names(model) 来获取输出变量的名称,然后结合 Dict 或 NamedTuple 构建 DataFrame 类型的输出数据.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"states_and_output_names = vcat(HydroModels.get_state_names(exphydro_model), HydroModels.get_output_names(exphydro_model))\noutput = NamedTuple{Tuple(states_and_output_names)}(eachslice(result, dims=1))\ndf = DataFrame(output)","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"计算结果如下.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"10000×10 DataFrame\n   Row │ snowpack  soilwater  pet      snowfall  rainfall  melt      evap      baseflow   surfaceflow  flow      \n       │ Float64   Float64    Float64  Float64   Float64   Float64   Float64   Float64    Float64      Float64   \n───────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │    0.0         0.0      3.1        0.0   1305.22  1.13779   0.868735  0.0212194          0.0  0.0212194\n     2 │    0.0         0.0      4.24       0.0   1308.28  1.51019   1.15578   0.0223371          0.0  0.0223371\n     3 │    0.0         0.0      8.02       0.0   1315.03  1.63204   1.25547   0.0250095          0.0  0.0250095\n     4 │    0.0         0.0     15.27       0.0   1329.34  1.21771   0.946937  0.0317802          0.0  0.0317802\n     5 │    0.0         0.0      8.48       0.0   1336.99  1.02779   0.803845  0.0361228          0.0  0.0361228\n   ⋮   │    ⋮          ⋮         ⋮        ⋮         ⋮         ⋮         ⋮          ⋮           ⋮           ⋮\n  9996 │  254.264       0.0      0.0       -0.0   1521.37  0.221762  0.197362  0.791897           0.0  0.791897\n  9997 │  266.324      12.06     0.0       -0.0   1520.37  0.238907  0.21248   0.778688           0.0  0.778688\n  9998 │  277.874      11.55     0.0       -0.0   1519.33  0.288362  0.256291  0.765307           0.0  0.765307\n  9999 │  279.714       1.84     0.0       -0.0   1518.29  0.311022  0.27624   0.752073           0.0  0.752073\n 10000 │  279.854       0.14     0.0       -0.0   1517.38  0.176836  0.156967  0.740711           0.0  0.740711","category":"page"},{"location":"get_start_zh/#Running-with-Config","page":"Getting Started With HydroModels.jl","title":"Running with Config","text":"","category":"section"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"当然模型计算不仅限于这些内容,为支持计算过程中的一些必要设置,HydroModel 在计算时能够接受 config 参数.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"例如在默认情况下,模型求解常微分方程时仅使用了 Euler 方法,但有时需要使用更精确的求解方法,这时就需要使用 config 参数来设置求解方法.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"为演示这个功能需要额外导入 OrdinaryDiffEq.jl 和 HydroModelTools.jl,然后设置求解方法.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"using OrdinaryDiffEq\nusing HydroModelTools\nusing DataInterpolations\n\nconfig = (solver=ODESolver(alg=Tsit5(), abstol=1e-3, reltol=1e-3), interp=LinearInterpolation)\noutput = exphydro_model(input_arr, pas, config=config)","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"config 参数的设置方式为 NamedTuple 类型,其中 solver 参数用于设置求解方法, interp 参数用于设置插值方法.ODESolver 是 HydroModelTools.jl 提供的求解器包装类,对求解结果进行了一些数据转换,它接受 OrdinaryDiffEq.jl 的求解方法作为参数,并设置求解方法的参数.","category":"page"},{"location":"get_start_zh/#Run-the-Neural-Network-Enhanced-Model","page":"Getting Started With HydroModels.jl","title":"Run the Neural Network Enhanced Model","text":"","category":"section"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"在前面我们构建了一个用神经网络耦合的 ExpHydro 模型,现在我们就可以使用这个模型来计算结果.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"首先需要准备模型的参数,在 Exphydro 模型参数基础上我们还需要额外准备神经网络的参数.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"using StableRNGs\n\nep_nn_params = Vector(ComponentVector(LuxCore.initialparameters(ep_nn)))\nq_nn_params = Vector(ComponentVector(LuxCore.initialparameters(q_nn)))","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"基于 Lux.jl 的模型能够将参数与模型结构进行解耦,这也是我们选择使用 Lux.jl 构建神经网络的首要原因,在使用 LuxCore.initialparameters 后,我们将参数（NamedTuple）转换为 Vector 类型,然后与模型参数和初始状态一同构建模型参数.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"nn_pas = ComponentVector(epnn=ep_nn_params, qnn=q_nn_params)\npas = ComponentVector(params=params, initstates=init_states, nns=nn_pas)","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"值得注意的是,需要使用 nns 这个键名存储神经网络的参数,保证与模型参数和初始状态独立,同时神经网络参数 nn_pas 需要使用模型名称和参数作为键值对构建参数.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"最后将模型参数输入至模型中,就可以得到输出结果.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"output = m50_model(input_arr, pas)","category":"page"},{"location":"get_start_zh/#Conclusion","page":"Getting Started With HydroModels.jl","title":"Conclusion","text":"","category":"section"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"本教程详细介绍了 HydroModels.jl 的基本使用方法,包括：","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"模型的构建过程\n参数和初始状态的设置\n模型的运行和计算","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"通过本教程,用户可以快速掌握 HydroModels.jl 的核心功能,并开始构建自己的水文模型.","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"HydroModels.jl 还提供了更多高级功能,包括：","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"半分布式和分布式水文模型的构建与计算\n神经网络耦合的参数自适应模型\n支持单位线汇流的 GR4J 模型\n模型参数优化\n基于 Wrapper 的模型扩展功能","category":"page"},{"location":"get_start_zh/","page":"Getting Started With HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"这些高级特性将在后续教程中详细介绍.","category":"page"},{"location":"concepts_en/#HydroModels.jl-Concepts","page":"Basic Concepts","title":"HydroModels.jl Concepts","text":"","category":"section"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"HydroModels.jl implements a modular and extensible architecture, designed to support diverse hydrological modeling paradigms. The framework's core structure comprises four main classes: Flux, Bucket, Route, Model and Wrapper, each playing a vital role in constructing comprehensive hydrological systems. The framework is implemented in Julia programming language for model development, computation, and parameter optimization. It leverages Lux.jl as the deep learning framework and integrates with SciML for scientific computing, symbolic programming, and parameter optimization capabilities. The conceptual framework of the model design philosophy is illustrated in the following diagram:","category":"page"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"(Image: Framework Concept) Architecture and ecosystem of the HydroModels.jl framework. (a) illustrates the supporting ecosystem and its functional capabilities, highlighting the key dependencies and their roles in the framework; (b) shows the core architectural design of HydroModels.jl, demonstrating the main components and their interactions.","category":"page"},{"location":"concepts_en/#Flux-class:-Water-Process-Transfer-Representation","page":"Basic Concepts","title":"Flux class: Water Process Transfer Representation","text":"","category":"section"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"The Flux class serves as the fundamental building block of HydroModels.jl, drawing inspiration from flux library of the MARRMoT while extending its capabilities. This class encapsulates the physical equations governing water movement throughout the hydrological cycle. The conceptual formulation of the Flux class can be expressed as:","category":"page"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"beginaligned\nY(t) = f(X(t)theta)  (1) \nendaligned","category":"page"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"where the functional representation f maps input variables X(t) and parameters theta to output variables Y(t). Here, X(t) represents input variables like precipitation and temperature, theta denotes the parameters that can be calibrated, and Y(t) represents output variables like runoff and infiltration. Based on different applications, the Flux class includes:","category":"page"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"HydroFlux: Implements fundamental hydrological processes through mathematical formulations\nStateFlux: Handles mass-balance equations for state variables like soil moisture and snowpack\nNeuralFlux: Uses neural networks to model processes or predict parameters, leveraging Lux.jl capabilities","category":"page"},{"location":"concepts_en/#Bucket-Class:-Storage-Volume-Change-Simulation","page":"Basic Concepts","title":"Bucket Class: Storage Volume Change Simulation","text":"","category":"section"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"The Bucket class represents fundamental water storage components within the hydrological system. It consists of multiple HydroFlux components (including NeuralFlux) and StateFlux components, which collectively define the water balance dynamics through coupled differential equations. These components can represent various hydrological stores such as soil moisture, groundwater reservoirs, and surface water bodies.","category":"page"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"The Bucket class generates two essential functions:","category":"page"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"An ODE solver function for state variables\nA hydrological flux computation function for output calculations","category":"page"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"This dual-function architecture enables efficient computation of hydrological processes, following a two-step process of solving ODEs and computing output fluxes.","category":"page"},{"location":"concepts_en/#Route-Class:-Spatial-Flow-Propagation","page":"Basic Concepts","title":"Route Class: Spatial Flow Propagation","text":"","category":"section"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"The Route class simulates lateral water fluxes across landscapes and river networks, supporting both lumped \"integral\" and distributed \"differential\" models. Its core components include:","category":"page"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"beginaligned\nQ_out(t) = f_rflux(S_route(t)Q_gen(t) ps)  (2) \nfracdS_routedt = Q_in(t) - Q_out(t)  (3) \nQ_in(t+1) = f_aggr(Q_out(t))  (4) \nendaligned","category":"page"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"Where: Q_in is inflow, Q_out is outflow, S_route is the routing state variable, and f_aggr is the aggregation function.","category":"page"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"The class supports various routing methods including:","category":"page"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"Standard state-update approaches\nUnit hydrograph through convolution operations\nDynamic routing methods (Muskingum, kinematic wave)","category":"page"},{"location":"concepts_en/#Model-Class:-Hydrological-Process-Integration","page":"Basic Concepts","title":"Model Class: Hydrological Process Integration","text":"","category":"section"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"The Model class serves as the central management component, orchestrating the integration of Flux, Bucket, and Route components. It facilitates:","category":"page"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"Construction of distributed hydrological models\nIntegration of vertical water movement with lateral connectivity\nSystematic parameter optimization and sensitivity analysis\nEfficient computation through metadata-driven approaches","category":"page"},{"location":"concepts_en/#Wrapper-Class:-Enhanced-Component-Capabilities","page":"Basic Concepts","title":"Wrapper Class: Enhanced Component Capabilities","text":"","category":"section"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"The Wrapper class extends component customization capabilities while maintaining interface uniformity. Key features include:","category":"page"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"NamedTupleIO wrapper for customized input/output specifications\nEstimateParam wrapper for parameter prediction based on basin characteristics\nRecordComponentState wrapper for state variable storage, supporting both batch training and online forecasting","category":"page"},{"location":"extent/parameter_estimate/#讨论动态参数与基于HRUs属性的参数","page":"讨论动态参数与基于HRUs属性的参数","title":"讨论动态参数与基于HRUs属性的参数","text":"","category":"section"},{"location":"get_start_en/#Getting-Started-With-HydroModels.jl","page":"Get Started with HydroModels.jl","title":"Getting Started With HydroModels.jl","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"HydroModels.jl 是一个基于 Julia 语言的现代水文模型框架.它在 SUPERFLEX 设计理念的基础上进行了扩展和增强,具有灵活的模型构建能力和高效的计算性能,并支持深度学习模型集成.本教程将介绍如何使用 HydroModels.jl 构建和运行水文模型.","category":"page"},{"location":"get_start_en/#Installation,.","page":"Get Started with HydroModels.jl","title":"Installation,.","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"] add HydroModels","category":"page"},{"location":"get_start_en/#Build-a-ExpHydro-Model","page":"Get Started with HydroModels.jl","title":"Build a ExpHydro Model","text":"","category":"section"},{"location":"get_start_en/#Introduction-to-ExpHydro-Model","page":"Get Started with HydroModels.jl","title":"Introduction to ExpHydro Model","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"ExpHydro 是一个由积雪模块和土壤模块组成的简单水文模型.其数学表达式如下：","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"beginaligned\n textSnowpack Bucket \n pet = 298 cdot lday cdot 24 cdot 0611 cdot fracexp(173 cdot temp)temp + 2373 cdot frac1temp + 2732  (1) \n nowfall = H(T_min - temp) cdot prcp  (2) \n rainfall = H(temp - T_mn) cdot prcp (3) \n melt = H(temp - T_max) cdot H(snowpack) cdot min(snowpack D_f cdot (temp - T_max))  (4) \n fracd(snowpack)dt = snowfall - melt  (5) \n\n textSoilwater Bucket \n evap = H(soilwater) cdot pet cdot min(10 fracsoilwaterS_max)  (6) \n baseflow = H(soilwater) cdot Q_max cdot exp(-f cdot max(00 S_max - soilwater))  (7) \n surfaceflow = max(00 soilwater - S_max)  (8) \n flow = baseflow + urfaceflow  (9) \n fracd(soilwater)dt = rainfall + melt - evap - flow  (10)\nendaligned","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":",,,. 其中：","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"H(x)\n表示 Heaviside 阶跃函数,当 x  0 时为 1,否则为 0,.\nT_min T_max D_f S_max Q_max f\n为模型参数\ntemp lday prcp\n为输入变量\nsnowpack soilwater\n为状态变量\n其他变量为中间计算变量","category":"page"},{"location":"get_start_en/#Build-an-ExpHydro-Model-in-HydroModels.jl","page":"Get Started with HydroModels.jl","title":"Build an ExpHydro Model in HydroModels.jl","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"After understanding the basic principles of the ExpHydro model, we can use HydroModels.jl to build this model.","category":"page"},{"location":"get_start_en/#Import-Packages","page":"Get Started with HydroModels.jl","title":"Import Packages","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"First, import the HydroModels.jl package:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"using HydroModels","category":"page"},{"location":"get_start_en/#Define-Variables-and-Parameters","page":"Get Started with HydroModels.jl","title":"Define Variables and Parameters","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Define the model parameters, state variables, and other variables (including precipitation, evaporation, snowmelt, surface flow, etc.):","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"@variables temp lday pet prcp \n@variables snowfall rainfall melt evap baseflow surfaceflow flow\n@variables snowpack soilwater\n@parameters Tmin Tmax Df Smax Qmax f","category":"page"},{"location":"get_start_en/#Build-Flux-Formulas-by-HydroFlux","page":"Get Started with HydroModels.jl","title":"Build Flux Formulas by HydroFlux","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Next, we need to construct the various computational formulas of the model, including state equations and intermediate variable calculations. Let's use the snowmelt formula as an example to demonstrate how to use HydroFlux:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"melt_flux = HydroFlux([snowpack, temp] => [melt], [Tmax, Df], exprs=[step_func(temp - Tmax) * step_func(snowpack) * min(snowpack, Df * (temp - Tmax))])","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"When constructing HydroFlux, several points need attention:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Ensure all variables and parameters used in the expression are declared in the inputs\nInput and output variables are connected through the Pair type (=>)\nParameters are passed as vectors\nExpressions are passed as vectors to the exprs parameter","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"HydroFlux first accepts a Pair type consisting of input and output variables, then takes a Vector of parameters, and finally accepts the snowmelt formula expression through exprs to complete the construction of the snowmelt formula.","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"It's important to note that when building HydroFlux, you must ensure that all variables and parameters in expr are included in the input variables and parameters. If there are variables or parameters in exprs that haven't been provided to HydroFlux, errors may occur during subsequent calculations due to undefined variables. In such cases, you'll need to check if the HydroFlux construction is correct.","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Of course, when building HydroFlux, parameter variables are not always necessary. If parameters are not needed, they can be omitted, as shown in the potential evapotranspiration calculation formula:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"pet_flux = HydroFlux([temp, lday] => [pet], exprs=[29.8 * lday * 24 * 0.611 * exp(17.3 * temp) / (temp + 237.3) * 1 / (temp + 273.2)])","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"This formula uses temp and lday as input variables and calculates pet as the output variable. Since this formula doesn't involve parameters, there's no need to pass parameter variables.","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"It's worth noting that HydroFlux's exprs parameter can only accept a Vector of expressions. This is because HydroFlux sometimes needs to support multiple output variables, thus requiring multiple expressions, and the number of expressions must match the number of outputs. Here's an example using the rain-snow separation formula:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp])","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"This formula uses prcp and temp as input variables and calculates snowfall and rainfall as output variables, while using Tmin as a parameter. Since this formula outputs two variables (snowfall and rainfall), two expressions must be provided to represent the calculation formulas for each output variable.","category":"page"},{"location":"get_start_en/#Build-State-Formulas-by-StateFlux","page":"Get Started with HydroModels.jl","title":"Build State Formulas by StateFlux","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Generally, state equations are constructed as the sum of input fluxes minus the sum of output fluxes. Therefore, we can use a Pair to represent this input-output relationship and include the state variable to build a StateFlux. Here's an example with the snowpack state equation:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"snowpack_flux = StateFlux([snowfall] => [melt], snowpack)","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"This formula uses snowfall as the input variable and calculates snowpack as the output variable, while incorporating the state variable snowpack to construct the snowpack state equation.","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Typically, before constructing state equations, it's preferable to build all involved fluxes using HydroFlux first, then combine them using StateFlux with input-output flux Pairs and state variables to get an intuitive StateFlux. However, to avoid introducing unnecessary variables, you can also directly construct more complex StateFlux equations. In fact, this construction method is highly consistent with HydroFlux - it similarly takes input and output variables as StateFlux inputs, names the state variables and required parameters, and finally constructs the state equation. Let's rebuild the snowpack state equation:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"snowpack_flux = StateFlux([prcp, temp, melt], snowpack, [Tmin], expr=step_func(Tmin - temp) * prcp-melt)","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"In this state equation, instead of directly calculating snowfall, we perform the calculation using prcp and temp, combining with the state equation dsnowpack/dt=snowfall-melt to construct a complex state equation that omits the snowfall intermediate variable.","category":"page"},{"location":"get_start_en/#Build-Snowfall-Bucket","page":"Get Started with HydroModels.jl","title":"Build Snowfall Bucket","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"After completing the necessary HydroFlux and StateFlux constructions, we can build a HydroBucket. Using the snowpack Bucket as an example, we need to pass the constructed HydroFlux and StateFlux to HydroBucket.","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"First, store the relevant HydroFlux and StateFlux in a Vector:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"fluxes_1 = [\n    HydroFlux([temp, lday] => [pet], exprs=[29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)]),\n    HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp]),\n    HydroFlux([snowpack, temp] => [melt], [Tmax, Df], exprs=[step_func(temp - Tmax) * step_func(snowpack) * min(snowpack, Df * (temp - Tmax))]),\n]\ndfluxes_1 = [StateFlux([snowfall] => [melt], snowpack),]\nsnowpack_bucket = HydroBucket(name=:surface, fluxes=fluxes_1, dfluxes=dfluxes_1)","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Then use these Vector variables as input to build a hydrological computation module, i.e., HydroBucket:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"snowpack_bucket = HydroBucket(name=:surface, fluxes=fluxes_1, dfluxes=dfluxes_1)","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Through HydroBucket, we can complete the construction of a hydrological computation module. During the construction of HydroBucket, the program executes some automatic construction methods to express the ordinary differential equations and other variable calculation functions in the computation module. For implementation details, please refer to the implementation section.","category":"page"},{"location":"get_start_en/#Build-Exphydro-Model","page":"Get Started with HydroModels.jl","title":"Build Exphydro Model","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Following the same logic, we can build the soil computation module, then concatenate the two modules into a Vector type and input it to HydroModel to complete the construction of the ExpHydro model. The complete construction code is as follows:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"#* import packages\nusing HydroModels\n\n#* define variables and parameters\n@variables temp lday pet prcp \n@variables snowfall rainfall melt evap baseflow surfaceflow flow\n@variables snowpack soilwater\n@parameters Tmin Tmax Df Smax Qmax f\n\nstep_func(x) = (tanh(5.0 * x) + 1.0) * 0.5\n\n#* define snowpack bucket\nfluxes_1 = [\n    HydroFlux([temp, lday] => [pet], exprs=[29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)]),\n    HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp]),\n    HydroFlux([snowpack, temp] => [melt], [Tmax, Df], exprs=[step_func(temp - Tmax) * step_func(snowpack) * min(snowpack, Df * (temp - Tmax))]),\n]\ndfluxes_1 = [StateFlux([snowfall] => [melt], snowpack),]\nsnowpack_bucket = HydroBucket(name=:surface, fluxes=fluxes_1, dfluxes=dfluxes_1)\n\n#* define soilwater bucket\nfluxes_2 = [\n    HydroFlux([soilwater, pet] => [evap], [Smax], exprs=[step_func(soilwater) * pet * min(1.0, soilwater / Smax)]),\n    HydroFlux([soilwater] => [baseflow], [Smax, Qmax, f], exprs=[step_func(soilwater) * Qmax * exp(-f * (max(0.0, Smax - soilwater)))]),\n    HydroFlux([soilwater] => [surfaceflow], [Smax], exprs=[max(0.0, soilwater - Smax)]),\n    HydroFlux([baseflow, surfaceflow] => [flow], exprs=[baseflow + surfaceflow]),\n]\ndfluxes_2 = [StateFlux([rainfall, melt] => [evap, flow], soilwater)]\nsoilwater_bucket = HydroBucket(name=:soil, fluxes=fluxes_2, dfluxes=dfluxes_2)\n\n#* define the Exp-Hydro model\nexphydro_model = HydroModel(name=:exphydro, components=[snowpack_bucket, soilwater_bucket])","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"This completes the construction of an ExpHydro model. When we print this type, we can see the basic information contained in the model:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"HydroModel: exphydro\n   Components: surface, soil\n   Inputs: [temp, lday, prcp]\n   States: [snowpack, soilwater]\n   Outputs: [pet, snowfall, rainfall, melt, evap, baseflow, surfaceflow, flow]\n   Parameters: [Tmin, Tmax, Df, Smax, Qmax, f]\n   Components:\n       Fluxes: 0 fluxes\n       Buckets: 2 buckets\n       Routes: 0 routes","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"This information shows the model's name, component names, input variables, state variables, output variables, parameter variables, and the number of Fluxes, Buckets, and Routes contained in the model.","category":"page"},{"location":"get_start_en/#Define-Neural-Network-by-Lux.jl","page":"Get Started with HydroModels.jl","title":"Define Neural Network by Lux.jl","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"HydroModels.jl supports neural network definition through Lux.jl. Here's an example using a simple fully connected neural network:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"using Lux\n\n# define the ET NN and Q NN\nep_nn = Lux.Chain(\n    Lux.Dense(3 => 16, tanh),\n    Lux.Dense(16 => 16, leakyrelu),\n    Lux.Dense(16 => 1, leakyrelu),\n    name=:epnn\n)\n\nq_nn = Lux.Chain(\n    Lux.Dense(2 => 16, tanh),\n    Lux.Dense(16 => 16, leakyrelu),\n    Lux.Dense(16 => 1, leakyrelu),\n    name=:qnn\n)","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"After constructing two fully connected neural networks ep_nn and q_nn using Lux.jl, we can build neural network formulas using NeuralFlux provided by HydroModel.jl:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"@variables norm_snw norm_slw norm_temp norm_prcp\n@variables log_evap_div_lday log_flow\n\nep_nn_flux = NeuralFlux([norm_snw, norm_slw, norm_temp] => [log_evap_div_lday], ep_nn)\nq_nn_flux = NeuralFlux([norm_slw, norm_prcp] => [log_flow], q_nn)","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"NeuralFlux is a derivative type of HydroFlux. It similarly accepts a Pair of input and output variables, but unlike HydroFlux, it doesn't require model parameters and calculation formulas. Instead, it needs the neural network to be passed as a parameter to NeuralFlux to construct the neural network formula. It's important to note that the input and output variable dimensions must match those of the NeuralFlux.","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"After completing the construction of NeuralFlux, we can pass it along with other HydroFluxes to HydroBucket to build a neural network-coupled hydrological model:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"soil_fluxes = [\n    #* normalize\n    HydroFlux([snowpack, soilwater, prcp, temp] => [norm_snw, norm_slw, norm_prcp, norm_temp],\n        [snowpack_mean, soilwater_mean, prcp_mean, temp_mean, snowpack_std, soilwater_std, prcp_std, temp_std],\n        exprs=[(var - mean) / std for (var, mean, std) in zip([snowpack, soilwater, prcp, temp],\n            [snowpack_mean, soilwater_mean, prcp_mean, temp_mean],\n            [snowpack_std, soilwater_std, prcp_std, temp_std]\n        )]),\n    ep_nn_flux,\n    q_nn_flux\n]","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"This soil module includes normalization formulas, evaporation formulas, and runoff formulas. Next, we can pass these formulas to HydroBucket and combine them with state equations to complete the construction of the soil module:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"state_expr = rainfall + melt - step_func(soilwater) * lday * exp(log_evap_div_lday) - step_func(soilwater) * exp(log_flow)\nsoil_dfluxes = [StateFlux([soilwater, rainfall, melt, lday, log_evap_div_lday, log_flow], soilwater, expr=state_expr)]\nsoilwater_bucket = HydroBucket(name=:soil, fluxes=soil_fluxes, dfluxes=soil_dfluxes)\nm50_model = HydroModel(name=:m50, components=[snowpack_bucket, soilwater_bucket])","category":"page"},{"location":"get_start_en/#Run-a-ExpHydro-Model","page":"Get Started with HydroModels.jl","title":"Run a ExpHydro Model","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"After completing the model construction, since the model is callable, we can input the data and parameters into the model to obtain output results.","category":"page"},{"location":"get_start_en/#Prepare-Input-Data","page":"Get Started with HydroModels.jl","title":"Prepare Input Data","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"The model accepts input observation data of type AbstractMatrix, with dimensions being the number of input variables multiplied by the number of time steps. For example, if there are 3 input variables and 1000 time steps, the input observation data dimensions would be (3, 1000). It's important to note that the index of input variables in the dimension will affect the model calculation results, as the model cannot automatically identify which row in the Matrix corresponds to which input variable. Therefore, users can first prepare a Dict or NamedTuple type, then use HydroModels.get_input_names(model) to get the names of the model's input variables, and combine these names with the Dict or NamedTuple to construct the Matrix type input data:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"input = (lday=df[ts, \"dayl(day)\"], temp=df[ts, \"tmean(C)\"], prcp=df[ts, \"prcp(mm/day)\"])\ninput_arr = Matrix(reduce(hcat, collect(input[HydroModels.get_input_names(exphydro_model)]))')","category":"page"},{"location":"get_start_en/#Prepare-Parameters-and-Initial-States","page":"Get Started with HydroModels.jl","title":"Prepare Parameters and Initial States","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"For parameter preparation, HydroModels.jl accepts parameters of type ComponentVector (using ComponentArrays), storing parameter names and values in the ComponentVector, for example:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"f, Smax, Qmax, Df, Tmax, Tmin = 0.01674478, 1709.461015, 18.46996175, 2.674548848, 0.175739196, -2.092959084\nparams = ComponentVector(f=f, Smax=Smax, Qmax=Qmax, Df=Df, Tmax=Tmax, Tmin=Tmin)","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"For initial state preparation, HydroModels.jl similarly accepts initial states of type ComponentVector, storing state names and values in the ComponentVector, for example:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"init_states = ComponentVector(snowpack=0.0, soilwater=1303.004248)","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Then store the parameters and initial states in a single ComponentVector (sometimes initial states are also treated as parameters to be optimized, so they need to be stored together with parameters for unified management):","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"pas = ComponentVector(params=params, initstates=init_states)","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"[Would you like me to continue with the next section?]","category":"page"},{"location":"get_start_en/#Run-the-ExpHydro-Model","page":"Get Started with HydroModels.jl","title":"Run the ExpHydro Model","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Finally, we can input the data and parameters into the model to obtain the output results:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"result = exphydro_model(input_arr, pas)","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"The model output is also of type AbstractMatrix, with dimensions being the number of output variables (including state variables) multiplied by the number of time steps. For example, if there are 8 output variables and 1000 time steps, the output dimensions would be (8, 1000). If you want to export the results as a DataFrame type, you can use HydroModels.get_output_names(model) to get the names of the output variables, then combine them with a Dict or NamedTuple to construct a DataFrame:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"states_and_output_names = vcat(HydroModels.get_state_names(exphydro_model), HydroModels.get_output_names(exphydro_model))\noutput = NamedTuple{Tuple(states_and_output_names)}(eachslice(result, dims=1))\ndf = DataFrame(output)","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"The calculation results look like this:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"10000×10 DataFrame\n   Row │ snowpack  soilwater  pet      snowfall  rainfall  melt      evap      baseflow   surfaceflow  flow      \n       │ Float64   Float64    Float64  Float64   Float64   Float64   Float64   Float64    Float64      Float64   \n───────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │    0.0         0.0      3.1        0.0   1305.22  1.13779   0.868735  0.0212194          0.0  0.0212194\n     2 │    0.0         0.0      4.24       0.0   1308.28  1.51019   1.15578   0.0223371          0.0  0.0223371\n     3 │    0.0         0.0      8.02       0.0   1315.03  1.63204   1.25547   0.0250095          0.0  0.0250095\n     4 │    0.0         0.0     15.27       0.0   1329.34  1.21771   0.946937  0.0317802          0.0  0.0317802\n     5 │    0.0         0.0      8.48       0.0   1336.99  1.02779   0.803845  0.0361228          0.0  0.0361228\n   ⋮   │    ⋮          ⋮         ⋮        ⋮         ⋮         ⋮         ⋮          ⋮           ⋮           ⋮\n  9996 │  254.264       0.0      0.0       -0.0   1521.37  0.221762  0.197362  0.791897           0.0  0.791897\n  9997 │  266.324      12.06     0.0       -0.0   1520.37  0.238907  0.21248   0.778688           0.0  0.778688\n  9998 │  277.874      11.55     0.0       -0.0   1519.33  0.288362  0.256291  0.765307           0.0  0.765307\n  9999 │  279.714       1.84     0.0       -0.0   1518.29  0.311022  0.27624   0.752073           0.0  0.752073\n 10000 │  279.854       0.14     0.0       -0.0   1517.38  0.176836  0.156967  0.740711           0.0  0.740711","category":"page"},{"location":"get_start_en/#Running-with-Config","page":"Get Started with HydroModels.jl","title":"Running with Config","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"The model computation is not limited to these basic features. To support necessary settings during the computation process, HydroModel can accept a config parameter.","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"For example, by default, the model uses only the Euler method to solve ordinary differential equations. However, sometimes a more accurate solving method is needed, which can be set using the config parameter.","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"To demonstrate this functionality, we need to additionally import OrdinaryDiffEq.jl and HydroModelTools.jl, then set the solving method:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"using OrdinaryDiffEq\nusing HydroModelTools\nusing DataInterpolations\n\nconfig = (solver=ODESolver(alg=Tsit5(), abstol=1e-3, reltol=1e-3), interp=LinearInterpolation)\noutput = exphydro_model(input_arr, pas, config=config)","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"The config parameter is set as a NamedTuple type, where the solver parameter is used to set the solving method, and the interp parameter is used to set the interpolation method. ODESolver is a solver wrapper class provided by HydroModelTools.jl that performs some data conversion on the solution results. It accepts solving methods from OrdinaryDiffEq.jl as parameters and sets the solving method parameters.","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"[Would you like me to continue with the neural network implementation section?]","category":"page"},{"location":"get_start_en/#Run-the-Neural-Network-Enhanced-Model","page":"Get Started with HydroModels.jl","title":"Run the Neural Network Enhanced Model","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Earlier we built an ExpHydro model coupled with neural networks, and now we can use this model to calculate results.","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"First, we need to prepare the model parameters. In addition to the ExpHydro model parameters, we also need to prepare neural network parameters:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"using StableRNGs\n\nep_nn_params = Vector(ComponentVector(LuxCore.initialparameters(ep_nn)))\nq_nn_params = Vector(ComponentVector(LuxCore.initialparameters(q_nn)))","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Models based on Lux.jl can decouple parameters from model structure, which is the primary reason we chose to use Lux.jl to build neural networks. After using LuxCore.initialparameters, we convert the parameters (NamedTuple) to Vector type, then combine them with the model parameters and initial states to build the complete model parameters:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"nn_pas = ComponentVector(epnn=ep_nn_params, qnn=q_nn_params)\npas = ComponentVector(params=params, initstates=init_states, nns=nn_pas)","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"It's important to note that we need to use the key name nns to store the neural network parameters, keeping them independent from model parameters and initial states. Additionally, the neural network parameters nn_pas need to use model names and parameters as key-value pairs.","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Finally, we can input the model parameters into the model to obtain the output results:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"output = m50_model(input_arr, pas)","category":"page"},{"location":"get_start_en/#Conclusion","page":"Get Started with HydroModels.jl","title":"Conclusion","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"This tutorial has provided a detailed introduction to the basic usage of HydroModels.jl, including:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Model building process\nParameter and initial state configuration\nModel execution and computation","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Through this tutorial, users can quickly master the core functionality of HydroModels.jl and begin building their own hydrological models.","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"HydroModels.jl also offers more advanced features, including:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Semi-distributed and distributed hydrological model construction and computation\nNeural network-coupled parameter-adaptive models\nGR4J model with unit hydrograph routing\nModel parameter optimization\nModel extension functionality based on Wrapper","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"These advanced features will be covered in subsequent tutorials.","category":"page"},{"location":"implements/build_m50_model_en/#Embedding-Neural-Networks-in-ExpHydro-Model:-Implementation-of-[M50](https://hess.copernicus.org/articles/26/5085/2022/)-Model","page":"construct the M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"","category":"section"},{"location":"implements/build_m50_model_en/","page":"construct the M50 Model","title":"construct the M50 Model","text":"marv-in proposed the M50 and M100 models in their paper, with code stored in HydroNODE, pioneering the integration of neural networks into hydrological models (notably by replacing ExpHydro model's calculation formulas while participating in balance equation solving). This model inspired our repository, and recognizing the current complexity in model development, our primary goal is to simplify the process of embedding neural networks into hydrological models. Below, we'll compare the source code with our repository's implementation of M50 and M100 models, showcasing a new approach to model construction.","category":"page"},{"location":"implements/build_m50_model_en/#M50-Implementation-in-HydroNODE","page":"construct the M50 Model","title":"M50 Implementation in HydroNODE","text":"","category":"section"},{"location":"implements/build_m50_model_en/","page":"construct the M50 Model","title":"construct the M50 Model","text":"First, let's examine the implementation of M50 and M100 models in HydroNODE:","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct the M50 Model","title":"construct the M50 Model","text":"# define the ODE problem\nfunction NeuralODE_M50_core!(dS,S,p,t)\n\n    Tmin, Tmax, Df = (p_bucket_precal...,)\n\n    Lday = itp_Lday(t)\n    P    = itp_P(t)\n    T    = itp_T(t)\n\n    g_ET = ann_ET([norm_S0(S[1]), norm_S1(S[2]), norm_T(T)],p[:p1]) #p[idcs_params_ann_ET])\n    g_Q = ann_Q([norm_S1(S[2]), norm_P(P)],p[:p2]) #p[idcs_params_ann_Q])\n\n    melting = M(S[1], T, Df, Tmax)\n    dS[1] = Ps(P, T, Tmin) - melting\n    dS[2] = Pr(P, T, Tmin) + melting - step_fct(S[2])*Lday*exp(g_ET[1])- step_fct(S[2])*exp(g_Q[1])\n\nend\n# build and solve ODE problem\nprob = ODEProblem(NeuralODE_M50_core!, S_init, Float64.((t_out[1], maximum(t_out))), p)\nsol = solve(prob, BS3(), dt=1.0, saveat=t_out, reltol=1e-3, abstol=1e-3, sensealg=BacksolveAdjoint(autojacvec=ZygoteVJP()))\n# calculate Qout\nP_interp = norm_P.(itp_P.(t_out))\nS1_ = norm_S1.(sol[2,:])\nQout_ =  exp.(ann_Q(permutedims([S1_ P_interp]),p[:p2])[1,:])","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct the M50 Model","title":"construct the M50 Model","text":"In the HydroNODE code, we can see that model construction consists of three steps:","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct the M50 Model","title":"construct the M50 Model","text":"ODE function definition\nODE problem construction and solution\nCalculation of Qout from intermediate states","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct the M50 Model","title":"construct the M50 Model","text":"While this code follows the standard style of the DifferentialEquations.jl library, it requires manual construction of model calculation formulas (M, Ps, Pr) and their combination with state equation expressions (dS). The model has high coupling, and obtaining intermediate calculation fluxes like Qout requires additional calls to corresponding calculation formulas, making the code relatively complex to write.","category":"page"},{"location":"implements/build_m50_model_en/#M50-Implementation-in-HydroModels.jl","page":"construct the M50 Model","title":"M50 Implementation in HydroModels.jl","text":"","category":"section"},{"location":"implements/build_m50_model_en/","page":"construct the M50 Model","title":"construct the M50 Model","text":"First, we need to define the parameters and variables designed in the M50 model:","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct the M50 Model","title":"construct the M50 Model","text":"using HydroModels\n\n#! parameters in the Exp-Hydro model\n@parameters Tmin Tmax Df Smax f Qmax\n#! parameters in normalize flux\n@parameters snowpack_std snowpack_mean\n@parameters soilwater_std soilwater_mean\n@parameters prcp_std prcp_mean\n@parameters temp_std temp_mean\n\n#! hydrological flux in the Exp-Hydro model\n@variables prcp temp lday pet rainfall snowfall\n@variables snowpack soilwater lday pet\n@variables melt log_evap_div_lday log_flow flow\n@variables norm_snw norm_slw norm_temp norm_prcp\n\nstep_func(x) = (tanh(5.0 * x) + 1.0) * 0.5","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct the M50 Model","title":"construct the M50 Model","text":"Compared to conventional conceptual hydrological models, the M50 model uses neural networks to replace hydrological flux calculation formulas (ET and Q). These neural networks differ significantly from standard calculation formulas, so HydroModels.jl uses NeuralFlux to represent neural networks. The NeuralFlux for ET and Q predictions is shown below:","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct the M50 Model","title":"construct the M50 Model","text":"using Lux\nusing StableRNGs\n\n# define the ET NN and Q NN\nep_nn = Lux.Chain(\n    Lux.Dense(3 => 16, tanh),\n    Lux.Dense(16 => 16, leakyrelu),\n    Lux.Dense(16 => 1, leakyrelu),\n    name=:epnn\n)\nep_nn_params = Vector(ComponentVector(first(Lux.setup(StableRNGs.LehmerRNG(1234), ep_nn))))\nq_nn = Lux.Chain(\n    Lux.Dense(2 => 16, tanh),\n    Lux.Dense(16 => 16, leakyrelu),\n    Lux.Dense(16 => 1, leakyrelu),\n    name=:qnn\n)\nq_nn_params = Vector(ComponentVector(first(Lux.setup(StableRNGs.LehmerRNG(1234), q_nn))))\n\n\nep_nn_flux = NeuralFlux([norm_snw, norm_slw, norm_temp] => [log_evap_div_lday], ep_nn)\nq_nn_flux = NeuralFlux([norm_slw, norm_prcp] => [log_flow], q_nn)","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct the M50 Model","title":"construct the M50 Model","text":"A special aspect of building the M50 model is the need to wrap embedded neural networks using the NeuralFlux model, providing input-output information for the neural networks and converting them into expressions during construction.","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct the M50 Model","title":"construct the M50 Model","text":"Then we can build the remaining parts of the M50 model:","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct the M50 Model","title":"construct the M50 Model","text":"# define the snow pack reservoir\nsnow_fluxes = [\n    HydroFlux([temp, lday] => [pet], exprs=[29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)]),\n    HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp]),\n    HydroFlux([snowpack, temp] => [melt], [Tmax, Df], exprs=[step_func(temp - Tmax) * min(snowpack, Df * (temp - Tmax))]),\n]\nsnow_dfluxes = [StateFlux([snowfall] => [melt], snowpack)]\nsnow_ele = HydroBucket(name=:exphydro_snow, fluxes=snow_fluxes, dfluxes=snow_dfluxes)\n\n# define the soil water reservoir\nsoil_fluxes = [\n    #* normalize\n    HydroFlux([snowpack, soilwater, prcp, temp] => [norm_snw, norm_slw, norm_prcp, norm_temp],\n        [snowpack_mean, soilwater_mean, prcp_mean, temp_mean, snowpack_std, soilwater_std, prcp_std, temp_std],\n        exprs=[(var - mean) / std for (var, mean, std) in zip([snowpack, soilwater, prcp, temp],\n            [snowpack_mean, soilwater_mean, prcp_mean, temp_mean],\n            [snowpack_std, soilwater_std, prcp_std, temp_std]\n        )]),\n    ep_nn_flux,\n    q_nn_flux\n]\nstate_expr = rainfall + melt - step_func(soilwater) * lday * exp(log_evap_div_lday) - step_func(soilwater) * exp(log_flow)\nsoil_dfluxes = [StateFlux([soilwater, rainfall, melt, lday, log_evap_div_lday, log_flow], soilwater, expr=state_expr)]\nsoil_ele = HydroBucket(name=:m50_soil, fluxes=soil_fluxes, dfluxes=soil_dfluxes)\nconvert_flux = HydroFlux([log_flow] => [flow], exprs=[exp(log_flow)])\n# define the Exp-Hydro model\nm50_model = HydroModel(name=:m50, components=[snow_ele, soil_ele, convert_flux]);","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct the M50 Model","title":"construct the M50 Model","text":"In the code above, we present a complete implementation of the M50 model, starting with the Snowpack Bucket implementation from ExpHydro, followed by the Soilwater Bucket implementation with neural network embedding. In the Soilwater Bucket module implementation, we can use defined NeuralFlux (ep_nn_flux and q_nn_flux) to express embedded neural networks, combining them with other HydroFlux components and using StateFlux to construct the Soilwater Bucket.","category":"page"},{"location":"extent/why_not_MTK_en/#HydroModels.jl-and-ModelingToolkit.jl","page":"Why not using ModelingToolkit.jl directly","title":"HydroModels.jl and ModelingToolkit.jl","text":"","category":"section"},{"location":"extent/why_not_MTK_en/#Why-Not-Use-[ModelingToolkit.jl](https://github.com/SciML/ModelingToolkit.jl)-Directly","page":"Why not using ModelingToolkit.jl directly","title":"Why Not Use ModelingToolkit.jl Directly","text":"","category":"section"},{"location":"extent/why_not_MTK_en/","page":"Why not using ModelingToolkit.jl directly","title":"Why not using ModelingToolkit.jl directly","text":"The design philosophy of HydroModels.jl is actually completely aligned with ModelingToolkit.jl. Both frameworks use Symbolics.jl for symbolic computation. ModelingToolkit.jl is a more general symbolic system that supports the construction of various problems, and ModelingToolkitStandardLibrary.jl provides support for basic components in specific domains.","category":"page"},{"location":"extent/why_not_MTK_en/","page":"Why not using ModelingToolkit.jl directly","title":"Why not using ModelingToolkit.jl directly","text":"However, I encountered several issues when using ModelingToolkit.jl:","category":"page"},{"location":"extent/why_not_MTK_en/","page":"Why not using ModelingToolkit.jl directly","title":"Why not using ModelingToolkit.jl directly","text":"Although ModelingToolkit.jl can express the ordinary differential equations of hydrological models through symbolic programming, its support for calculations like unit hydrograph and routing processes in hydrological models is not particularly ideal\nWithin the same module, such as evaporation calculation formulas and soil calculation modules, the modules needed for different regions may differ due to different formulas, requiring separate construction of calculation formulas to support model building\nHydrological models typically include multiple ordinary differential equations. Using a single ODESystem becomes relatively chaotic, while using multiple ODESystems becomes relatively complex\nAdditionally, ODESystem may not directly support multi-node input and spatial routing process calculations\nAlthough ModelingToolkitNeuralNets.jl exists for neural network model embedding, the integration is not as straightforward as imagined\nI also encountered issues with automatic differentiation support based on ModelingToolkit.jl, especially with Zygote.jl","category":"page"},{"location":"extent/why_not_MTK_en/","page":"Why not using ModelingToolkit.jl directly","title":"Why not using ModelingToolkit.jl directly","text":"Therefore, I decided to build my own model library, referencing the symbolic programming model construction approach, to better support the modeling needs of hydrological models.","category":"page"},{"location":"extent/why_not_MTK_en/#Future-Work","page":"Why not using ModelingToolkit.jl directly","title":"Future Work","text":"","category":"section"},{"location":"extent/why_not_MTK_en/","page":"Why not using ModelingToolkit.jl directly","title":"Why not using ModelingToolkit.jl directly","text":"It's undeniable that ModelingToolkit.jl is an excellent framework. After meeting the requirements of hydrological models, I will try to make the modules in HydroModels.jl become similar modules in ModelingToolkitStandardLibrary.jl, and inherit the support of ModelingToolkit.jl's AbstractSystem class to provide consistent functional support, thereby maintaining compatibility with more computational capabilities in the SciML ecosystem.","category":"page"},{"location":"tutorials/run_exphydro_model/#ExpHydro-Model-Tutorial","page":"ExpHydro Model Tutorial","title":"ExpHydro Model Tutorial","text":"","category":"section"},{"location":"tutorials/run_exphydro_model/#Overview","page":"ExpHydro Model Tutorial","title":"Overview","text":"","category":"section"},{"location":"tutorials/run_exphydro_model/","page":"ExpHydro Model Tutorial","title":"ExpHydro Model Tutorial","text":"This tutorial demonstrates how to use the ExpHydro model for hydrological calculations, including:","category":"page"},{"location":"tutorials/run_exphydro_model/","page":"ExpHydro Model Tutorial","title":"ExpHydro Model Tutorial","text":"Lumped calculation (Single HRU)\nDistributed calculation (Multiple HRUs)","category":"page"},{"location":"tutorials/run_exphydro_model/#Dependencies","page":"ExpHydro Model Tutorial","title":"Dependencies","text":"","category":"section"},{"location":"tutorials/run_exphydro_model/","page":"ExpHydro Model Tutorial","title":"ExpHydro Model Tutorial","text":"First, import the required Julia packages:","category":"page"},{"location":"tutorials/run_exphydro_model/","page":"ExpHydro Model Tutorial","title":"ExpHydro Model Tutorial","text":"using CSV            \nusing DataFrames     \nusing ComponentArrays\nusing BenchmarkTools\nusing NamedTupleTools\nusing Plots","category":"page"},{"location":"tutorials/run_exphydro_model/#Model-Setup","page":"ExpHydro Model Tutorial","title":"Model Setup","text":"","category":"section"},{"location":"tutorials/run_exphydro_model/#Parameter-Configuration","page":"ExpHydro Model Tutorial","title":"Parameter Configuration","text":"","category":"section"},{"location":"tutorials/run_exphydro_model/","page":"ExpHydro Model Tutorial","title":"ExpHydro Model Tutorial","text":"The ExpHydro model contains 6 key parameters defined using ComponentVector:","category":"page"},{"location":"tutorials/run_exphydro_model/","page":"ExpHydro Model Tutorial","title":"ExpHydro Model Tutorial","text":"# Define model parameters\nparams = ComponentVector(\n    f = 0.01674478,    # Infiltration parameter\n    Smax = 1709.461015, # Maximum soil water storage\n    Qmax = 18.46996175, # Maximum discharge\n    Df = 2.674548848,   # Degree-day factor\n    Tmax = 0.175739196, # Maximum temperature threshold\n    Tmin = -2.092959084 # Minimum temperature threshold\n)","category":"page"},{"location":"tutorials/run_exphydro_model/#Initial-States","page":"ExpHydro Model Tutorial","title":"Initial States","text":"","category":"section"},{"location":"tutorials/run_exphydro_model/","page":"ExpHydro Model Tutorial","title":"ExpHydro Model Tutorial","text":"Set initial states for the two calculation modules:","category":"page"},{"location":"tutorials/run_exphydro_model/","page":"ExpHydro Model Tutorial","title":"ExpHydro Model Tutorial","text":"# Define initial states\ninistates = ComponentVector(\n    snowpack = 0.0,           # Snow accumulation\n    soilwater = 1303.004248   # Soil water content\n)","category":"page"},{"location":"tutorials/run_exphydro_model/#Data-Preparation","page":"ExpHydro Model Tutorial","title":"Data Preparation","text":"","category":"section"},{"location":"tutorials/run_exphydro_model/","page":"ExpHydro Model Tutorial","title":"ExpHydro Model Tutorial","text":"The model uses hydrometeorological data from \"data/exphydro/01013500.csv\":","category":"page"},{"location":"tutorials/run_exphydro_model/","page":"ExpHydro Model Tutorial","title":"ExpHydro Model Tutorial","text":"# Read input data\nfile_path = \"data/exphydro/01013500.csv\"\ndata = CSV.File(file_path)\ndf = DataFrame(data)\nts = collect(1:10000)  # Time series length","category":"page"},{"location":"tutorials/run_exphydro_model/","page":"ExpHydro Model Tutorial","title":"ExpHydro Model Tutorial","text":"Input variables include:","category":"page"},{"location":"tutorials/run_exphydro_model/","page":"ExpHydro Model Tutorial","title":"ExpHydro Model Tutorial","text":"Day length (dayl)\nMean temperature (tmean)\nPrecipitation (prcp)","category":"page"},{"location":"tutorials/run_exphydro_model/#Import-the-ExpHydro-Model","page":"ExpHydro Model Tutorial","title":"Import the ExpHydro Model","text":"","category":"section"},{"location":"tutorials/run_exphydro_model/","page":"ExpHydro Model Tutorial","title":"ExpHydro Model Tutorial","text":"include(\"../models/ExpHydro.jl\")\nprintln(exphydro_model)","category":"page"},{"location":"tutorials/run_exphydro_model/","page":"ExpHydro Model Tutorial","title":"ExpHydro Model Tutorial","text":"HydroModel: exphydro\n  Components: surface, soil\n  Inputs: temp, lday, prcp\n  Outputs: pet, snowfall, rainfall, melt, evap, baseflow, surfaceflow, flow\n  Parameters: Tmin, Tmax, Df, Smax, Qmax, f\n  States: snowpack, soilwater\n  Components:\n    Fluxes: 0 fluxes\n    Buckets: 2 buckets\n    Route: nothing","category":"page"},{"location":"tutorials/run_exphydro_model/#Model-Testing","page":"ExpHydro Model Tutorial","title":"Model Testing","text":"","category":"section"},{"location":"tutorials/run_exphydro_model/#Single-Node-Testing","page":"ExpHydro Model Tutorial","title":"Single Node Testing","text":"","category":"section"},{"location":"tutorials/run_exphydro_model/","page":"ExpHydro Model Tutorial","title":"ExpHydro Model Tutorial","text":"# Configure solver\nsolver = HydroModels.ManualSolver{true}()\npas = ComponentVector(params=params, inistates=inistates)\n# Run model with benchmarking\nresult = exphydro_model(input, pas, config=(solver=solver, timeidx=ts))\n\n# convert to NamedTuple\nmodel_total_output_names = vcat(HydroModels.get_state_names(exphydro_model), HydroModels.get_output_names(exphydro_model))\nresult_ntp = NamedTuple{Tuple(model_total_output_names)}(eachslice(result, dims=1))\n\n# Visualize results\nplot(result_ntp.flow, label=\"Simulated\")\nplot!(df[ts, \"flow(mm)\"], label=\"Observed\")","category":"page"},{"location":"tutorials/run_exphydro_model/","page":"ExpHydro Model Tutorial","title":"ExpHydro Model Tutorial","text":"(Image: exphydro predict)","category":"page"},{"location":"tutorials/run_exphydro_model/#The-other-hydrological-fluxes-are-also-available","page":"ExpHydro Model Tutorial","title":"The other hydrological fluxes are also available","text":"","category":"section"},{"location":"tutorials/run_exphydro_model/","page":"ExpHydro Model Tutorial","title":"ExpHydro Model Tutorial","text":"output_df = DataFrame(result)","category":"page"},{"location":"tutorials/run_exphydro_model/","page":"ExpHydro Model Tutorial","title":"ExpHydro Model Tutorial","text":"10000×10 DataFrame\n   Row │ snowpack  soilwater  pet       snowfall  rainfall  melt       evap     baseflow  surfaceflow  flow      \n       │ Float64   Float64    Float64   Float64   Float64   Float64    Float64  Float64   Float64      Float64\n───────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │      0.0      0.0    1.13779       0.0       3.1   0.0204477      0.0   1303.0      0.867263  0.0204477\n     2 │      0.0      0.0    1.51019       0.0       4.24  0.0211591      0.0   1305.05     1.15292   0.0211591\n     3 │      0.0      0.0    1.63204       0.0       8.02  0.0228657      0.0   1309.68     1.25036   0.0228657\n     4 │      0.0      0.0    1.21771       0.0      15.27  0.0274505      0.0   1320.59     0.940706  0.0274505\n     5 │      0.0      0.0    1.02779       0.0       8.48  0.033228       0.0   1332.0      0.800846  0.033228\n   ⋮   │    ⋮          ⋮         ⋮         ⋮         ⋮          ⋮         ⋮        ⋮           ⋮           ⋮\n  9996 │      0.0    261.111  0.221762      0.0       0.0   0.495441      -0.0   1493.37     0.193729  0.495441\n  9997 │      0.0    266.638  0.238907     12.06      0.0   0.49106       -0.0   1492.84     0.208632  0.49106\n  9998 │      0.0    278.143  0.288362     11.55      0.0   0.486664      -0.0   1492.3      0.25173   0.486664\n  9999 │      0.0    285.026  0.311022      1.84      0.0   0.482119      -0.0   1491.74     0.271409  0.482119\n 10000 │      0.0    286.074  0.176836      0.14      0.0   0.477275      -0.0   1491.14     0.154251  0.477275","category":"page"},{"location":"tutorials/run_exphydro_model/#trial-another-solver-(using-[HydroModelTools](https://github.com/chooron/HydroModelTools.jl))","page":"ExpHydro Model Tutorial","title":"trial another solver (using HydroModelTools)","text":"","category":"section"},{"location":"tutorials/run_exphydro_model/","page":"ExpHydro Model Tutorial","title":"ExpHydro Model Tutorial","text":"using HydroModelTools: ODESolver, DiscreteSolver\nusing OrdinalDiffEq\n\n# using continuous solver\nresult1 = exphydro_model(input, pas, config=(solver=ODESolver(alg=Tsit5(), abstol=1e-3, reltol=1e-3), timeidx=ts))\n# using discrete solver\nresult2 = exphydro_model(input, pas, config=(solver=DiscreteSolver(), timeidx=ts))","category":"page"},{"location":"tutorials/run_exphydro_model/#Single-Node-Benchmarking","page":"ExpHydro Model Tutorial","title":"Single Node Benchmarking","text":"","category":"section"},{"location":"tutorials/run_exphydro_model/","page":"ExpHydro Model Tutorial","title":"ExpHydro Model Tutorial","text":"# Performance testing using BenchmarkTools\n@btime exphydro_model(input, params, config=(solver=solver, timeidx=ts), convert_to_ntp=true);\n@btime exphydro_model(input, params, config=(solver=ODESolver(alg=Tsit5(), abstol=1e-3, reltol=1e-3), timeidx=ts), convert_to_ntp=true);\n@btime exphydro_model(input, params, config=(solver=DiscreteSolver(), timeidx=ts), convert_to_ntp=true);","category":"page"},{"location":"tutorials/run_exphydro_model/","page":"ExpHydro Model Tutorial","title":"ExpHydro Model Tutorial","text":"Efficiency of each solver","category":"page"},{"location":"tutorials/run_exphydro_model/","page":"ExpHydro Model Tutorial","title":"ExpHydro Model Tutorial","text":"16.612 ms (328670 allocations: 35.08 MiB)\n16.748 ms (328670 allocations: 35.08 MiB)\n7.844 ms (160412 allocations: 20.11 MiB)","category":"page"},{"location":"tutorials/run_exphydro_model/#Multi-Node-Testing","page":"ExpHydro Model Tutorial","title":"Multi-Node Testing","text":"","category":"section"},{"location":"tutorials/run_exphydro_model/","page":"ExpHydro Model Tutorial","title":"ExpHydro Model Tutorial","text":"Multi-node setup for distributed computing:","category":"page"},{"location":"tutorials/run_exphydro_model/","page":"ExpHydro Model Tutorial","title":"ExpHydro Model Tutorial","text":"# Setup multiple nodes\nnode_num = 10  # Number of nodes\n# convert to 3D array (variables, node_num, time)\ninputs = repeat(reshape(input, size(input)[1], 1, size(input)[2]), 1, node_num, 1)\nptypes = [Symbol(:node, i) for i in 1:node_num]\n\n# Configure parameters and states for multiple nodes\nparams_multi = ComponentVector(NamedTuple{Tuple(ptypes)}(repeat([params], node_num)))\ninit_states_multi = ComponentVector(NamedTuple{Tuple(ptypes)}(repeat([inistates], node_num)))\npas_multi = ComponentVector(params=params_multi, initstates=init_states_multi)\n# Run multi-node simulation\nresults = exphydro_model(inputs, pas_multi, config=(solver=solver, timeidx=ts))","category":"page"},{"location":"extent/framework comparision_zh/#比较superflexpy,-MARRMoT-和-HydroModels.jl三种库对于自定义模型的编程风格","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"","category":"section"},{"location":"extent/framework comparision_zh/","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"本内容对应了论文的4.1节的内容,我们在这里希望能够讨论三种软件库对于模型计算公式的自定义的编程风格的差异. 我们以GR4J模型的实习过程为例,对模型计算公式的自定义的编程风格进行比较.","category":"page"},{"location":"extent/framework comparision_zh/#[Superflexpy](https://github.com/dalmo1991/superflexPy/tree/master)","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"Superflexpy","text":"","category":"section"},{"location":"extent/framework comparision_zh/","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"Superflexpy是基于SUPERFLEX思想下的python代码实现, 针对于水文模型中一些计算功能的实现, 该框架一般而言是直接使用python语法表述模型的计算公式, 如下所示.","category":"page"},{"location":"extent/framework comparision_zh/","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"@staticmethod\ndef _flux_function_python(S, S0, ind, P, x1, alpha, beta, ni, PET, dt):\n    if ind is None:\n        return (\n            [\n                P * (1 - (S / x1) ** alpha), # Ps\n                -PET * (2 * (S / x1) - (S / x1) ** alpha), # Evaporation\n                -((x1 ** (1 - beta)) / ((beta - 1) * dt)) * (ni ** (beta - 1)) * (S**beta), # Perc\n            ],\n            0.0,\n            S0 + P * (1 - (S / x1) ** alpha) * dt,\n        )\n    else:\n        return (\n            [\n                P[ind] * (1 - (S / x1[ind]) ** alpha[ind]), # Ps\n                -PET[ind] * (2 * (S / x1[ind]) - (S / x1[ind]) ** alpha[ind]), # Evaporation\n                -((x1[ind] ** (1 - beta[ind])) / ((beta[ind] - 1) * dt[ind]))\n                * (ni[ind] ** (beta[ind] - 1))\n                * (S ** beta[ind]), # Perc\n            ],\n            0.0,\n            S0 + P[ind] * (1 - (S / x1[ind]) ** alpha[ind]) * dt[ind],\n            [\n                -(P[ind] * alpha[ind] / x1[ind]) * ((S / x1[ind]) ** (alpha[ind] - 1)),\n                -(PET[ind] / x1[ind]) * (2 - alpha[ind] * ((S / x1[ind]) ** (alpha[ind] - 1))),\n                -beta[ind]\n                * ((x1[ind] ** (1 - beta[ind])) / ((beta[ind] - 1) * dt[ind]))\n                * (ni[ind] ** (beta[ind] - 1))\n                * (S ** (beta[ind] - 1)),\n            ],\n        )\n\n@staticmethod\n@nb.jit(\n    \"Tuple((UniTuple(f8, 3), f8, f8, UniTuple(f8, 3)))\"\n    \"(optional(f8), f8, i4, f8[:], f8[:], f8[:], f8[:], f8[:], f8[:], f8[:])\",\n    nopython=True,\n)\ndef _flux_function_numba(S, S0, ind, P, x1, alpha, beta, ni, PET, dt):\n    return (\n        (\n            P[ind] * (1 - (S / x1[ind]) ** alpha[ind]),  # Ps\n            -PET[ind] * (2 * (S / x1[ind]) - (S / x1[ind]) ** alpha[ind]),  # Evaporation\n            -((x1[ind] ** (1 - beta[ind])) / ((beta[ind] - 1) * dt[ind]))\n            * (ni[ind] ** (beta[ind] - 1))\n            * (S ** beta[ind]),  # Perc\n        ),\n        0.0,\n        S0 + P[ind] * (1 - (S / x1[ind]) ** alpha[ind]) * dt[ind],\n        (\n            -(P[ind] * alpha[ind] / x1[ind]) * ((S / x1[ind]) ** (alpha[ind] - 1)),\n            -(PET[ind] / x1[ind]) * (2 - alpha[ind] * ((S / x1[ind]) ** (alpha[ind] - 1))),\n            -beta[ind]\n            * ((x1[ind] ** (1 - beta[ind])) / ((beta[ind] - 1) * dt[ind]))\n            * (ni[ind] ** (beta[ind] - 1))\n            * (S ** (beta[ind] - 1)),\n        ),\n    )","category":"page"},{"location":"extent/framework comparision_zh/","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"可以看出, superflexpy框架在实现GR4J的production模块计算时origin code,不仅需要分别构建numpy和numba的计算代码,在函数中需要给出模型中涉及的水文通量Ps,Evaporation,Perc,同时还要给出状态变量的平衡方程,一个代码中需要耦合多个计算过程的实现代码,不仅导致代码的复用的灵活性较差(仅能在模块层面进行复用),模型编写的代码量和重复度也较高.","category":"page"},{"location":"extent/framework comparision_zh/#[MARRMoT](https://github.com/wknoben/MARRMoT)","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"MARRMoT","text":"","category":"section"},{"location":"extent/framework comparision_zh/","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"MARRMoT是一个由MATLAB语言开发的水文模型框架,该框架根据不同水文模型会分别构建模型类型,储存模型涉及的计算公式和状态变化方程,GR4J模型在该框架下的实现代码(简化了变量命名)如下所示.","category":"page"},{"location":"extent/framework comparision_zh/","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"function [dS, fluxes] = model_fun(obj, S)\n    % definitions\n    ...\n    % fluxes functions\n    flux_pn   = max(P-Ep,0);\n    flux_en   = max(Ep-P,0);\n    flux_ef   = P - flux_pn;\n    flux_ps   = saturation_4(S1,x1,flux_pn);\n    flux_es   = evap_11(S1,x1,flux_en);\n    flux_perc = percolation_3(S1,x1);\n    flux_q9   = route(.9.*(flux_pn - flux_ps + flux_perc), uh_q9);\n    flux_q1   = route(.1.*(flux_pn - flux_ps + flux_perc), uh_q1);\n    flux_fr   = recharge_2(3.5,S2,x3,x2);\n    flux_fq   = flux_fr;\n    flux_qr   = baseflow_3(S2,x3);\n    flux_qt   = flux_qr + max(flux_q1 + flux_fq,0);\n    % this flux is not included in original MARRMoT,\n    % but it is useful to calculate the water balance\n    flux_ex = flux_fr + max(flux_q1 + flux_fq,0) - flux_q1;      \n    % stores ODEs\n    dS1 = flux_ps - flux_es - flux_perc;\n    dS2 = flux_q9 + flux_fr - flux_qr;\n    % outputs\n    dS = [dS1 dS2];\n    fluxes = [flux_pn,   flux_en, flux_ef, flux_ps, flux_es,...\n                flux_perc, flux_q9, flux_q1, flux_fr, flux_fq,...\n                flux_qr,   flux_qt, flux_ex];\nend","category":"page"},{"location":"extent/framework comparision_zh/","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"可以看出,MARRMoT框架将每一个Flux计算公式由函数进行表达,因此使用者可以直接调取函数进行计算(可以根据提供的文档进行调用),这种方式相比superflexpy的确简化了很多代码编写需求. 然而MARRMoT对于模块的重复率支持性较差,不能够像superflexpy那样进行复用. 同时将变量赋值,通量计算和状态变化方程以一个函数包括,计算内容的解耦性较差.","category":"page"},{"location":"extent/framework comparision_zh/#HydroModels.jl","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"HydroModels.jl","text":"","category":"section"},{"location":"extent/framework comparision_zh/","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"#* define the production store\nprod_funcs = [\n    HydroFlux([prcp, ep] => [pn, en], exprs=[prcp - min(prcp, ep), ep - min(prcp, ep)]),\n    HydroFlux([pn, soilwater] => [ps], [x1], exprs=[max(0.0, pn * (1 - (soilwater / x1)^2))]),\n    HydroFlux([en, soilwater] => [es], [x1], exprs=[en * (2 * soilwater / x1 - (soilwater / x1)^2)]),\n    HydroFlux([soilwater] => [perc], [x1], exprs=[((x1)^(-4)) / 4 * ((4 / 9)^(4)) * (soilwater^5)]),\n    HydroFlux([pn, ps, perc] => [pr], exprs=[pn - ps + perc]),\n    HydroFlux([pr] => [slowflow, fastflow], exprs=[0.9 * pr, 0.1 * pr]),\n]\nprod_dfuncs = [StateFlux([ps] => [es, perc], soilwater)]\nprod_ele = HydroBucket(name=:gr4j_prod, funcs=prod_funcs, dfuncs=prod_dfuncs)\n\n#* uh function\nuh_flux_1 = HydroModels.UnitHydrograph([slowflow] => [slowflow_routed], x4, uhfunc=HydroModels.UHFunction(:UH_1_HALF), solvetype=:SPARSE)\nuh_flux_2 = HydroModels.UnitHydrograph([fastflow] => [fastflow_routed], x4, uhfunc=HydroModels.UHFunction(:UH_2_FULL), solvetype=:SPARSE)\n\n#* define the routing store\nrst_funcs = [\n    HydroFlux([routingstore] => [exch], [x2, x3], exprs=[x2 * abs(routingstore / x3)^3.5]),\n    HydroFlux([routingstore, slowflow, exch] => [routedflow], [x3], exprs=[x3^(-4) / 4 * (routingstore + slowflow + exch)^5]),\n    HydroFlux([routedflow, fastflow_routed, exch] => [flow], exprs=[routedflow + max(fastflow_routed + exch, 0.0)]),\n]\nrst_dfuncs = [StateFlux([exch, slowflow] => [routedflow], routingstore)]\nrst_ele = HydroBucket(name=:gr4j_rst, funcs=rst_funcs, dfuncs=rst_dfuncs)\n\ngr4j_model = HydroModel(name=:gr4j, components=[prod_ele, uh_flux_1, uh_flux_2, rst_ele])","category":"page"},{"location":"extent/framework comparision_zh/","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"回到HydroModels.jl框架中对于GR4J模型的实现, 在该代码中我们依次对production store, unit hydrograph, routing store进行了定义, 在这个过程中,在变量对应的前提下,模型能够实现可复用的能力. 在这个搭建过程中, 包括HydroFlux, StateFlux, UnitHydrograph, HydroModel, HydroBucket等类的实例化,这些类型的实例化方式不是像前两者一样使用函数的方式构建的, 而是通过符号编程的方式对计算公式进行表达, 在模型构建完成后是通过输入数据和参数进行模型计算,可以看出这种设计思路是将模型结构与公式同参数和数据完全解耦,有着极高的可复用性.","category":"page"},{"location":"implements/build_exphydro_model_en/#Build-an-ExpHydro-Model","page":"construct the ExpHydro Model","title":"Build an ExpHydro Model","text":"","category":"section"},{"location":"implements/build_exphydro_model_en/#Introduction-to-ExpHydro-Model","page":"construct the ExpHydro Model","title":"Introduction to ExpHydro Model","text":"","category":"section"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"This section demonstrates how to build a simple hydrological model - the ExpHydro model - using HydroModels.jl, serving as an introduction to conceptual model construction. The ExpHydro model consists of two computational modules: the Snowpack Bucket and the Soilwater Bucket. Their mathematical formulations are as follows:","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"beginaligned\n textSnowpack Bucket \n pet = 298 cdot lday cdot 24 cdot 0611 cdot fracexp(173 cdot temp)temp + 2373 cdot frac1temp + 2732  (1) \n snowfall = H(T_min - temp) cdot prcp  (2) \n rainfall = H(temp - T_min) cdot prcp  (3) \n melt = H(temp - T_max) cdot H(snowpack) cdot min(snowpack D_f cdot (temp - T_max))  (4) \n fracd(snowpack)dt = snowfall - melt  (5) \n\n textSoilwater Bucket \n evap = H(soilwater) cdot pet cdot min(10 fracsoilwaterS_max)  (6) \n baseflow = H(soilwater) cdot Q_max cdot exp(-f cdot max(00 S_max - soilwater))  (7) \n surfaceflow = max(00 soilwater - S_max)  (8) \n flow = baseflow + surfaceflow  (9) \n fracd(soilwater)dt = rainfall + melt - evap - flow  (10)\nendaligned","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"Where: H(x) represents the Heaviside step function, equals 1 when x  0, otherwise 0; T_min T_max D_f S_max Q_max f are model parameters;temp lday prcp are input variables;snowpack soilwater are state variables;Other variables are intermediate calculation variables","category":"page"},{"location":"implements/build_exphydro_model_en/#Complete-Model-Construction-Process","page":"construct the ExpHydro Model","title":"Complete Model Construction Process","text":"","category":"section"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"# import packages\nusing HydroModels\n\n# define variables and parameters\n@variables temp lday pet prcp \n@variables snowfall rainfall melt evap baseflow surfaceflow flow\n@variables snowpack soilwater\n@parameters Tmin Tmax Df Smax Qmax f\n\nstep_func(x) = (tanh(5.0 * x) + 1.0) * 0.5\n\n# define snowpack bucket\nfluxes_1 = [\n    HydroFlux([temp, lday] => [pet], exprs=[29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)]),\n    HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp]),\n    HydroFlux([snowpack, temp] => [melt], [Tmax, Df], exprs=[step_func(temp - Tmax) * step_func(snowpack) * min(snowpack, Df * (temp - Tmax))]),\n]\ndfluxes_1 = [StateFlux([snowfall] => [melt], snowpack),]\nsnowpack_bucket = HydroBucket(name=:surface, fluxes=fluxes_1, dfluxes=dfluxes_1)\n\n# define soilwater bucket\nfluxes_2 = [\n    HydroFlux([soilwater, pet] => [evap], [Smax], exprs=[step_func(soilwater) * pet * min(1.0, soilwater / Smax)]),\n    HydroFlux([soilwater] => [baseflow], [Smax, Qmax, f], exprs=[step_func(soilwater) * Qmax * exp(-f * (max(0.0, Smax - soilwater)))]),\n    HydroFlux([soilwater] => [surfaceflow], [Smax], exprs=[max(0.0, soilwater - Smax)]),\n    HydroFlux([baseflow, surfaceflow] => [flow], exprs=[baseflow + surfaceflow]),\n]\ndfluxes_2 = [StateFlux([rainfall, melt] => [evap, flow], soilwater)]\nsoilwater_bucket = HydroBucket(name=:soil, fluxes=fluxes_2, dfluxes=dfluxes_2)\n\n# define the Exp-Hydro model\nexphydro_model = HydroModel(name=:exphydro, components=[snowpack_bucket, soilwater_bucket])","category":"page"},{"location":"implements/build_exphydro_model_en/#Step-by-Step-Analysis","page":"construct the ExpHydro Model","title":"Step-by-Step Analysis","text":"","category":"section"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"Let's break down the model construction process into detailed steps.","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"First, we need to import the HydroModels.jl dependency:","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"using HydroModels","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"By importing the HydroModels module, we gain direct access to types defined in HydroFlux, StateFlux, HydroBucket, and HydroModel modules. Additionally, the package exports macros from ModelingToolkit.jl such as @variables and @parameters, which are used for defining and manipulating variables and parameters in hydrological models:","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"@variables temp lday prcp \n@variables snowfall rainfall melt evap baseflow surfaceflow flow pet\n@variables snowpack soilwater\n@parameters Tmin Tmax Df Smax Qmax f","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"In this code segment, we define all variables used in the ExpHydro model, including:","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"Input variables: temperature (temp), day length (lday), and precipitation (prcp)\nIntermediate calculation variables: pet, snowfall, rainfall, melt, evap, baseflow, surfaceflow, flow\nState variables: snowpack and soilwater\nModel parameters: Tmin, Tmax, Df, Smax, Qmax, and f","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"The definition of HydroFlux requires determining input/output variables and model parameters based on calculation formulas. For example, in the rain-snow partitioning formula, the input variables are prcp and temp, output variables are snowfall and rainfall, and the model parameter is Tmin. The formula translation to HydroFlux looks like this:","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"# define the smooth function\nstep_func(x) = (tanh(5.0 * x) + 1.0) * 0.5\n# define the rain-snow partitioning flux\nsplit_flux = HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp])","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"The definition of StateFlux is based on the balance equation of state variables. Generally, the balance equation equates the rate of change of the state variable to the difference between input and output fluxes. For example, the balance equation for snowpack is the difference between snowfall and melt. The formula translation to StateFlux looks like this:","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"snowpack_dflux = StateFlux([snowfall] => [melt], snowpack)","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"Next, we define the model calculation formulas using HydroFlux and StateFlux, and integrate them into HydroBucket to create the Snowpack Bucket and Soilwater Bucket components:","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"# define snowpack bucket\nfluxes_1 = [\n    HydroFlux([temp, lday] => [pet], exprs=[29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)]),\n    HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp]),\n    HydroFlux([snowpack, temp] => [melt], [Tmax, Df], exprs=[step_func(temp - Tmax) * step_func(snowpack) * min(snowpack, Df * (temp - Tmax))]),\n]\ndfluxes_1 = [StateFlux([snowfall] => [melt], snowpack),]\nsnowpack_bucket = HydroBucket(name=:surface, fluxes=fluxes_1, dfluxes=dfluxes_1)\n\n# define soilwater bucket\nfluxes_2 = [\n    HydroFlux([soilwater, pet] => [evap], [Smax], exprs=[step_func(soilwater) * pet * min(1.0, soilwater / Smax)]),\n    HydroFlux([soilwater] => [baseflow], [Smax, Qmax, f], exprs=[step_func(soilwater) * Qmax * exp(-f * (max(0.0, Smax - soilwater)))]),\n    HydroFlux([soilwater] => [surfaceflow], [Smax], exprs=[max(0.0, soilwater - Smax)]),\n    HydroFlux([baseflow, surfaceflow] => [flow], exprs=[baseflow + surfaceflow]),\n]\ndfluxes_2 = [StateFlux([rainfall, melt] => [evap, flow], soilwater)]\nsoilwater_bucket = HydroBucket(name=:soil, fluxes=fluxes_2, dfluxes=dfluxes_2)","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"The construction of HydroBucket consists of HydroFlux and StateFlux, where HydroFlux defines the model's calculation formulas, and StateFlux defines the balance equations for state variables.","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"Finally, we combine the HydroBucket components into a HydroModel to create the complete ExpHydro model:","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"# define the Exp-Hydro model\nexphydro_model = HydroModel(name=:exphydro, components=[snowpack_bucket, soilwater_bucket])","category":"page"},{"location":"implements/build_m50_model_zh/#Embedding-Neural-Networks-in-ExpHydro-Model:-Implementation-of-[M50](https://hess.copernicus.org/articles/26/5085/2022/)-Model","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"","category":"section"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"marv-in在论文中提出了M50和M100两个模型,代码储存于HydroNODE中,开创了神经网络嵌入水文模型的先河(重点在于实现神经网络替换了ExpHydro模型的计算公式,并参与到平衡方程的求解中),这个模型也是对该仓库的启蒙,我们发现当前模型编写仍存在一定难度,因此我们创建这个仓库的首要目的就是简化神经网络嵌入水文模型这个过程,下面我们将对比源代码与本仓库在M50和M100模型上的实现差异,为使用者展现出一种新的模型搭建方式.","category":"page"},{"location":"implements/build_m50_model_zh/#HydroNODE中M50的实现方法","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"HydroNODE中M50的实现方法","text":"","category":"section"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"首先我们展示了HydroNODE中M50和M100模型的实现:","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"# define the ODE problem\nfunction NeuralODE_M50_core!(dS,S,p,t)\n\n    Tmin, Tmax, Df = (p_bucket_precal...,)\n\n    Lday = itp_Lday(t)\n    P    = itp_P(t)\n    T    = itp_T(t)\n\n    g_ET = ann_ET([norm_S0(S[1]), norm_S1(S[2]), norm_T(T)],p[:p1]) #p[idcs_params_ann_ET])\n    g_Q = ann_Q([norm_S1(S[2]), norm_P(P)],p[:p2]) #p[idcs_params_ann_Q])\n\n    melting = M(S[1], T, Df, Tmax)\n    dS[1] = Ps(P, T, Tmin) - melting\n    dS[2] = Pr(P, T, Tmin) + melting - step_fct(S[2])*Lday*exp(g_ET[1])- step_fct(S[2])*exp(g_Q[1])\n\nend\n# build and solve ODE problem\nprob = ODEProblem(NeuralODE_M50_core!, S_init, Float64.((t_out[1], maximum(t_out))), p)\nsol = solve(prob, BS3(), dt=1.0, saveat=t_out, reltol=1e-3, abstol=1e-3, sensealg=BacksolveAdjoint(autojacvec=ZygoteVJP()))\n# calculate Qout\nP_interp = norm_P.(itp_P.(t_out))\nS1_ = norm_S1.(sol[2,:])\nQout_ =  exp.(ann_Q(permutedims([S1_ P_interp]),p[:p2])[1,:])","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"在HydroNODE的代码中可以看出,模型构建分为以下三个步骤:","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"ODE函数的定义\nODE问题的构建与求解\n以及根据求解的中间状态计算Qout","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"这个代码的构建风格遵循了最标准的DifferentialEquations.jl库的风格,然而这个代码中需要手动搭建模型的计算公式(M,Ps,Pr)并与状态方程表达式组合在一起(dS),模型的耦合性极高,同时,为获取Qout等中间计算通量,还需要额外调用对应的计算公式,代码编写的繁琐性相对较高.","category":"page"},{"location":"implements/build_m50_model_zh/#HydroModels.jl中M50的实现方法","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"HydroModels.jl中M50的实现方法","text":"","category":"section"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"首先需要定义M50模型中设计的参数和变量:","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"using HydroModels\n\n#! parameters in the Exp-Hydro model\n@parameters Tmin Tmax Df Smax f Qmax\n#! parameters in normalize flux\n@parameters snowpack_std snowpack_mean\n@parameters soilwater_std soilwater_mean\n@parameters prcp_std prcp_mean\n@parameters temp_std temp_mean\n\n#! hydrological flux in the Exp-Hydro model\n@variables prcp temp lday pet rainfall snowfall\n@variables snowpack soilwater lday pet\n@variables melt log_evap_div_lday log_flow flow\n@variables norm_snw norm_slw norm_temp norm_prcp\n\nstep_func(x) = (tanh(5.0 * x) + 1.0) * 0.5","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"相比较普通的概念式水文模型,M50模型使用神经网络模型替换了水文通量的计算公式(ET和Q),这个神经网络相比普通的计算公式有着明显的差异,因此在HydroModels.jl中采用了NeuralFlux来表示神经网络, 用于ET和Q预测的NeuralFlux如下表示:","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"# define the ET NN and Q NN\nep_nn = Lux.Chain(\n    Lux.Dense(3 => 16, tanh),\n    Lux.Dense(16 => 16, leakyrelu),\n    Lux.Dense(16 => 1, leakyrelu),\n    name=:epnn\n)\nep_nn_params = Vector(ComponentVector(first(Lux.setup(StableRNGs.LehmerRNG(1234), ep_nn))))\nq_nn = Lux.Chain(\n    Lux.Dense(2 => 16, tanh),\n    Lux.Dense(16 => 16, leakyrelu),\n    Lux.Dense(16 => 1, leakyrelu),\n    name=:qnn\n)\nq_nn_params = Vector(ComponentVector(first(Lux.setup(StableRNGs.LehmerRNG(1234), q_nn))))\n\n\nep_nn_flux = NeuralFlux([norm_snw, norm_slw, norm_temp] => [log_evap_div_lday], ep_nn)\nq_nn_flux = NeuralFlux([norm_slw, norm_prcp] => [log_flow], q_nn)","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"构建M50模型相对特殊的一点在于需要针对嵌入的神经网络使用NeuralFlux模型进行包装,为神经网络赋予输入输出的信息,并在构建过程中将神经网络转换为表达式.","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"然后我们可以构建M50模型的其余部分:","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"# define the snow pack reservoir\nsnow_fluxes = [\n    HydroFlux([temp, lday] => [pet], exprs=[29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)]),\n    HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp]),\n    HydroFlux([snowpack, temp] => [melt], [Tmax, Df], exprs=[step_func(temp - Tmax) * min(snowpack, Df * (temp - Tmax))]),\n]\nsnow_dfluxes = [StateFlux([snowfall] => [melt], snowpack)]\nsnow_ele = HydroBucket(name=:exphydro_snow, fluxes=snow_fluxes, dfluxes=snow_dfluxes)\n\n# define the soil water reservoir\nsoil_fluxes = [\n    #* normalize\n    HydroFlux([snowpack, soilwater, prcp, temp] => [norm_snw, norm_slw, norm_prcp, norm_temp],\n        [snowpack_mean, soilwater_mean, prcp_mean, temp_mean, snowpack_std, soilwater_std, prcp_std, temp_std],\n        exprs=[(var - mean) / std for (var, mean, std) in zip([snowpack, soilwater, prcp, temp],\n            [snowpack_mean, soilwater_mean, prcp_mean, temp_mean],\n            [snowpack_std, soilwater_std, prcp_std, temp_std]\n        )]),\n    ep_nn_flux,\n    q_nn_flux\n]\nstate_expr = rainfall + melt - step_func(soilwater) * lday * exp(log_evap_div_lday) - step_func(soilwater) * exp(log_flow)\nsoil_dfluxes = [StateFlux([soilwater, rainfall, melt, lday, log_evap_div_lday, log_flow], soilwater, expr=state_expr)]\nsoil_ele = HydroBucket(name=:m50_soil, fluxes=soil_fluxes, dfluxes=soil_dfluxes)\nconvert_flux = HydroFlux([log_flow] => [flow], exprs=[exp(log_flow)])\n# define the Exp-Hydro model\nm50_model = HydroModel(name=:m50, components=[snow_ele, soil_ele, convert_flux]);","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"上述代码中我们对M50模型进行了一个完整的表现,首先包括ExpHydro中Snowpack Bucket的实现,其次就是对于神经网络嵌入后Soilwater Bucket的实现. 在Soilwater Bucket模块实现中,可以通过定义的NeuralFlux(ep_nn_flux和q_nn_flux)来表达嵌入的神经网络,并与其他HydroFlux进行组合,结合StateFlux构建Soilwater Bucket.","category":"page"},{"location":"implements/build_exphydro_model_zh/#构建ExpHydro模型","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"","category":"section"},{"location":"implements/build_exphydro_model_zh/#ExpHydro模型介绍","page":"构建ExpHydro模型","title":"ExpHydro模型介绍","text":"","category":"section"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"本节将基于 HydroModels.jl 构建一个结构较为简单的水文模型-ExpHydro 模型,以此来开启概念式模型搭建的教程。 首先对 ExpHydro 模型进行介绍,该模型由 Snowpack Bucket 和 Soilwater Bucket 两个计算模块组成,其计算公式如下：","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"beginaligned\n textSnowpack Bucket \n pet = 298 cdot lday cdot 24 cdot 0611 cdot fracexp(173 cdot temp)temp + 2373 cdot frac1temp + 2732  (1) \n snowfall = H(T_min - temp) cdot prcp  (2) \n rainfall = H(temp - T_min) cdot prcp  (3) \n melt = H(temp - T_max) cdot H(snowpack) cdot min(snowpack D_f cdot (temp - T_max))  (4) \n fracd(snowpack)dt = snowfall - melt  (5) \n\n textSoilwater Bucket \n evap = H(soilwater) cdot pet cdot min(10 fracsoilwaterS_max)  (6) \n baseflow = H(soilwater) cdot Q_max cdot exp(-f cdot max(00 S_max - soilwater))  (7) \n surfaceflow = max(00 soilwater - S_max)  (8) \n flow = baseflow + surfaceflow  (9) \n fracd(soilwater)dt = rainfall + melt - evap - flow  (10)\nendaligned","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"其中:","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"H(x)\n表示Heaviside阶跃函数，当 x  0 时为1，否则为0\nT_min T_max D_f S_max Q_max f\n为模型参数\ntemp lday prcp\n为输入变量\nsnowpack soilwater\n为状态变量\n其余变量为中间计算变量","category":"page"},{"location":"implements/build_exphydro_model_zh/#完整的模型构建过程","page":"构建ExpHydro模型","title":"完整的模型构建过程","text":"","category":"section"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"# import packages\nusing HydroModels\n\n# define variables and parameters\n@variables temp lday pet prcp \n@variables snowfall rainfall melt evap baseflow surfaceflow flow\n@variables snowpack soilwater\n@parameters Tmin Tmax Df Smax Qmax f\n\n# define snowpack bucket\nfluxes_1 = [\n    HydroFlux([temp, lday] => [pet], exprs=[29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)]),\n    HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp]),\n    HydroFlux([snowpack, temp] => [melt], [Tmax, Df], exprs=[step_func(temp - Tmax) * step_func(snowpack) * min(snowpack, Df * (temp - Tmax))]),\n]\ndfluxes_1 = [StateFlux([snowfall] => [melt], snowpack),]\nsnowpack_bucket = HydroBucket(name=:surface, fluxes=fluxes_1, dfluxes=dfluxes_1)\n\n# define soilwater bucket\nfluxes_2 = [\n    HydroFlux([soilwater, pet] => [evap], [Smax], exprs=[step_func(soilwater) * pet * min(1.0, soilwater / Smax)]),\n    HydroFlux([soilwater] => [baseflow], [Smax, Qmax, f], exprs=[step_func(soilwater) * Qmax * exp(-f * (max(0.0, Smax - soilwater)))]),\n    HydroFlux([soilwater] => [surfaceflow], [Smax], exprs=[max(0.0, soilwater - Smax)]),\n    HydroFlux([baseflow, surfaceflow] => [flow], exprs=[baseflow + surfaceflow]),\n]\ndfluxes_2 = [StateFlux([rainfall, melt] => [evap, flow], soilwater)]\nsoilwater_bucket = HydroBucket(name=:soil, fluxes=fluxes_2, dfluxes=dfluxes_2)\n\n# define the Exp-Hydro model\nexphydro_model = HydroModel(name=:exphydro, components=[snowpack_bucket, soilwater_bucket])","category":"page"},{"location":"implements/build_exphydro_model_zh/#分段剖析","page":"构建ExpHydro模型","title":"分段剖析","text":"","category":"section"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"接下来我们将分块对模型构建过程进行介绍.","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"首先需要引入HydroModels.jl的依赖:","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"using HydroModels","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"通过导入HydroModels模块,可以直接访问HydroFlux,StateFlux,HydroBucket,HydroModel等模块定义的类型,同时还该包导出了ModelingToolkit.jl包中@variables,@parameters等宏,可以用于水文模型中变量和参数的定义和操作, 如下所示:","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"@variables temp lday prcp \n@variables snowfall rainfall melt evap baseflow surfaceflow flow pet\n@variables snowpack soilwater\n@parameters Tmin Tmax Df Smax Qmax f","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"在这段代码中,需要将ExpHydro模型中所有变量进行定义,包括输入变量温度(temp),日照时长(lday)和降水(prcp),同时给出了ExpHydro模型中所有变量的中间计算变量,如pet, snowfall, rainfall, melt, evap, baseflow, surfaceflow, flow等,以及ExpHydro模型的状态变量snowpack和soilwater,以及ExpHydro模型的参数Tmin, Tmax, Df, Smax, Qmax和f.","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"HydroFlux的定义需要根据计算公式确定模型的输入输出变量和模型参数,例如在模型的雨雪划分计算公式,该公式的输入变量为prcp和temp,输出变量为snowfall和rainfall,模型参数为Tmin, 公式转译为HydroFlux的结果如下所示:","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"# 定义平滑函数\nstep_func(x) = (tanh(5.0 * x) + 1.0) * 0.5\n# 定义雨雪划分函数\nsplit_flux = HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp])","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"StateFlux的定义是根据状态变量的平衡方程, 一般来说平衡方程是状态变量的变化率等于输入输出通量的差值得到,例如snowpack的平衡方程是snowfall和melt的差值, 公式转译为StateFlux的结果如下所示:","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"snowpack_dflux = StateFlux([snowfall] => [melt], snowpack)","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"接着根据模型计算公式通过HydroFlux和StateFlux进行定义, 并将其整合为HydroBucket,得到Snowpack Bucket和Soilwater Bucket如下所示:","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"# define snowpack bucket\nfluxes_1 = [\n    HydroFlux([temp, lday] => [pet], exprs=[29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)]),\n    HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp]),\n    HydroFlux([snowpack, temp] => [melt], [Tmax, Df], exprs=[step_func(temp - Tmax) * step_func(snowpack) * min(snowpack, Df * (temp - Tmax))]),\n]\ndfluxes_1 = [StateFlux([snowfall] => [melt], snowpack),]\nsnowpack_bucket = HydroBucket(name=:surface, fluxes=fluxes_1, dfluxes=dfluxes_1)\n\n# define soilwater bucket\nfluxes_2 = [\n    HydroFlux([soilwater, pet] => [evap], [Smax], exprs=[step_func(soilwater) * pet * min(1.0, soilwater / Smax)]),\n    HydroFlux([soilwater] => [baseflow], [Smax, Qmax, f], exprs=[step_func(soilwater) * Qmax * exp(-f * (max(0.0, Smax - soilwater)))]),\n    HydroFlux([soilwater] => [surfaceflow], [Smax], exprs=[max(0.0, soilwater - Smax)]),\n    HydroFlux([baseflow, surfaceflow] => [flow], exprs=[baseflow + surfaceflow]),\n]\ndfluxes_2 = [StateFlux([rainfall, melt] => [evap, flow], soilwater)]\nsoilwater_bucket = HydroBucket(name=:soil, fluxes=fluxes_2, dfluxes=dfluxes_2)","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"HydroBucket的构建由HydroFlux和StateFlux组成, 其中HydroFlux用于定义模型的计算公式,StateFlux用于定义状态变量的平衡方程.","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"最后将HydroBucket组合成HydroModel,作为components输入到模型中,得到ExpHydro模型如下所示:","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"# define the Exp-Hydro model\nexphydro_model = HydroModel(name=:exphydro, components=[snowpack_bucket, soilwater_bucket])","category":"page"},{"location":"implements/build_discharge_route_en/#Building-a-Discharge-Routing-Model","page":"construct the discharge route model","title":"Building a Discharge Routing Model","text":"","category":"section"},{"location":"implements/build_discharge_route_en/#Mathematical-Formulation","page":"construct the discharge route model","title":"Mathematical Formulation","text":"","category":"section"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"The discharge routing model is based on the following equations:","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"beginaligned\nfracdS_rfndt = Q_rfup - Q_rfn  (1) \nQ_rfn = fracS_rfntextLAG_rf + Q_rfn-1  (2) \nQ_rfup = sum_i in up(n) Q_rfi  (3) \nQ_rf = Q_rfn + (R_sw + R_gw) cdot A_gc  (4)\nendaligned","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"where n is the reach index, ranging from 1c_max; Delta S_rfn is the storage change in reach n; Q_rfn is the outflow from reach n; S_rfn is the storage in reach n; textLAG_rf is the routing lag parameter; Q_rfup is the inflow from upstream reaches; R_sw and R_gw are surface and groundwater runoff; A_gc is the grid cell area; c_max is the maximum number of reaches.","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"The equations describe: (1) storage change in the reach, (2) reach outflow calculation, (3) upstream inflow accumulation, and (4) final discharge calculation. This approach determines the inflow to each Hydrological Response Unit (HRU) based on its upstream inputs, which can be represented using two different routing functions. The outflow from the current HRU is calculated using the current reach storage S_rfn and combined with the HRU's R_sw and R_gw (after area conversion) to obtain the final discharge Q_rf.","category":"page"},{"location":"implements/build_discharge_route_en/#Implementation-in-HydroModels.jl","page":"construct the discharge route model","title":"Implementation in HydroModels.jl","text":"","category":"section"},{"location":"implements/build_discharge_route_en/#Modified-Calculation-Formula","page":"construct the discharge route model","title":"Modified Calculation Formula","text":"","category":"section"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"In the HydroModels.jl framework, this storage-based discharge calculation method is represented by the HydroRoute type, which solves the problem continuously through ODE equations. The implementation differs from the original formula in that it assumes no instantaneous changes when calculating Q_rfn, transforming equation (2) into:","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"beginaligned\nQ_rfn = S_rfn cdot frac1textLAG_rf + 1  (5)\nendaligned","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"The Q_rfn-1 term is removed because in continuous change, S_rfn is constantly evolving, making it unnecessary to consider Q_rfn-1 in calculating Q_rfn. Additionally, there are dimensional differences between S_rfn and Q_rfn, and including Q_rfn would add an instantaneous state variable, which is unsuitable as a state variable. In HydroRoute construction, the primary focus is expressing the outflow calculation formula. Like HydroBucket, HydroRoute accepts HydroFlux to represent the Q_rfn calculation formula:","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"using HydroModels\n# Define parameters and variables\n@variables q q_routed s_river\n@parameters lag\n# Define routing flux\nrflux = HydroFlux([q, s_river] => [q_routed], [lag], exprs=[s_river / (1 + lag) + q])","category":"page"},{"location":"implements/build_discharge_route_en/#Flow-Accumulation-Functions","page":"construct the discharge route model","title":"Flow Accumulation Functions","text":"","category":"section"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"The method of obtaining upstream flow inputs is another crucial component of the routing model. Flow accumulation functions are typically used to calculate the upstream inflow for each HRU. This accumulation can be represented using either Grid-Based or Vector-Based approaches, corresponding to two types of HydroRoute construction in HydroModels.jl: GridRoute and VectorRoute.","category":"page"},{"location":"implements/build_discharge_route_en/#Vector-Based-Routing-Model","page":"construct the discharge route model","title":"Vector-Based Routing Model","text":"","category":"section"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"The Vector-Based routing model is based on watershed subdivision and topological relationships, using an adjacency matrix for flow accumulation:","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"using Graphs\n# Build river network topology\nnetwork = DiGraph(9)\nadd_edge!(network, 1, 2)\nadd_edge!(network, 2, 5)\nadd_edge!(network, 3, 5)\nadd_edge!(network, 4, 5)\nadd_edge!(network, 5, 8)\nadd_edge!(network, 6, 9)\nadd_edge!(network, 7, 8)\nadd_edge!(network, 8, 9)\nvroute = HydroModels.VectorRoute(rfunc=rflux, rstate=s_river, network=network)","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"The code uses Graphs.jl's DiGraph data structure to represent watershed topology, which, along with the constructed rflux and s_river, completes the Vector-Based routing model construction.","category":"page"},{"location":"implements/build_discharge_route_en/#Grid-Based-Routing-Model","page":"construct the discharge route model","title":"Grid-Based Routing Model","text":"","category":"section"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"The Grid-Based routing model represents HRU connectivity using a D8 flow direction matrix. The construction is based on the D8 matrix and corresponding HRU coordinates:","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"# Build river network topology\nflwdir = [1 4 8; 1 4 4; 1 1 2]\npositions = [[1, 1], [1, 2], [1, 3], [2, 1], [2, 2], [2, 3], [3, 1], [3, 2], [3, 3]]\ngroute = HydroModels.GridRoute(rfunc=rflux, rstate=s_river, flwdir=flwdir, positions=positions)","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"The code uses matrix data to represent flow direction and HRU coordinates, which, combined with the constructed rflux and s_river, completes the Grid-Based routing model construction.","category":"page"},{"location":"tutorials/run_any_component_directly/#Run-Any-Component-Directly","page":"Run Any Component Directly","title":"Run Any Component Directly","text":"","category":"section"},{"location":"tutorials/run_any_component_directly/","page":"Run Any Component Directly","title":"Run Any Component Directly","text":"在HydroModels.jl中,任何组件(Flux,Bucket,Route,Model)都是可以直接通过数据和参数来进行计算的。这些组件的结构和使用方式如下:","category":"page"},{"location":"extent/flexible_and_efficent/#讨论灵活构建所牺牲的计算效率","page":"讨论灵活构建所牺牲的计算效率","title":"讨论灵活构建所牺牲的计算效率","text":"","category":"section"},{"location":"tutorials/run_a_bucket/#HydroModels-Bucket-Model-Implementation-Example","page":"HydroModels Bucket Model Implementation Example","title":"HydroModels Bucket Model Implementation Example","text":"","category":"section"},{"location":"tutorials/run_a_bucket/#Overview","page":"HydroModels Bucket Model Implementation Example","title":"Overview","text":"","category":"section"},{"location":"tutorials/run_a_bucket/","page":"HydroModels Bucket Model Implementation Example","title":"HydroModels Bucket Model Implementation Example","text":"This document demonstrates the implementation and usage of a hydrological bucket model using the HydroModels framework. The code showcases both single-node and multi-node simulations using the ExpHydro model structure.","category":"page"},{"location":"tutorials/run_a_bucket/#Dependencies","page":"HydroModels Bucket Model Implementation Example","title":"Dependencies","text":"","category":"section"},{"location":"tutorials/run_a_bucket/","page":"HydroModels Bucket Model Implementation Example","title":"HydroModels Bucket Model Implementation Example","text":"using CSV\nusing DataFrames\nusing ComponentArrays\nusing BenchmarkTools\nusing HydroModels\nusing ModelingToolkit","category":"page"},{"location":"tutorials/run_a_bucket/#Model-Configuration","page":"HydroModels Bucket Model Implementation Example","title":"Model Configuration","text":"","category":"section"},{"location":"tutorials/run_a_bucket/#Parameter-Setup","page":"HydroModels Bucket Model Implementation Example","title":"Parameter Setup","text":"","category":"section"},{"location":"tutorials/run_a_bucket/","page":"HydroModels Bucket Model Implementation Example","title":"HydroModels Bucket Model Implementation Example","text":"The model uses the following parameters for the hydrological simulation:","category":"page"},{"location":"tutorials/run_a_bucket/","page":"HydroModels Bucket Model Implementation Example","title":"HydroModels Bucket Model Implementation Example","text":"f: 0.01674478 (Infiltration parameter)\nSmax: 1709.461015 (Maximum soil water storage)\nQmax: 18.46996175 (Maximum discharge)\nDf: 2.674548848 (Degree-day factor)\nTmax: 0.175739196 (Maximum temperature threshold)\nTmin: -2.092959084 (Minimum temperature threshold)","category":"page"},{"location":"tutorials/run_a_bucket/#Initial-States","page":"HydroModels Bucket Model Implementation Example","title":"Initial States","text":"","category":"section"},{"location":"tutorials/run_a_bucket/","page":"HydroModels Bucket Model Implementation Example","title":"HydroModels Bucket Model Implementation Example","text":"Initial conditions for the model:","category":"page"},{"location":"tutorials/run_a_bucket/","page":"HydroModels Bucket Model Implementation Example","title":"HydroModels Bucket Model Implementation Example","text":"snowpack: 0.0\nsoilwater: 1303.004248","category":"page"},{"location":"tutorials/run_a_bucket/#Data-Input","page":"HydroModels Bucket Model Implementation Example","title":"Data Input","text":"","category":"section"},{"location":"tutorials/run_a_bucket/","page":"HydroModels Bucket Model Implementation Example","title":"HydroModels Bucket Model Implementation Example","text":"The model uses time series data from a CSV file located at \"data/exphydro/01013500.csv\" containing:","category":"page"},{"location":"tutorials/run_a_bucket/","page":"HydroModels Bucket Model Implementation Example","title":"HydroModels Bucket Model Implementation Example","text":"Day length (dayl)\nMean temperature (tmean)\nPrecipitation (prcp)","category":"page"},{"location":"tutorials/run_a_bucket/#Implementation-Examples","page":"HydroModels Bucket Model Implementation Example","title":"Implementation Examples","text":"","category":"section"},{"location":"tutorials/run_a_bucket/#1.-Single-Node-Simulation","page":"HydroModels Bucket Model Implementation Example","title":"1. Single Node Simulation","text":"","category":"section"},{"location":"tutorials/run_a_bucket/","page":"HydroModels Bucket Model Implementation Example","title":"HydroModels Bucket Model Implementation Example","text":"# Setup input data\ninput = (lday=df[ts, \"dayl(day)\"], temp=df[ts, \"tmean(C)\"], prcp=df[ts, \"prcp(mm/day)\"])\nsolver = HydroModels.ManualSolver{true}()\nconfig = (solver=solver,)\n\n# Convert input to required format\ninput_arr = Matrix(reduce(hcat, collect(input[ele.meta.inputs]))')\n\n# Run simulation\nresults = ele(input_arr, pas, config=config, convert_to_ntp=true)","category":"page"},{"location":"tutorials/run_a_bucket/#2.-Multi-Node-Simulation","page":"HydroModels Bucket Model Implementation Example","title":"2. Multi-Node Simulation","text":"","category":"section"},{"location":"tutorials/run_a_bucket/","page":"HydroModels Bucket Model Implementation Example","title":"HydroModels Bucket Model Implementation Example","text":"# Setup for multiple nodes\nnode_num = 10\nnode_names = [Symbol(:node, i) for i in 1:node_num]\n\n# Create parameter and state vectors for all nodes\nnode_params = ComponentVector(NamedTuple{Tuple(node_names)}(repeat([params], length(node_names))))\nnode_initstates = ComponentVector(NamedTuple{Tuple(node_names)}(repeat([init_states], length(node_names))))\nnode_pas = ComponentVector(params=node_params, initstates=node_initstates)\n\n# Prepare input data for multiple nodes\ninput_arr = reduce(hcat, collect(input[HydroModels.get_input_names(ele)]))\nnode_input = reduce((m1, m2) -> cat(m1, m2, dims=3), repeat([input_arr], length(node_names)))\nnode_input = permutedims(node_input, (2, 3, 1))\n\n# Run simulation with multiple nodes\nrun_kwgs = (ptypes=node_names, timeidx=ts)\nresult = ele(node_input, node_pas, kwargs=run_kwgs)","category":"page"},{"location":"tutorials/run_a_bucket/#Model-Structure","page":"HydroModels Bucket Model Implementation Example","title":"Model Structure","text":"","category":"section"},{"location":"tutorials/run_a_bucket/","page":"HydroModels Bucket Model Implementation Example","title":"HydroModels Bucket Model Implementation Example","text":"The model uses a bucket structure defined in exphydro.jl with two main components:","category":"page"},{"location":"tutorials/run_a_bucket/","page":"HydroModels Bucket Model Implementation Example","title":"HydroModels Bucket Model Implementation Example","text":"Surface water component (bucket_1):\nHandles precipitation partitioning (rainfall/snowfall)\nComputes potential evapotranspiration\nManages snowmelt processes\nSoil water component:\nManages soil water storage\nComputes actual evaporation\nGenerates baseflow and surface flow","category":"page"},{"location":"tutorials/run_a_bucket/#Usage-Notes","page":"HydroModels Bucket Model Implementation Example","title":"Usage Notes","text":"","category":"section"},{"location":"tutorials/run_a_bucket/","page":"HydroModels Bucket Model Implementation Example","title":"HydroModels Bucket Model Implementation Example","text":"The code demonstrates flexibility in handling both single-node and multi-node simulations\nInput data should be properly formatted with required columns (dayl, tmean, prcp)\nParameters and initial states can be adjusted based on specific catchment characteristics\nThe model uses a manual solver for time-stepping","category":"page"},{"location":"tutorials/run_a_bucket/#Time-Series-Processing","page":"HydroModels Bucket Model Implementation Example","title":"Time Series Processing","text":"","category":"section"},{"location":"tutorials/run_a_bucket/","page":"HydroModels Bucket Model Implementation Example","title":"HydroModels Bucket Model Implementation Example","text":"The example processes 10,000 time steps (ts = collect(1:10000)) and can be adjusted based on data availability and simulation requirements.","category":"page"},{"location":"implements/build_discharge_route_zh/#构建河道汇流模型","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"","category":"section"},{"location":"implements/build_discharge_route_zh/#[discharge-route-model](https://gmd.copernicus.org/articles/14/7795/2021/)汇流模型介绍","page":"构建河道汇流模型","title":"discharge route model汇流模型介绍","text":"","category":"section"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"河道汇流模型是描述水流在河道中运动过程的数学模型，主要用于计算河道中的流量变化。下面给出了一个简单的河道汇流模型的数学表达式:","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"beginaligned\nDelta S_rfn = Q_rfn-1 - Q_rfn  (1) \nQ_rfn = (S_rfn + Q_rfn-1) cdot frac1textLAG_rf + 1  (2) \nQ_rf0 = sum Q_rfup  (3) \nQ_rf = Q_rfc_max + (R_sw + R_gw) cdot 0001 cdot A_gc  (4)\nendaligned","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"其中,n表示河段编号，取值范围为1c_max;Delta S_rfn表示第 n 段河道的蓄水量变化;Q_rfn表示第 n 段河道的出流量;S_rfn表示第 n 段河道的蓄水量;textLAG_rf 表示河道汇流滞时参数;Q_rfup表示上游河道的入流量;R_sw和R_gw分别表示地表径流和地下径流;A_gc表示栅格面积;c_max表示河道最大分段数.","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"公式(1)描述了河道蓄水量的变化，公式(2)表示河道出流量的计算，公式(3)给出了河道入流量的计算方法，公式(4)则是最终河道出流量的计算公式。 这种构建方式是根据每个 hydrological response unit(HRU)的上游输入确定当前的 HRU 入流量,这个确定方式可以由两种路由函数来表示. 当前 HRU 的出流量则是以当前的河道蓄水量S_rfn计算得到,并于 HRU 的 R{sw}和 R{gw}进行相加(经面积转换)得到最终的出流量Q_rf.","category":"page"},{"location":"implements/build_discharge_route_zh/#HydroModels.jl-框架下的河道汇流模型构建","page":"构建河道汇流模型","title":"HydroModels.jl 框架下的河道汇流模型构建","text":"","category":"section"},{"location":"implements/build_discharge_route_zh/#计算公式的改造","page":"构建河道汇流模型","title":"计算公式的改造","text":"","category":"section"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"HydroModels.jl 框架中为这种基于河道蓄水状态计算时段出流量的方法以 HydroRoute 类型进行表示,通过构建 ODE 方程的方式对这个问题进行连续性求解.与原公式实现有所不同的是,,并认为在计算Q_rfn时不存在瞬时变化,所以将公式(2)转换为如下式子:","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"beginaligned\nQ_rfn = S_rfn cdot frac1textLAG_rf + 1  (5)\nendaligned","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"式中,去掉了Q_rfn-1项.因为认为,在持续性变化中,S_rfn是一直处于变化状态的,所以在计算Q_rfn时不需要考虑Q_rfn-1的变化.此外于S_rfn与Q_rfn的量纲存在差异,同时如果将式中如果考虑Q_rfn会额外增加一个状态变量,这个变量是一个瞬时值,也不适合作为状态变量来使用. 在 HydroRoute 构造中,其首要的就是针对出流计算公式进行表达,与 HydroBucket 一样,HydroRoute 可以接受 HydroFlux 以此表示Q_rfn的计算公式,如下所示:","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"# 定义涉及的参数和变量\n@variables q q_routed s_river\n@parameters lag\n# 定义\nrflux = HydroFlux([q, s_river] => [q_routed], [lag], exprs=[s_river / (1 + lag) + q])","category":"page"},{"location":"implements/build_discharge_route_zh/#流量累积函数表示","page":"构建河道汇流模型","title":"流量累积函数表示","text":"","category":"section"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"获取 HRU 上游流量输入的方式是构成汇流模型的另一个部分,通常可以设置 Aggregation 函数来获取每个 HRU 的上游入流流量. 这个 Aggregation 函数可以由 Grid-Based 和 Vector-Based 两种方式来表示. 在 HydroModels.jl 框架中分别对应了两种 HydroRoute 的构造方式: GridRoute 和 VectorRoute.","category":"page"},{"location":"implements/build_discharge_route_zh/#表示-Vector-Based-的河道汇流模型","page":"构建河道汇流模型","title":"表示 Vector-Based 的河道汇流模型","text":"","category":"section"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"Vector-Based 的河道汇流模型是以流域子流域划分结果及其连接的拓扑关系为基础,通过构建 adjacency 矩阵得到流量累积函数:","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"# 构建河网拓扑结构\nnetwork = DiGraph(9)\nadd_edge!(network, 1, 2)\nadd_edge!(network, 2, 5)\nadd_edge!(network, 3, 5)\nadd_edge!(network, 4, 5)\nadd_edge!(network, 5, 8)\nadd_edge!(network, 6, 9)\nadd_edge!(network, 7, 8)\nadd_edge!(network, 8, 9)\nvroute = HydroModels.VectorRoute(rfunc=rflux, rstate=s_river, network=network)","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"代码中是采用 Graphs.jl 的 DiGraph 数据结构来表示流域拓扑,作为模型的输入参数,连同构建的 rflux 和 s_river,一同完成 Vector-Based 的河道汇流模型的构造.","category":"page"},{"location":"implements/build_discharge_route_zh/#表示-Grid-Based-的河道汇流模型","page":"构建河道汇流模型","title":"表示 Grid-Based 的河道汇流模型","text":"","category":"section"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"Grid-Based 的河道汇流模型是 HRU 之间的连同关系所表示的, 同常是使用 d8 流向矩阵来表示其连同关系,以此 Grid-Based 的河道汇流模型的构造便是根据 d8 流向矩阵和对应的 HRU 坐标来进行构造的:","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"# 构建河网拓扑结构\nflwdir = [1 4 8; 1 4 4; 1 1 2]\npositions = [[1, 1], [1, 2], [1, 3], [2, 1], [2, 2], [2, 3], [3, 1], [3, 2], [3, 3]]\ngroute = HydroModels.GridRoute(rfunc=rflux, rstate=s_river, flwdir=flwdir, positions=positions)","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"代码中是采用矩阵数据表示流向矩阵和HRU 坐标,作为模型的输入参数,连同构建的 rflux 和 s_river,一同完成 Grid-Based 的河道汇流模型的构造.","category":"page"},{"location":"extent/share_parameters/#Share-parameters-in-multiple-HRUs","page":"Share parameters in multiple HRUs","title":"Share parameters in multiple HRUs","text":"","category":"section"},{"location":"extent/why_not_MTK/#HydroModels.jl与ModelingToolkit.jl","page":"HydroModels.jl与ModelingToolkit.jl","title":"HydroModels.jl与ModelingToolkit.jl","text":"","category":"section"},{"location":"extent/why_not_MTK/#为什么不直接使用[ModelingToolkit.jl](https://github.com/SciML/ModelingToolkit.jl)","page":"HydroModels.jl与ModelingToolkit.jl","title":"为什么不直接使用ModelingToolkit.jl","text":"","category":"section"},{"location":"extent/why_not_MTK/","page":"HydroModels.jl与ModelingToolkit.jl","title":"HydroModels.jl与ModelingToolkit.jl","text":"HydroModels.jl的设计理念事实上是与ModelingToolkit.jl完全一致的,两者都是使用Symbolics.jl进行符号计算的框架,ModelingToolkit.jl是一个更通用符号系统,支持多种问题的构建,同时针对特定领域ModelingToolkitStandardLibrary.jl提供了基础组件的支持. 但是我之前在ModelingToolkit.jl的使用中存在一些问题:","category":"page"},{"location":"extent/why_not_MTK/","page":"HydroModels.jl与ModelingToolkit.jl","title":"HydroModels.jl与ModelingToolkit.jl","text":"尽管ModelingToolkit.jl同样能够根据符号编程表达水文模型的常微分方程,但对水文模型中单位线计算,汇流过程计算等计算过程的支持却并不是特别理想\n在同一种模块中,比如蒸发计算公式和土壤计算模块,不同区域所需要构建的模块会因为公式的不同存在差异,需要分别构建计算公式支撑模型模型构建\n水文模型通常包括多个常微分方程,使用一个ODESystem构建会相对混乱,使用多个ODESystem会相对复杂\n同时对于多节点输入,空间汇流过程计算,ODESystem或无法直接支持.\n对于神经网络模型的嵌入,尽管存在ModelingToolkitNeuralNets.jl,然而嵌入性却没有想象的那么简单\n基于ModelingToolkit.jl对于自动微分的支持,尤其是Zygote.jl我在使用时也存在问题.","category":"page"},{"location":"extent/why_not_MTK/","page":"HydroModels.jl与ModelingToolkit.jl","title":"HydroModels.jl与ModelingToolkit.jl","text":"因此我决定自己构建一个模型库,参考了符号编程的模型构建方式,使其更能够支撑水文模型的一些建模需求.","category":"page"},{"location":"extent/why_not_MTK/#未来的工作","page":"HydroModels.jl与ModelingToolkit.jl","title":"未来的工作","text":"","category":"section"},{"location":"extent/why_not_MTK/","page":"HydroModels.jl与ModelingToolkit.jl","title":"HydroModels.jl与ModelingToolkit.jl","text":"不可否认ModelingToolkit.jl是一个非常好的框架,在满足了水文模型的需求之后,我会尽量将HydroModels.jl中的模块能够成为ModelingToolkitStandardLibrary.jl中相似的模块,并继承ModelingToolkit.jl提供的AbstractSystem类的支持,提供一致的功能支持,从而兼容更多SciML生态的计算功能.","category":"page"},{"location":"extent/framework_comparision_en/#Comparing-Programming-Styles-for-Custom-Models-in-superflexpy,-MARRMoT,-and-HydroModels.jl","page":"Framework Comparision","title":"Comparing Programming Styles for Custom Models in superflexpy, MARRMoT, and HydroModels.jl","text":"","category":"section"},{"location":"extent/framework_comparision_en/","page":"Framework Comparision","title":"Framework Comparision","text":"This content corresponds to Section 4.1 of the paper, where we discuss the differences in programming styles for custom model implementation across these three software libraries. Using the GR4J model implementation as an example, we compare the programming styles for customizing model computation formulas.","category":"page"},{"location":"extent/framework_comparision_en/#[Superflexpy](https://github.com/dalmo1991/superflexPy/tree/master)","page":"Framework Comparision","title":"Superflexpy","text":"","category":"section"},{"location":"extent/framework_comparision_en/","page":"Framework Comparision","title":"Framework Comparision","text":"Superflexpy is a Python implementation based on the SUPERFLEX concept. For implementing hydrological model computations, this framework typically uses Python syntax to express model calculation formulas, as shown below.","category":"page"},{"location":"extent/framework_comparision_en/","page":"Framework Comparision","title":"Framework Comparision","text":"@staticmethod\ndef _flux_function_python(S, S0, ind, P, x1, alpha, beta, ni, PET, dt):\n    if ind is None:\n        return (\n            [\n                P * (1 - (S / x1) ** alpha), # Ps\n                -PET * (2 * (S / x1) - (S / x1) ** alpha), # Evaporation\n                -((x1 ** (1 - beta)) / ((beta - 1) * dt)) * (ni ** (beta - 1)) * (S**beta), # Perc\n            ],\n            0.0,\n            S0 + P * (1 - (S / x1) ** alpha) * dt,\n        )\n    else:\n        return (\n            [\n                P[ind] * (1 - (S / x1[ind]) ** alpha[ind]), # Ps\n                -PET[ind] * (2 * (S / x1[ind]) - (S / x1[ind]) ** alpha[ind]), # Evaporation\n                -((x1[ind] ** (1 - beta[ind])) / ((beta[ind] - 1) * dt[ind]))\n                * (ni[ind] ** (beta[ind] - 1))\n                * (S ** beta[ind]), # Perc\n            ],\n            0.0,\n            S0 + P[ind] * (1 - (S / x1[ind]) ** alpha[ind]) * dt[ind],\n            [\n                -(P[ind] * alpha[ind] / x1[ind]) * ((S / x1[ind]) ** (alpha[ind] - 1)),\n                -(PET[ind] / x1[ind]) * (2 - alpha[ind] * ((S / x1[ind]) ** (alpha[ind] - 1))),\n                -beta[ind]\n                * ((x1[ind] ** (1 - beta[ind])) / ((beta[ind] - 1) * dt[ind]))\n                * (ni[ind] ** (beta[ind] - 1))\n                * (S ** (beta[ind] - 1)),\n            ],\n        )\n\n@staticmethod\n@nb.jit(\n    \"Tuple((UniTuple(f8, 3), f8, f8, UniTuple(f8, 3)))\"\n    \"(optional(f8), f8, i4, f8[:], f8[:], f8[:], f8[:], f8[:], f8[:], f8[:])\",\n    nopython=True,\n)\ndef _flux_function_numba(S, S0, ind, P, x1, alpha, beta, ni, PET, dt):\n    return (\n        (\n            P[ind] * (1 - (S / x1[ind]) ** alpha[ind]),  # Ps\n            -PET[ind] * (2 * (S / x1[ind]) - (S / x1[ind]) ** alpha[ind]),  # Evaporation\n            -((x1[ind] ** (1 - beta[ind])) / ((beta[ind] - 1) * dt[ind]))\n            * (ni[ind] ** (beta[ind] - 1))\n            * (S ** beta[ind]),  # Perc\n        ),\n        0.0,\n        S0 + P[ind] * (1 - (S / x1[ind]) ** alpha[ind]) * dt[ind],\n        (\n            -(P[ind] * alpha[ind] / x1[ind]) * ((S / x1[ind]) ** (alpha[ind] - 1)),\n            -(PET[ind] / x1[ind]) * (2 - alpha[ind] * ((S / x1[ind]) ** (alpha[ind] - 1))),\n            -beta[ind]\n            * ((x1[ind] ** (1 - beta[ind])) / ((beta[ind] - 1) * dt[ind]))\n            * (ni[ind] ** (beta[ind] - 1))\n            * (S ** (beta[ind] - 1)),\n        ),\n    )","category":"page"},{"location":"extent/framework_comparision_en/","page":"Framework Comparision","title":"Framework Comparision","text":"As shown, when implementing the GR4J production module calculations origin code, the superflexpy framework requires separate construction of numpy and numba computation code. The function must specify hydrological fluxes Ps, Evaporation, Perc, and state variable balance equations. This approach couples multiple computational process implementations in a single code block, resulting in reduced code reusability (only reusable at the module level) and increased code volume and redundancy.","category":"page"},{"location":"extent/framework_comparision_en/#[MARRMoT](https://github.com/wknoben/MARRMoT)","page":"Framework Comparision","title":"MARRMoT","text":"","category":"section"},{"location":"extent/framework_comparision_en/","page":"Framework Comparision","title":"Framework Comparision","text":"MARRMoT is a hydrological modeling framework developed in MATLAB. This framework constructs model types separately based on different hydrological models, storing the calculation formulas and state change equations involved. The simplified implementation code for the GR4J model in this framework is shown below.","category":"page"},{"location":"extent/framework_comparision_en/","page":"Framework Comparision","title":"Framework Comparision","text":"function [dS, fluxes] = model_fun(obj, S)\n    % definitions\n    ...\n    % fluxes functions\n    flux_pn   = max(P-Ep,0);\n    flux_en   = max(Ep-P,0);\n    flux_ef   = P - flux_pn;\n    flux_ps   = saturation_4(S1,x1,flux_pn);\n    flux_es   = evap_11(S1,x1,flux_en);\n    flux_perc = percolation_3(S1,x1);\n    flux_q9   = route(.9.*(flux_pn - flux_ps + flux_perc), uh_q9);\n    flux_q1   = route(.1.*(flux_pn - flux_ps + flux_perc), uh_q1);\n    flux_fr   = recharge_2(3.5,S2,x3,x2);\n    flux_fq   = flux_fr;\n    flux_qr   = baseflow_3(S2,x3);\n    flux_qt   = flux_qr + max(flux_q1 + flux_fq,0);\n    % this flux is not included in original MARRMoT,\n    % but it is useful to calculate the water balance\n    flux_ex = flux_fr + max(flux_q1 + flux_fq,0) - flux_q1;      \n    % stores ODEs\n    dS1 = flux_ps - flux_es - flux_perc;\n    dS2 = flux_q9 + flux_fr - flux_qr;\n    % outputs\n    dS = [dS1 dS2];\n    fluxes = [flux_pn,   flux_en, flux_ef, flux_ps, flux_es,...\n                flux_perc, flux_q9, flux_q1, flux_fr, flux_fq,...\n                flux_qr,   flux_qt, flux_ex];\nend","category":"page"},{"location":"extent/framework_comparision_en/","page":"Framework Comparision","title":"Framework Comparision","text":"As evident, the MARRMoT framework expresses each Flux calculation formula through functions, allowing users to directly call functions for calculations (according to provided documentation). This approach significantly simplifies code writing requirements compared to superflexpy. However, MARRMoT has poor support for module reusability and cannot be reused like superflexpy. Additionally, combining variable assignments, flux calculations, and state change equations in one function results in poor decoupling of computational content.","category":"page"},{"location":"extent/framework_comparision_en/#HydroModels.jl","page":"Framework Comparision","title":"HydroModels.jl","text":"","category":"section"},{"location":"extent/framework_comparision_en/","page":"Framework Comparision","title":"Framework Comparision","text":"#* define the production store\nprod_funcs = [\n    HydroFlux([prcp, ep] => [pn, en], exprs=[prcp - min(prcp, ep), ep - min(prcp, ep)]),\n    HydroFlux([pn, soilwater] => [ps], [x1], exprs=[max(0.0, pn * (1 - (soilwater / x1)^2))]),\n    HydroFlux([en, soilwater] => [es], [x1], exprs=[en * (2 * soilwater / x1 - (soilwater / x1)^2)]),\n    HydroFlux([soilwater] => [perc], [x1], exprs=[((x1)^(-4)) / 4 * ((4 / 9)^(4)) * (soilwater^5)]),\n    HydroFlux([pn, ps, perc] => [pr], exprs=[pn - ps + perc]),\n    HydroFlux([pr] => [slowflow, fastflow], exprs=[0.9 * pr, 0.1 * pr]),\n]\nprod_dfuncs = [StateFlux([ps] => [es, perc], soilwater)]\nprod_ele = HydroBucket(name=:gr4j_prod, funcs=prod_funcs, dfuncs=prod_dfuncs)\n\n#* uh function\nuh_flux_1 = HydroModels.UnitHydrograph([slowflow] => [slowflow_routed], x4, uhfunc=HydroModels.UHFunction(:UH_1_HALF), solvetype=:SPARSE)\nuh_flux_2 = HydroModels.UnitHydrograph([fastflow] => [fastflow_routed], x4, uhfunc=HydroModels.UHFunction(:UH_2_FULL), solvetype=:SPARSE)\n\n#* define the routing store\nrst_funcs = [\n    HydroFlux([routingstore] => [exch], [x2, x3], exprs=[x2 * abs(routingstore / x3)^3.5]),\n    HydroFlux([routingstore, slowflow, exch] => [routedflow], [x3], exprs=[x3^(-4) / 4 * (routingstore + slowflow + exch)^5]),\n    HydroFlux([routedflow, fastflow_routed, exch] => [flow], exprs=[routedflow + max(fastflow_routed + exch, 0.0)]),\n]\nrst_dfuncs = [StateFlux([exch, slowflow] => [routedflow], routingstore)]\nrst_ele = HydroBucket(name=:gr4j_rst, funcs=rst_funcs, dfuncs=rst_dfuncs)\n\ngr4j_model = HydroModel(name=:gr4j, components=[prod_ele, uh_flux_1, uh_flux_2, rst_ele])","category":"page"},{"location":"extent/framework_comparision_en/","page":"Framework Comparision","title":"Framework Comparision","text":"Returning to the GR4J model implementation in HydroModels.jl framework, we sequentially define the production store, unit hydrograph, and routing store. In this process, the model can achieve reusability while maintaining variable correspondence. The construction process includes instantiation of classes such as HydroFlux, StateFlux, UnitHydrograph, HydroModel, and HydroBucket. Unlike the previous two frameworks that use functional construction, these class instantiations express calculation formulas through symbolic programming. After model construction, calculations are performed through input data and parameters, demonstrating a design philosophy that completely decouples model structure and formulas from parameters and data, achieving high reusability.","category":"page"},{"location":"#HydroModels.jl","page":"Home","title":"HydroModels.jl","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HydroModels.jl is a modern hydrological modeling framework that extends and enhances SUPERFLEX's design philosophy. Built on Julia language and the SciML (Scientific Machine Learning) ecosystem, it combines flexible model construction with computational efficiency, particularly supporting deep learning integration in hydrological modeling.","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Flexible Model Construction: Supports development of lumped, semi-distributed, and distributed hydrological models\nDeep Learning Integration: Enables neural network integration for enhanced flux calculations and dynamic parameter estimation\nComputational Efficiency: Leverages Julia's high-performance capabilities and the SciML ecosystem\nGradient-Based Optimization: Supports advanced parameter optimization techniques\nComprehensive Framework: Provides tools for both traditional hydrological modeling and modern machine learning approaches","category":"page"},{"location":"#Framework-Capabilities","page":"Home","title":"Framework Capabilities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HydroModels.jl offers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Easy implementation and customization of hydrological models\nIntegration with Julia's scientific computing ecosystem\nSupport for various modeling approaches:\nTraditional conceptual models\nNeural network enhanced models\nDistributed hydrological systems","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"HydroModels\")","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HydroModels.jl is an open-source project available on Github. We welcome contributions from the community to help advance deep learning applications in hydrology.","category":"page"}]
}
