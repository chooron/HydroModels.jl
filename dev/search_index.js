var documenterSearchIndex = {"docs":
[{"location":"concepts_en/#HydroModels.jl-Concepts","page":"Basic Concepts","title":"HydroModels.jl Concepts","text":"","category":"section"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"HydroModels.jl implements a modular and extensible architecture, designed to support diverse hydrological modeling paradigms. The framework's core structure comprises four main classes: Flux, Bucket, Route, Model and Wrapper, each playing a vital role in constructing comprehensive hydrological systems. The framework is implemented in Julia programming language for model development, computation, and parameter optimization. It leverages Lux.jl as the deep learning framework and integrates with SciML for scientific computing, symbolic programming, and parameter optimization capabilities. The conceptual framework of the model design philosophy is illustrated in the following diagram:","category":"page"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"(Image: Framework Concept) Architecture and ecosystem of the HydroModels.jl framework. (a) illustrates the supporting ecosystem and its functional capabilities, highlighting the key dependencies and their roles in the framework; (b) shows the core architectural design of HydroModels.jl, demonstrating the main components and their interactions.","category":"page"},{"location":"concepts_en/#Flux-class:-Water-Process-Transfer-Representation","page":"Basic Concepts","title":"Flux class: Water Process Transfer Representation","text":"","category":"section"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"The Flux class serves as the fundamental building block of HydroModels.jl, drawing inspiration from flux library of the MARRMoT while extending its capabilities. This class encapsulates the physical equations governing water movement throughout the hydrological cycle. The conceptual formulation of the Flux class can be expressed as:","category":"page"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"beginaligned\nY(t) = f(X(t)theta)  (1) \nendaligned","category":"page"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"where the functional representation f maps input variables X(t) and parameters theta to output variables Y(t). Here, X(t) represents input variables like precipitation and temperature, theta denotes the parameters that can be calibrated, and Y(t) represents output variables like runoff and infiltration. Based on different applications, the Flux class includes:","category":"page"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"HydroFlux: Implements fundamental hydrological processes through mathematical formulations\nStateFlux: Handles mass-balance equations for state variables like soil moisture and snowpack\nNeuralFlux: Uses neural networks to model processes or predict parameters, leveraging Lux.jl capabilities","category":"page"},{"location":"concepts_en/#Bucket-Class:-Storage-Volume-Change-Simulation","page":"Basic Concepts","title":"Bucket Class: Storage Volume Change Simulation","text":"","category":"section"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"The Bucket class represents fundamental water storage components within the hydrological system. It consists of multiple HydroFlux components (including NeuralFlux) and StateFlux components, which collectively define the water balance dynamics through coupled differential equations. These components can represent various hydrological stores such as soil moisture, groundwater reservoirs, and surface water bodies.","category":"page"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"The Bucket class generates two essential functions:","category":"page"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"An ODE solver function for state variables\nA hydrological flux computation function for output calculations","category":"page"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"This dual-function architecture enables efficient computation of hydrological processes, following a two-step process of solving ODEs and computing output fluxes.","category":"page"},{"location":"concepts_en/#Route-Class:-Spatial-Flow-Propagation","page":"Basic Concepts","title":"Route Class: Spatial Flow Propagation","text":"","category":"section"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"The Route class simulates lateral water fluxes across landscapes and river networks, supporting both lumped \"integral\" and distributed \"differential\" models. Its core components include:","category":"page"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"beginaligned\nQ_out(t) = f_rflux(S_route(t)Q_gen(t) ps)  (2) \nfracdS_routedt = Q_in(t) - Q_out(t)  (3) \nQ_in(t+1) = f_aggr(Q_out(t))  (4) \nendaligned","category":"page"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"Where: Q_in is inflow, Q_out is outflow, S_route is the routing state variable, and f_aggr is the aggregation function.","category":"page"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"The class supports various routing methods including:","category":"page"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"Standard state-update approaches\nUnit hydrograph through convolution operations\nDynamic routing methods (Muskingum, kinematic wave)","category":"page"},{"location":"concepts_en/#Model-Class:-Hydrological-Process-Integration","page":"Basic Concepts","title":"Model Class: Hydrological Process Integration","text":"","category":"section"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"The Model class serves as the central management component, orchestrating the integration of Flux, Bucket, and Route components. It facilitates:","category":"page"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"Construction of distributed hydrological models\nIntegration of vertical water movement with lateral connectivity\nSystematic parameter optimization and sensitivity analysis\nEfficient computation through metadata-driven approaches","category":"page"},{"location":"concepts_en/#Wrapper-Class:-Enhanced-Component-Capabilities","page":"Basic Concepts","title":"Wrapper Class: Enhanced Component Capabilities","text":"","category":"section"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"The Wrapper class extends component customization capabilities while maintaining interface uniformity. Key features include:","category":"page"},{"location":"concepts_en/","page":"Basic Concepts","title":"Basic Concepts","text":"NamedTupleIO wrapper for customized input/output specifications\nEstimateParam wrapper for parameter prediction based on basin characteristics\nRecordComponentState wrapper for state variable storage, supporting both batch training and online forecasting","category":"page"},{"location":"extent/parameter_estimate/#讨论动态参数与基于HRUs属性的参数","page":"讨论动态参数与基于HRUs属性的参数","title":"讨论动态参数与基于HRUs属性的参数","text":"","category":"section"},{"location":"get_start_en/#Getting-start-with-HydroModels.jl","page":"Get Started with HydroModels.jl","title":"Getting start with HydroModels.jl","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"This guide provides a comprehensive introduction to HydroModels.jl, a Julia package for hydrological modeling. We'll walk through the installation process, build a complete ExpHydro model, and demonstrate how to run simulations with real-world data.","category":"page"},{"location":"get_start_en/#Install-HydroModels.jl","page":"Get Started with HydroModels.jl","title":"Install HydroModels.jl","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"HydroModels.jl can be installed directly from the Julia package manager. Open a Julia REPL and enter the following command:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"] add HydroModels","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"For the latest development version, you can install directly from the GitHub repository:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"] add https://github.com/chooron/HydroModels.jl","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"After installation, load the package with:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"using HydroModels\nusing ComponentArrays  # For parameter handling\nusing CSV, DataFrames  # For data input/output","category":"page"},{"location":"get_start_en/#Build-a-ExpHydro-Model","page":"Get Started with HydroModels.jl","title":"Build a ExpHydro Model","text":"","category":"section"},{"location":"get_start_en/#Introduction-to-ExpHydro-Model","page":"Get Started with HydroModels.jl","title":"Introduction to ExpHydro Model","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"The ExpHydro model is a conceptual rainfall-runoff model that simulates watershed hydrology through a series of interconnected processes. It consists of two main components:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Snowpack Bucket: Handles snow accumulation and melt processes","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"beginaligned\n pet = 298 cdot lday cdot 24 cdot 0611 cdot fracexp(173 cdot temp)temp + 2373 cdot frac1temp + 2732  quad  (1) \n snowfall = H(T_min - temp) cdot prcp  quad  (2) \n rainfall = H(temp - T_min) cdot prcp  quad  (3) \n melt = H(temp - T_max) cdot H(snowpack) cdot min(snowpack D_f cdot (temp - T_max))  quad  (4) \n fracd(snowpack)dt = snowfall - melt  quad  (5) \nendaligned","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Soil Water Bucket: Manages soil moisture, evapotranspiration, and runoff generation","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"beginaligned\n evap = H(soilwater) cdot pet cdot minleft(10 fracsoilwaterS_maxright)  quad  (6) \n baseflow = H(soilwater) cdot Q_max cdot expleft(-f cdot max(00 S_max - soilwater)right)  quad  (7) \n surfaceflow = max(00 soilwater - S_max)  quad  (8) \n flow = baseflow + surfaceflow  quad  (9) \n fracd(soilwater)dt = rainfall + melt - evap - flow  quad  (10) \nendaligned","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"where H(x) represents the Heaviside step function that equals 1 when x  0 and 0 otherwise; T_min, T_max, D_f, S_max, Q_max, and f are model parameters; temp, lday, and prcp are input variables; snowpack and soilwater are state variables; and the remaining variables are intermediate calculation variables.","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"The model uses temperature thresholds to partition precipitation into rainfall and snowfall, and employs exponential functions to represent soil moisture dynamics. Its relative simplicity combined with physical process representation makes it an excellent starting point for hydrological modeling.","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Key parameters in the ExpHydro model include:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Tmin: Minimum temperature threshold for snow/rain partitioning\nTmax: Temperature threshold for snowmelt initiation\nDf: Degree-day factor for snowmelt calculation\nSmax: Maximum soil water storage capacity\nf: Parameter controlling baseflow recession\nQmax: Maximum baseflow rate","category":"page"},{"location":"get_start_en/#Build-an-ExpHydro-Model-in-HydroModels.jl","page":"Get Started with HydroModels.jl","title":"Build an ExpHydro Model in HydroModels.jl","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"HydroModels.jl provides a flexible framework for constructing hydrological models using a component-based approach. Let's build the ExpHydro model step by step.","category":"page"},{"location":"get_start_en/#1.-Define-the-Variables-and-Parameters-based-on-ModelingToolkit.jl","page":"Get Started with HydroModels.jl","title":"1. Define the Variables and Parameters based on ModelingToolkit.jl","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"First, we need to define the variables and parameters that will be used in our model. HydroModels.jl leverages ModelingToolkit.jl for symbolic representation of model components.","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"# Import necessary functions\nusing HydroModels\n\n# Define the step function used in hydrological processes\nstep_func(x) = (tanh(5.0 * x) + 1.0) * 0.5\n\n# Define variables and parameters (the macro @variables and @parameters are from ModelingToolkit.jl)\n@variables temp lday prcp pet snowfall rainfall snowpack melt\n@variables soilwater evap baseflow surfaceflow flow\n@parameters Tmin Tmax Df Smax Qmax f","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Here, we define:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Input variables: temp (temperature), lday (day length), prcp (precipitation)\nState variables: snowpack (snow water equivalent), soilwater (soil moisture)\nIntermediate flux variables: snowfall, rainfall, melt, pet (potential evapotranspiration), etc.\nOutput variables: flow (total streamflow)\nModel parameters: Tmin, Tmax, Df, Smax, Qmax, f","category":"page"},{"location":"get_start_en/#2.-Build-the-ExpHydro-Model","page":"Get Started with HydroModels.jl","title":"2. Build the ExpHydro Model","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"With variables and parameters defined, we can now construct the complete ExpHydro model using HydroModels.jl's macro-based syntax:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"# Define the snow component\nsnow_bucket = @hydrobucket :snow begin\n    fluxes = begin\n        @hydroflux pet ~ 29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)\n        @hydroflux snowfall ~ step_func(Tmin - temp) * prcp\n        @hydroflux rainfall ~ step_func(temp - Tmin) * prcp\n        @hydroflux melt ~ step_func(temp - Tmax) * step_func(snowpack) * min(snowpack, Df * (temp - Tmax))\n    end\n    dfluxes = begin\n        @stateflux snowpack ~ snowfall - melt\n    end\nend\n\n# Define the soil water component\nsoil_bucket = @hydrobucket :soil begin\n    fluxes = begin\n        @hydroflux evap ~ step_func(soilwater) * pet * min(1.0, soilwater / Smax)\n        @hydroflux baseflow ~ step_func(soilwater) * Qmax * exp(-f * (max(0.0, Smax - soilwater)))\n        @hydroflux surfaceflow ~ max(0.0, soilwater - Smax)\n        @hydroflux flow ~ baseflow + surfaceflow\n    end\n    dfluxes = begin\n        @stateflux soilwater ~ (rainfall + melt) - (evap + flow)\n    end\nend\n\n# Combine components into the complete ExpHydro model\nexphydro_model = @hydromodel :exphydro begin\n    snow_bucket\n    soil_bucket\nend","category":"page"},{"location":"get_start_en/#Step-by-Step-Analysis-of-the-Build-Process","page":"Get Started with HydroModels.jl","title":"Step by Step Analysis of the Build Process","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Let's break down the model construction process to understand each component in detail.","category":"page"},{"location":"get_start_en/#1.-First-Build-one-Hydrological-Flux","page":"Get Started with HydroModels.jl","title":"1. First Build one Hydrological Flux","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"A hydrological flux represents a specific process in the water cycle. For example, the snowfall flux is defined as:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"snowfall_flux = @hydroflux snowfall ~ step_func(Tmin - temp) * prcp","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"This equation partitions precipitation into snowfall based on temperature. When temperature is below Tmin, the step function approaches 1, and precipitation is treated as snowfall. The ~ operator establishes the mathematical relationship between variables.","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Each flux has:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Input variables (right side of ~): Variables used to calculate the flux\nOutput variable (left side of ~): The resulting flux value\nParameters: Model coefficients used in the calculation","category":"page"},{"location":"get_start_en/#2.-Build-All-Fluxes-inner-the-Snowpack-Bucket","page":"Get Started with HydroModels.jl","title":"2. Build All Fluxes inner the Snowpack Bucket","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"The snowpack bucket contains multiple fluxes that work together to simulate snow processes:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"fluxes = begin\n    @hydroflux pet ~ 29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)\n    @hydroflux snowfall ~ step_func(Tmin - temp) * prcp\n    @hydroflux rainfall ~ step_func(temp - Tmin) * prcp\n    @hydroflux melt ~ step_func(temp - Tmax) * step_func(snowpack) * min(snowpack, Df * (temp - Tmax))\nend","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"These fluxes represent:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"pet: Potential evapotranspiration calculated using a temperature-based formula\nsnowfall: Precipitation that falls as snow when temperature is below Tmin\nrainfall: Precipitation that falls as rain when temperature is above Tmin\nmelt: Snowmelt that occurs when temperature exceeds Tmax, limited by available snowpack","category":"page"},{"location":"get_start_en/#3.-Build-the-Snowpack-Bucket-Based-on-these-Flux","page":"Get Started with HydroModels.jl","title":"3. Build the Snowpack Bucket Based on these Flux","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"A bucket in HydroModels.jl represents a storage component with state variables that change over time. The @hydrobucket macro creates a complete hydrological storage unit that encapsulates both water movement processes and state evolution equations.","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"snow_bucket = @hydrobucket :snow begin\n    fluxes = begin\n        @hydroflux pet ~ 29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)\n        @hydroflux snowfall ~ step_func(Tmin - temp) * prcp\n        @hydroflux rainfall ~ step_func(temp - Tmin) * prcp\n        @hydroflux melt ~ step_func(temp - Tmax) * step_func(snowpack) * min(snowpack, Df * (temp - Tmax))\n    end\n    dfluxes = begin\n        @stateflux snowpack ~ snowfall - melt\n    end\nend","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"The bucket consists of two main sections:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"fluxes: Defines the hydrological processes that move water in and out of the bucket. Each flux is created with the @hydroflux macro and represents a specific hydrological process (e.g., snowfall, rainfall, melt).\ndfluxes: Specifies how state variables change over time using the @stateflux macro. In this example, the snowpack state variable changes according to the equation snowpack ~ snowfall - melt, meaning the change in snowpack equals snowfall minus snowmelt.","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"The first argument (:snow) provides a name for the bucket, which helps with identification and debugging. When the model runs, these equations are automatically converted into a system of differential equations that will be solved by the selected numerical solver.","category":"page"},{"location":"get_start_en/#4.-Build-ExpHydro-Model-Based-on-the-Snowpack-Bucket-and-Soilwater-Bucket","page":"Get Started with HydroModels.jl","title":"4. Build ExpHydro Model Based on the Snowpack Bucket and Soilwater Bucket","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"After creating the snow bucket, we need to define the soil water bucket that handles soil moisture dynamics, evapotranspiration, and runoff generation:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"soil_bucket = @hydrobucket :soil begin\n    fluxes = begin\n        @hydroflux evap ~ step_func(soilwater) * pet * min(1.0, soilwater / Smax)\n        @hydroflux baseflow ~ step_func(soilwater) * Qmax * exp(-f * (max(0.0, Smax - soilwater)))\n        @hydroflux surfaceflow ~ max(0.0, soilwater - Smax)\n        @hydroflux flow ~ baseflow + surfaceflow\n    end\n    dfluxes = begin\n        @stateflux soilwater ~ (rainfall + melt) - (evap + flow)\n    end\nend","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"The soil bucket includes several important hydrological processes:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Evapotranspiration (evap): Water loss from soil to atmosphere, dependent on potential evapotranspiration (pet) and available soil moisture\nBaseflow (baseflow): Subsurface flow that follows an exponential relationship with soil moisture deficit\nSurface runoff (surfaceflow): Excess water when soil moisture exceeds maximum capacity (Smax)\nTotal streamflow (flow): Combined baseflow and surface runoff","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"The state equation for soil moisture (soilwater) accounts for all inputs (rainfall and snowmelt) and outputs (evapotranspiration and streamflow).","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Finally, we combine the snow and soil components into a complete model using the @hydromodel macro:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"exphydro_model = @hydromodel :exphydro begin\n    snow_bucket\n    soil_bucket\nend","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"This creates a model named \"exphydro\" with two interconnected components. HydroModels.jl automatically handles the connections between components based on variable names. For example, the rainfall and melt outputs from the snow bucket are used as inputs to the soil bucket, and the pet calculation from the snow bucket is used in the evapotranspiration calculation in the soil bucket.","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"The @hydromodel macro performs several important tasks:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Analyzes dependencies between components to determine the correct execution order\nCreates a computational graph that efficiently routes information between components\nManages state variables across the entire model\nPrepares the model for simulation with various solver options","category":"page"},{"location":"get_start_en/#Run-the-ExpHydro-Model-With-Real-Data","page":"Get Started with HydroModels.jl","title":"Run the ExpHydro Model With Real Data","text":"","category":"section"},{"location":"get_start_en/#Preparation","page":"Get Started with HydroModels.jl","title":"Preparation","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Before running the model, we need to prepare input data, parameters, and initial states.","category":"page"},{"location":"get_start_en/#1.-Load-01013500-forcing-data-from-the-CAMELS-Dataset","page":"Get Started with HydroModels.jl","title":"1. Load 01013500 forcing data from the CAMELS Dataset","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"The CAMELS (Catchment Attributes and Meteorology for Large-sample Studies) dataset provides hydrometeorological time series for many watersheds. We'll use data from basin 01013500 as an example:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"# Load forcing data\nfile_path = \"data/exphydro/01013500.csv\"\ndf = DataFrame(CSV.File(file_path))\n\n# Select a time period for simulation\nts = collect(1:10000)  # One year of daily data\n\n# Extract required input variables\ninput_data = (\n    lday = df[ts, \"dayl(day)\"],   # Day length\n    temp = df[ts, \"tmean(C)\"],    # Mean temperature\n    prcp = df[ts, \"prcp(mm/day)\"] # Precipitation\n)\n\nq_data = df[ts, \"flow(mm)\"]\n\n# Convert to matrix format required by HydroModels.jl\n# We need to make the input matrix in the sort of the input names of the model\ninput_matrix = reduce(hcat, input_data[HydroModels.get_input_names(exphydro_model)]) |> permutedims","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"It is worth noting that in the line input_matrix = reduce(hcat, input_data[HydroModels.get_input_names(exphydro_model)]) |> permutedims we need to get the input variable names of the model according to get_input_names(exphydro_model) so that the input matrix has the correct order.","category":"page"},{"location":"get_start_en/#2.-Prepare-Parameters-and-Initial-States","page":"Get Started with HydroModels.jl","title":"2. Prepare Parameters and Initial States","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Next, we set up the model parameters and initial states:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"# Define parameter values (calibrated for basin 01013500)\n# Create parameter ComponentVector\nparams = ComponentVector(\n    f = 0.0167 , # Baseflow recession parameter\n    Smax = 1709.46 , # Maximum soil water storage (mm)\n    Qmax = 18.47 , # Maximum baseflow rate (mm/day)\n    Df = 2.674 , # Degree-day factor for snowmelt (mm/°C/day)\n    Tmax = 0.17 , # Temperature threshold for snowmelt (°C)\n    Tmin = -2.09 # Temperature threshold for snow/rain partitioning (°C)\n)\n\n# Set initial states\ninit_states = ComponentVector(\n    snowpack = 0.0,       # Initial snow water equivalent (mm)\n    soilwater = 1303.00   # Initial soil moisture (mm)\n)\n\n# Combine into parameter array structure\npas = ComponentVector(params = params)","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"The input parameters and initial states are stored in the type provided by ComponentArrays.jl. Each parameter name corresponds to a parameter value, and finally they are unified into pas. Params represents the hydrological model parameters, and nns represents the neural network parameters (see neuralnetwork_embeding.md)","category":"page"},{"location":"get_start_en/#3.-Prepare-the-Running-Config","page":"Get Started with HydroModels.jl","title":"3. Prepare the Running Config","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Finally, we configure the simulation settings:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"using DataInterpolations\n\n# Define simulation configuration\nconfig = (\n    # Time indices for simulation\n    timeidx = ts,\n    # Solver settings\n    solver = HydroModels.ManualSolver(mutable = true),\n    # Interpolation method for inputs\n    interp = LinearInterpolation\n)","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"The configuration includes:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"timeidx: Time indices for the simulation period\nsolver: Numerical solver for state equations (ManualSolver uses explicit Euler method)\ninterp: Method for interpolating input data between time steps, the LinearInterpolation is provided by DataInterpolations.jl.","category":"page"},{"location":"get_start_en/#Run-Model","page":"Get Started with HydroModels.jl","title":"Run Model","text":"","category":"section"},{"location":"get_start_en/#1.-Run-the-Model","page":"Get Started with HydroModels.jl","title":"1. Run the Model","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"With everything prepared, we can now run the ExpHydro model:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"# Execute the model simulation\noutput_matrix = exphydro_model(\n    input_matrix,   # Input data matrix\n    pas,            # Parameters\n    initstates = init_states,  # Initial states\n    config = config  # Configuration\n)\n\n# Extract results into named variables\noutput_names = vcat(\n    HydroModels.get_state_names(exphydro_model),\n    HydroModels.get_output_names(exphydro_model)\n)\noutput_df = NamedTuple{Tuple(output_names)}(eachslice(results, dims=1)) |> DataFrame","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"The types defined in HydroModels.jl all have the callable capability. The exphydro_model of the HydroModel type obtains the calculation result output_matrix through input data, parameters, initial state and operation settings. Its format is consistent with the input data format. The first dimension stores the variable name, and the second dimension stores the time series. The order of the variable name is the state name and output name of exphydro_model. Here we convert it to the DataFrame type and get the result as follows:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"10000×10 DataFrame\n   Row │ snowpack  soilwater  pet       snowfall  rainfall  melt     evap      baseflow   surfaceflow  flow    \n       │ Float64   Float64    Float64   Float64   Float64   Float64  Float64   Float64    Float64      Float64\n───────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────\n     1 │    0.0      1305.21  1.13779       0.0       3.1       0.0  0.868733  0.0216058          0.0  0.0216058\n     2 │    0.0      1308.28  1.51019       0.0       4.24      0.0  1.15577   0.0227406          0.0  0.0227406\n     3 │    0.0      1315.03  1.63204       0.0       8.02      0.0  1.25547   0.0254533          0.0  0.0254533\n   ⋮   │    ⋮          ⋮         ⋮         ⋮         ⋮         ⋮        ⋮          ⋮           ⋮           ⋮\n  9999 │  279.712    1517.91  0.311022      1.84      0.0      -0.0  0.276171  0.753699           0.0  0.753699\n 10000 │  279.852    1517.0   0.176836      0.14      0.0      -0.0  0.156927  0.742322           0.0  0.742322\n                                                                                                9995 rows omitted","category":"page"},{"location":"get_start_en/#2.-Check-the-Run-Cost","page":"Get Started with HydroModels.jl","title":"2. Check the Run Cost","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"We can benchmark the model performance to assess computational efficiency:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"using BenchmarkTools\n\n# Benchmark model execution\n@btime exphydro_model(\n    $input_matrix,\n    $pas,\n    initstates = $init_states,\n    config = $config\n)","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"992.800 μs (56349 allocations: 2.90 MiB) # 1,000 data points, using HydroModels.ManualSolver(mutable = true)\n10.348 ms (596349 allocations: 29.40 MiB) # 10,000 data points, using HydroModels.ManualSolver(mutable = true)","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"These benchmark results demonstrate the impressive computational efficiency of HydroModels.jl:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"For 1,000 data points (approximately 3 years of daily data), the model completes execution in less than 1 millisecond (992.8 microseconds), allocating only 2.90 MiB of memory.\nFor 10,000 data points (approximately 27 years of daily data), execution time scales linearly to about 10.3 milliseconds with 29.40 MiB of memory allocation.","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"We will discuss more about computational performance and gradient solving performance in the benchmark.","category":"page"},{"location":"get_start_en/#3.-Explain-the-Results","page":"Get Started with HydroModels.jl","title":"3. Explain the Results","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"The simulation results contain time series for all state variables and output fluxes:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"# Plot the results\nusing Plots\n\n# Create a multi-panel plot\np1 = plot(ts, output_data.snowpack, label=\"Snowpack (mm)\", ylabel=\"SWE (mm)\")\np2 = plot(ts, output_data.soilwater, label=\"Soil Moisture (mm)\", ylabel=\"SM (mm)\")\np3 = plot(ts, output_data.flow, label=\"Simulated Flow\", ylabel=\"Flow (mm/day)\")\n\n# Add observed flow if available\nif \"flow(mm)\" in names(df)\n    plot!(p3, ts, q_data, label=\"Observed Flow\")\nend\n\n# Combine plots\nplot(p1, p2, p3, layout=(3,1), size=(800, 600))","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"(Image: exphydro_results)","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"The key outputs include:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Snowpack: Shows snow accumulation during winter months and melting during spring\nSoil Moisture: Reflects the balance between water inputs (rainfall, snowmelt) and outputs (evaporation, runoff)\nFlow: The total streamflow, which can be compared with observations to assess model performance","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Additional analysis can include:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"# Calculate performance metrics if observed data is available\nobserved_flow = df[ts, \"flow(mm)\"]\nsimulated_flow = output_data.flow\n\n# Nash-Sutcliffe Efficiency\nnse = 1 - sum((observed_flow - simulated_flow).^2) / sum((observed_flow .- mean(observed_flow)).^2)\n\n# Percent Bias\npbias = 100 * (sum(simulated_flow) - sum(observed_flow)) / sum(observed_flow)\n\nprintln(\"Nash-Sutcliffe Efficiency: \", nse)\nprintln(\"Percent Bias: \", pbias, \"%\")","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Nash-Sutcliffe Efficiency: 0.7323810502829138\nPercent Bias: 4.127942033470476%","category":"page"},{"location":"get_start_en/#Conclusion","page":"Get Started with HydroModels.jl","title":"Conclusion","text":"","category":"section"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"In this guide, we've walked through the process of building and running a hydrological model using HydroModels.jl. The ExpHydro model demonstrates the core capabilities of the framework, including:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Component-Based Modeling: Building complex models from simpler components\nSymbolic Model Definition: Using mathematical expressions to define hydrological processes\nEfficient Simulation: Running models with real-world data\nResult Analysis: Extracting and visualizing simulation outputs","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"HydroModels.jl provides a flexible and powerful platform for hydrological modeling, suitable for both research and operational applications. The framework's modular design allows for easy extension and customization, enabling users to implement a wide range of hydrological models.","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Next steps include:","category":"page"},{"location":"get_start_en/","page":"Get Started with HydroModels.jl","title":"Get Started with HydroModels.jl","text":"Embedding neural networks in hydrological models\nAdding unit hydrograph calculation modules to hydrological models\nBuilding and computing multi-node models (distributed and semi-distributed)\nUsing solvers from DifferentialEquations.jl\nOptimizing model parameters based on Optimization.jl","category":"page"},{"location":"tutorials/distribute_modeling/#Multi-Node/Distributed-Hydrological-Modeling","page":"Distribute Modeling","title":"Multi-Node/Distributed Hydrological Modeling","text":"","category":"section"},{"location":"tutorials/distribute_modeling/#Introduction-to-Multi-Node/Distributed-Hydrological-Modeling","page":"Distribute Modeling","title":"Introduction to Multi-Node/Distributed Hydrological Modeling","text":"","category":"section"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"The hydrological models introduced earlier are primarily lumped models, which use a single model to simulate an entire watershed. This approach is typically suitable for smaller watersheds. For large watersheds with significant topographic features and river network topology, a single hydrological model is insufficient to simulate the processes accurately.","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"Researchers have proposed methods to build hydrological models based on watershed topographic characteristics and then integrate them using routing models. This approach is known as distributed hydrological modeling. The process begins by dividing the watershed into multiple hydrological response units (which we call multi-nodes). This division can be done either by partitioning the watershed into standard grids of fixed size (distributed approach) or by dividing it into irregularly shaped sub-watersheds based on river topology (semi-distributed approach). The runoff results from these multiple nodes are then integrated using geographic elevation information and river network topology.","category":"page"},{"location":"tutorials/distribute_modeling/#Implementation-of-Multi-Node-Models","page":"Distribute Modeling","title":"Implementation of Multi-Node Models","text":"","category":"section"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"All types constructed in HydroModels.jl (Flux, Bucket, Route, Model) support multi-node computation without requiring additional declarations during construction. Each module automatically allocates the appropriate computational scenario based on the input data type. This section primarily introduces the construction methods for routing modules. Using the HBV model as the runoff generation model, we have constructed three types of routing models: unit hydrograph-based routing, semi-distributed routing based on river network topology, and distributed routing based on geographic elevation information.","category":"page"},{"location":"tutorials/distribute_modeling/#1.-Unit-Hydrograph-Based-Routing-Model","page":"Distribute Modeling","title":"1. Unit Hydrograph-Based Routing Model","text":"","category":"section"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"HBV-maxbas uses HBV as its foundation and a unit hydrograph model for routing. The unit hydrograph parameters are determined by the distance from the computational grid to the outlet node. The implementation is as follows:","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"uh = @unithydro :maxbas_uh begin\n    uh_func = begin\n        2lag => (1 - 0.5 * (2 - t / lag)^2.5)\n        lag => (0.5 * (t / lag)^2.5)\n    end\n    uh_vars = [q]\n    configs = (solvetype=:DISCRETE, suffix=:_lag)\nend","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"Both semi-distributed routing based on river network topology and distributed routing based on geographic elevation information can be constructed using HydroRoute. The difference between these two construction methods lies in the aggregate function.","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"Semi-distributed hydrological models typically describe the connectivity of sub-watersheds using directed graphs. This allows for the integration of runoff results from different sub-watersheds based on the connection relationships provided by the network:","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"discharge_route = @hydroroute :exphydro_routed begin\n    fluxes = begin\n        @hydroflux q_routed ~ s_river / (1 + lag) + q\n    end\n    dfluxes = begin\n        @stateflux s_river ~ q - q_routed\n    end\n    aggr_func = HydroModels.build_aggr_func(network)\nend","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"The construction of fluxes and dfluxes is similar to that of Bucket, but with some limitations:","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"The number of fluxes and dfluxes must correspond. fluxes represents the flow from the current computational unit to the next, while dfluxes represents the storage volume of the routing module in the current computational unit. It is composed of the runoff from the current unit, inflow from other units, and outflow to other units. The complete formula should be:","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"$","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"\\frac{dS{route}}{dt} = Q{in}(t) - Q{out}(t) + Q{gen}(t) $","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"Here, we assume that Q_in(t) equals aggr_func(Q_out(t)), meaning the inflow for the current time period equals the result of routing the outflow for the current time period (this process is continuous, so we consider this expression valid). To simplify the construction of the Route module, this calculation is relatively fixed, but more modifications can be made in the writing of fluxes.","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"Compared to Bucket, the Route module also needs to provide an aggregate function. This function is constructed from the flow direction matrix calculated from the topological relationships of sub-watersheds or geographic elevation data, and is used to calculate Q_in(t) for the current time period.","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"For semi-distributed hydrological models, a directed graph can be constructed based on the upstream-downstream connection relationships of the watershed (using Graphs.jl):","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"network = DiGraph(9)\nadd_edge!(network, 1, 2)\nadd_edge!(network, 2, 5)\nadd_edge!(network, 3, 5)\nadd_edge!(network, 4, 5)\nadd_edge!(network, 5, 8)\nadd_edge!(network, 6, 9)\nadd_edge!(network, 7, 8)\nadd_edge!(network, 8, 9)\n\naggr_func = HydroModels.build_aggr_func(network)","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"The code represents the connection relationships of the watershed by constructing a directed graph, where the numbers in the directed graph represent the node numbers.","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"For distributed hydrological models, a flow direction matrix (d8) and a list of matrix indices representing the input node index order are needed to ensure the correctness of the input integration:","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"flwdir = [1 4 8; 1 4 4; 1 1 2]\npositions = [[1, 1], [1, 2], [1, 3], [2, 1], [2, 2], [2, 3], [3, 1], [3, 2], [3, 3]]","category":"page"},{"location":"tutorials/distribute_modeling/#Implementing-Multi-Node-Computation-with-HydroModels.jl","page":"Distribute Modeling","title":"Implementing Multi-Node Computation with HydroModels.jl","text":"","category":"section"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"All types constructed in HydroModels.jl (Flux, Bucket, Route, Model) support multi-node computation without requiring additional declarations during construction. Each module automatically allocates the appropriate computational scenario based on the input data type. Below, I will introduce the execution process of multi-node computation from three aspects: data preparation, parameter settings, and runtime configuration.","category":"page"},{"location":"tutorials/distribute_modeling/#1.-Data-Preparation","page":"Distribute Modeling","title":"1. Data Preparation","text":"","category":"section"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"For single-node input, the data format is variables × time dimensions. For multi-node input, the data format becomes variables × nodes × time dimensions, resulting in a three-dimensional matrix.","category":"page"},{"location":"tutorials/distribute_modeling/#2.-Parameter-Preparation","page":"Distribute Modeling","title":"2. Parameter Preparation","text":"","category":"section"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"For single-node input, the parameter format is:","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"params = ComponentVector(\n    params=(p1=0.0, p2=0.0, ...),\n    nns=(nn1=[...], )\n)","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"As you can see, each parameter name corresponds to a single value.","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"For multi-node input, the parameter format is:","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"params = ComponentVector(\n    params=(p1=[0.0, 0.0, ...], p2=[0.0, 0.0, ...], ...),\n    nns=(nn1=[...], )\n)","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"Each parameter corresponds to an array of values, representing the parameters for each node. Note that the neural network parameters do not show significant changes. This is because constructing a neural network for each node during multi-node computation would make the computational cost relatively large and unnecessary.","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"Similarly, the initial states follow the same pattern as the parameters:","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"initstates = ComponentVector(\n    s1=[0.0, 0.0, ...],\n    s2=[0.0, 0.0, ...],\n    ...\n)","category":"page"},{"location":"tutorials/distribute_modeling/#3.-Runtime-Configuration","page":"Distribute Modeling","title":"3. Runtime Configuration","text":"","category":"section"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"In multi-node computation, there are new settings: ptyidx (parameter type index) and styidx (state type index). In distributed hydrological models, some computational units have highly similar natural attributes, so it's reasonable to share parameters and initial states. This can be achieved using ptyidx and styidx:","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"In the multi-node input parameters, each parameter corresponds to a parameter array. For example, parameter p1:","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"p1 = [3, 7, 2, 4]","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"The parameter array stores 4 types of parameters. If we assume there are 10 computational nodes, we can set ptyidx as:","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"ptyidx = [1, 1, 1, 2, 2, 2, 3, 3, 3, 4]","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"Each index in ptyidx represents a node, and each value indicates the parameter type to which the node belongs. Expanding parameter p1 using ptyidx:","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"new_p1 = p1[ptyidx]","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"This gives us the corresponding value for each node.","category":"page"},{"location":"tutorials/distribute_modeling/#Real-World-Example-(Based-on-HBVmaxbas/route-Model)","page":"Distribute Modeling","title":"Real-World Example (Based on HBV+maxbas/route Model)","text":"","category":"section"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"To demonstrate the practical application of multi-node modeling, let's consider a real-world example using the HBV model for runoff generation combined with either maxbas or route for flow routing.","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"First, we'll define our watershed structure using a directed graph to represent the connectivity between sub-watersheds:","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"# Define watershed network structure\nnetwork = DiGraph(9)  # 9 sub-watersheds\nadd_edge!(network, 1, 2)  # Sub-watershed 1 flows into 2\nadd_edge!(network, 2, 5)\nadd_edge!(network, 3, 5)\nadd_edge!(network, 4, 5)\nadd_edge!(network, 5, 8)\nadd_edge!(network, 6, 9)\nadd_edge!(network, 7, 8)\nadd_edge!(network, 8, 9)  # Sub-watershed 8 flows into outlet 9\n\n# Create the routing component\ndischarge_route = @hydroroute :hbv_routed begin\n    fluxes = begin\n        @hydroflux q_routed ~ s_river / (1 + lag) + q\n    end\n    dfluxes = begin\n        @stateflux s_river ~ q - q_routed\n    end\n    aggr_func = HydroModels.build_aggr_func(network)\nend\n\n# Combine with HBV model\nhbv_distributed = @hydromodel :hbv_distributed begin\n    hbv_bucket  # Runoff generation component\n    discharge_route  # Routing component\nend","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"Next, we prepare our input data and parameters for the multi-node model:","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"# Prepare input data (variables × nodes × time)\ninput_data = zeros(3, 9, 365)  # Example: 3 variables, 9 nodes, 365 days\n# Fill with actual precipitation, temperature, etc. data for each node\n\n# Define parameter types (4 types of terrain)\nparams = ComponentVector(\n    params=(\n        FC=[150.0, 200.0, 100.0, 180.0],  # Field capacity for each terrain type\n        LP=[0.7, 0.8, 0.6, 0.75],\n        BETA=[2.0, 3.0, 1.5, 2.5],\n        # Other HBV parameters...\n        lag=[1.5, 2.0, 1.0, 1.8]  # Routing lag parameter\n    )\n)\n\n# Define which terrain type each node belongs to\nptyidx = [1, 1, 2, 2, 3, 3, 4, 4, 4]\n\n# Initial states for each node\ninitstates = ComponentVector(\n    snowpack=zeros(9),\n    soilwater=zeros(9),\n    s_river=zeros(9)\n)\n\n# Run the distributed model\nresults = hbv_distributed(\n    input_data,\n    params,\n    initstates=inititstates,\n    ptyidx=ptyidx\n)","category":"page"},{"location":"tutorials/distribute_modeling/","page":"Distribute Modeling","title":"Distribute Modeling","text":"This example demonstrates how HydroModels.jl can efficiently handle multi-node hydrological modeling with parameter sharing across similar terrain types, significantly reducing the number of parameters that need to be calibrated while maintaining the spatial heterogeneity of the watershed.","category":"page"},{"location":"tutorials/framework_design/#Understanding-DeepFlex.jl-Core-Concepts","page":"Framework Design","title":"Understanding DeepFlex.jl Core Concepts","text":"","category":"section"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"This document explains the core concepts of the DeepFlex.jl framework, focusing on the three fundamental components: Flux, Element/Bucket, and Model. We'll use examples from the ExpHydro model to illustrate these concepts in practice.","category":"page"},{"location":"tutorials/framework_design/#Framework-Architecture","page":"Framework Design","title":"Framework Architecture","text":"","category":"section"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"DeepFlex.jl is built on a modular architecture with three core components:","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"Flux: Basic computational units that define mathematical relationships\nElement/Bucket: Storage components that integrate fluxes and manage state variables\nModel: The top-level structure that combines all components into a complete system","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"This architecture allows you to build models ranging from simple conceptual models to complex physically-based or hybrid models using the same framework.","category":"page"},{"location":"tutorials/framework_design/#Flux-Components","page":"Framework Design","title":"Flux Components","text":"","category":"section"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"Fluxes are the fundamental building blocks in DeepFlex.jl. They define the mathematical relationships between variables in your hydrological system.","category":"page"},{"location":"tutorials/framework_design/#HydroFlux","page":"Framework Design","title":"HydroFlux","text":"","category":"section"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"A HydroFlux defines a mathematical relationship between input and output variables using symbolic expressions.","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"In the ExpHydro model, several HydroFlux components are used to calculate processes like snowfall, rainfall, and potential evapotranspiration:","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"@hydroflux begin\n    snowfall ~ step_func(Tmin - temp) * prcp\n    rainfall ~ step_func(temp - Tmin) * prcp\nend\n@hydroflux pet ~ 29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"┌ HydroFlux{##hydro_flux#7684448861079742687}\n│ Inputs:  [prcp, temp]\n│ Outputs: [snowfall, rainfall]\n│ Params:  [Tmin]\n│ Expressions:\n│   snowfall = 0.5prcp*(1.0 + tanh(5.0(Tmin - temp)))\n│   rainfall = 0.5prcp*(1.0 + tanh(5.0(-Tmin + temp)))\n└─","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"┌ HydroFlux{##hydro_flux#3326951609664340984}\n│ Inputs:  [temp, lday]\n│ Outputs: [pet]\n│ Params:  []\n│ Expressions:\n│   pet = (436.98720000000003lday*exp((17.3temp) / (237.3 + temp))) / (273.2 + temp)\n└─","category":"page"},{"location":"tutorials/framework_design/#Structure-of-HydroFlux-Components","page":"Framework Design","title":"Structure of HydroFlux Components","text":"","category":"section"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"As shown in the printed output above, each HydroFlux has a well-defined internal structure that includes several key elements:","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"Unique Identifier: Each flux component has a unique hash identifier (e.g., ##hydro_flux#7684448861079742687), which allows the system to track and reference specific flux components within the model.\nInput Variables: Listed under Inputs:, these are the variables required to calculate the flux. In the first example, the precipitation partitioning component requires precipitation (prcp) and temperature (temp).\nOutput Variables: Listed under Outputs:, these are the variables produced by the flux calculations. The first component outputs both snowfall and rainfall.\nParameters: Listed under Params:, these are the model parameters used in the calculations. The temperature threshold Tmin is a parameter in the precipitation partitioning component.\nMathematical Expressions: The actual equations that define how outputs are calculated from inputs and parameters. In the first component, the step_func(Tmin - temp) from the original code is expanded to 0.5*(1.0 + tanh(5.0(Tmin - temp))), which creates a smooth step function around the threshold temperature Tmin.","category":"page"},{"location":"tutorials/framework_design/#Transformation-from-Code-to-Internal-Representation","page":"Framework Design","title":"Transformation from Code to Internal Representation","text":"","category":"section"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"When you define a flux using the @hydroflux macro, the system:","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"Parses the expressions and identifies inputs, outputs, and parameters\nConverts the expressions into a symbolic representation using ModelingToolkit.jl\nOptimizes and simplifies the expressions where possible\nCreates a structured HydroFlux object with all necessary metadata","category":"page"},{"location":"tutorials/framework_design/#Advantages-of-This-Representation","page":"Framework Design","title":"Advantages of This Representation","text":"","category":"section"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"This structured representation offers several benefits:","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"Modularity: Each flux component is self-contained with clear inputs, outputs, and parameters\nTransparency: The mathematical relationships are explicitly defined and easily inspectable\nAutomatic Differentiation: The symbolic expressions can be automatically differentiated, enabling gradient-based optimization\nComputational Efficiency: The expressions can be compiled into efficient computational code\nConnectivity: The system can automatically determine how components connect based on matching variable names","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"These expressions define:","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"How precipitation is partitioned into snowfall and rainfall based on temperature\nHow potential evapotranspiration is calculated from temperature and day length","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"HydroFlux components are used for processes that can be expressed as explicit mathematical formulas.","category":"page"},{"location":"tutorials/framework_design/#StateFlux","page":"Framework Design","title":"StateFlux","text":"","category":"section"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"A StateFlux defines how state variables change over time. These are used to create differential equations that are solved during simulation.","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"In the ExpHydro model, StateFlux components define how the snowpack and soil water storage change:","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"@stateflux snowpack ~ snowfall - melt\n@stateflux soilwater ~ (rainfall + melt) - (evap + flow)","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"┌ StateFlux{##state_flux#7140258851200262205}\n│ Inputs:  [melt, snowfall]\n│ States:  [snowpack]\n│ Params:  []\n│ Expressions:\n│   snowpack = -melt + snowfall\n└─\n\njulia> @stateflux soilwater ~ (rainfall + melt) - (evap + flow)\n┌ StateFlux{##state_flux#7046604567730147152}\n│ Inputs:  [melt, rainfall, evap, flow]\n│ States:  [soilwater]\n│ Params:  []\n│ Expressions:\n│   soilwater = -evap - flow + melt + rainfall\n└─","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"These expressions define:","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"The snowpack increases with snowfall and decreases with snowmelt\nThe soil water increases with rainfall and snowmelt, and decreases with evapotranspiration and streamflow","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"StateFlux components are essential for water balance calculations and form the basis of the ordinary differential equations (ODEs) that are solved during simulation.","category":"page"},{"location":"tutorials/framework_design/#Element/Bucket-Components","page":"Framework Design","title":"Element/Bucket Components","text":"","category":"section"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"Elements are higher-level components that integrate multiple fluxes and manage state variables. The primary type of element in DeepFlex.jl is the Bucket.","category":"page"},{"location":"tutorials/framework_design/#HydroBucket","page":"Framework Design","title":"HydroBucket","text":"","category":"section"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"A HydroBucket represents a storage component with state variables that change over time according to input and output fluxes. It encapsulates both water movement processes and state evolution equations.","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"In the ExpHydro model, two buckets are defined:","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"Snow Bucket: Handles snow accumulation and melt processes","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"snow_bucket = @hydrobucket :snow begin\n    fluxes = begin\n        @hydroflux pet ~ 29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)\n        @hydroflux snowfall ~ step_func(Tmin - temp) * prcp\n        @hydroflux rainfall ~ step_func(temp - Tmin) * prcp\n        @hydroflux melt ~ step_func(temp - Tmax) * step_func(snowpack) * min(snowpack, Df * (temp - Tmax))\n    end\n    dfluxes = begin\n        @stateflux snowpack ~ snowfall - melt\n    end\nend","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"┌ HydroBucket{snow}\n│ Inputs:  [temp, lday, prcp]\n│ States:  [snowpack]\n│ Outputs: [pet, snowfall, rainfall, melt]\n│ Params:  []\n│ NNs:     []\n│\n│ Fluxes:\n│   Num[pet] ~ (436.98720000000003lday*exp((17.3temp) / (237.3 + temp))) / (273.2 + temp)\n│   Num[snowfall] ~ 0.5prcp*(1.0 + tanh(5.0(-2.092959084 - temp)))\n│   Num[rainfall] ~ 0.5prcp*(1.0 + tanh(5.0(2.092959084 + temp)))\n│   Num[melt] ~ 0.25(1.0 + tanh(5.0snowpack))*min(snowpack, 2.674548848(-0.175739196 + temp))*(1.0 + tanh(5.0(-0.175739196 + temp)))\n│\n│ State Fluxes:\n│   snowpack ~ -melt + snowfall\n└─","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"Soil Water Bucket: Manages soil moisture, evapotranspiration, and runoff generation","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"soil_bucket = @hydrobucket :soil begin\n    fluxes = begin\n        @hydroflux evap ~ step_func(soilwater) * pet * min(1.0, soilwater / Smax)\n        @hydroflux baseflow ~ step_func(soilwater) * Qmax * exp(-f * (max(0.0, Smax - soilwater)))\n        @hydroflux surfaceflow ~ max(0.0, soilwater - Smax)\n        @hydroflux flow ~ baseflow + surfaceflow\n    end\n    dfluxes = begin\n        @stateflux soilwater ~ (rainfall + melt) - (evap + flow)\n    end\nend","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"┌ HydroBucket{soil}\n│ Inputs:  [pet, melt, rainfall]\n│ States:  [soilwater]\n│ Outputs: [evap, baseflow, surfaceflow, flow]\n│ Params:  [Smax, f, Qmax]\n│ NNs:     []\n│\n│ Fluxes:\n│   Num[evap] ~ 0.5pet*min(1.0, 0.0005849797048457405soilwater)*(1.0 + tanh(5.0soilwater))\n│   Num[baseflow] ~ 9.234980875exp(-0.01674478max(0.0, 1709.461015 - soilwater))*(1.0 + tanh(5.0soilwater)) \n│   Num[surfaceflow] ~ max(0.0, -1709.461015 + soilwater)\n│   Num[flow] ~ baseflow + surfaceflow\n│\n│ State Fluxes:\n│   soilwater ~ -evap - flow + melt + rainfall\n└─","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"Each bucket:","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"Integrates multiple flux components\nManages state variables and their dynamics\nHandles ODE solving for time evolution\nSupports both single-node and multi-nodes simulations","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"The bucket structure allows for modular model construction, where each bucket represents a distinct hydrological process or storage component.","category":"page"},{"location":"tutorials/framework_design/#HydroRoute","page":"Framework Design","title":"HydroRoute","text":"","category":"section"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"Another type of element is HydroRoute, which handles water routing through a network of connected nodes. While not used in the basic ExpHydro model, routing components are essential for distributed hydrological modeling:","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"# Example routing component\nroute = @hydroroute :river_routing begin\n    fluxes = begin\n        @hydroflux outflow ~ inflow * (1 - exp(-k * travel_time))\n    end\n    dfluxes = begin\n        @stateflux channel_storage ~ inflow - outflow\n    end\n    aggr_func = network_aggregation_function\nend","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"Routing components manage flow calculations and inter-node water transfer in network-based models.","category":"page"},{"location":"tutorials/framework_design/#Specialized-Structures","page":"Framework Design","title":"Specialized Structures","text":"","category":"section"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"Hydrological models incorporate several specialized structures, with the unit hydrograph being the most typical example. The unit hydrograph is a module used to describe hillslope routing, simulating the process of runoff concentration after runoff generation through convolution calculations.","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"Q(t) = sum_i=1^t P(t-i+1) cdot UH(i)","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"To represent this concept, HydroModels.jl has designed two types: UHFunction and UnitHydrograph. These represent the unit hydrograph function and the unit hydrograph model, respectively.","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"The unit hydrograph function calculates the distribution weights for different time periods in the runoff process, while the unit hydrograph model describes which flux is used for unit hydrograph routing calculations. Here, we use the unit hydrographs for slow flow and fast flow routing calculations in the GR4J model as implementation examples.","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"# Unit hydrograph components for GR4J model\nuh = @unithydro :maxbas_uh begin\n    uh_func = begin\n        2lag => (1 - 0.5 * (2 - t / lag)^2.5)\n        lag => (0.5 * (t / lag)^2.5)\n    end\n    uh_vars = [q]\n    configs = (solvetype=:DISCRETE, suffix=:_lag)\nend","category":"page"},{"location":"tutorials/framework_design/#Model:-The-Integration-Framework","page":"Framework Design","title":"Model: The Integration Framework","text":"","category":"section"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"The HydroModel is the top-level structure that integrates multiple components into a complete simulation system.","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"In the ExpHydro model, the snow and soil buckets are combined into a complete model:","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"exphydro_model = @hydromodel :exphydro begin\n    snow_bucket\n    soil_bucket\nend","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"┌ HydroModel: exphydro\n│ Components: snow, soil\n│ Inputs:     [temp, lday, prcp]\n│ States:     [snowpack, soilwater]\n│ Outputs:    [pet, snowfall, rainfall, melt, evap, baseflow, surfaceflow, flow]\n│ Parameters: [Tmin, Df, Tmax, Smax, f, Qmax]\n│ Summary:\n│   Fluxes:  0 fluxes\n│   Buckets: 2 buckets\n│   Routes:  0 routes\n└─","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"The model automatically:","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"Analyzes dependencies between components\nCreates a computational graph for efficient execution\nManages state variables across the entire model\nPrepares the model for simulation with various solver options","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"The model provides a unified interface for simulation, allowing you to run the model with different input data, parameters, and configuration options:","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"# Run the model\nresults = exphydro_model(\n    input_matrix,   # Input data matrix\n    params,         # Parameters\n    initstates = init_states,  # Initial states\n    config = config  # Configuration\n)","category":"page"},{"location":"tutorials/framework_design/#How-Components-Work-Together","page":"Framework Design","title":"How Components Work Together","text":"","category":"section"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"The power of DeepFlex.jl comes from how these components work together:","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"Fluxes define the mathematical relationships and processes\nBuckets/Elements integrate these fluxes and manage state variables\nModels combine multiple elements into a complete simulation system","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"In the ExpHydro model:","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"HydroFlux components define processes like snowfall, rainfall, and potential evapotranspiration\nStateFlux components define how snowpack and soil water storage change over time\nHydroBucket components integrate these fluxes into snow and soil water components\nHydroModel combines these components into a complete ExpHydro model","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"The framework automatically handles the connections between components. For example, the rainfall and melt outputs from the snow bucket are used as inputs to the soil bucket without requiring explicit connections.","category":"page"},{"location":"tutorials/framework_design/#Execution-Process","page":"Framework Design","title":"Execution Process","text":"","category":"section"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"When running a model in DeepFlex.jl, the following steps occur:","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"Data Preparation:\nInput data is organized as a matrix (features × time)\nParameters are provided as a ComponentVector\nInitial states are specified\nConfiguration:\nSolver selection (e.g., ManualSolver for explicit Euler method)\nInterpolation method (e.g., LinearInterpolation)\nTime indices for output\nExecution:\nComponents are executed in dependency order\nState variables are integrated over time\nFluxes are calculated at each time step\nResults are collected and organized\nOutput:\nTime series of state variables (e.g., snowpack, soil moisture)\nTime series of output fluxes (e.g., streamflow)","category":"page"},{"location":"tutorials/framework_design/#Conclusion","page":"Framework Design","title":"Conclusion","text":"","category":"section"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"Understanding the relationships between Flux, Element/Bucket, and Model components is essential for effectively using the HydroModels.jl framework. These components provide a flexible and powerful system for building hydrological models of varying complexity.","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"The ExpHydro model demonstrates how these components work together to create a complete hydrological model:","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"Flux components define the mathematical relationships\nBucket components integrate these fluxes and manage state variables\nThe Model combines these components into a complete simulation system","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"By leveraging this modular architecture, you can:","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"Build models from reusable components\nCombine process-based and data-driven approaches","category":"page"},{"location":"tutorials/framework_design/","page":"Framework Design","title":"Framework Design","text":"This framework design enables a wide range of hydrological modeling applications while maintaining computational efficiency and scientific rigor.","category":"page"},{"location":"implements/build_m50_model_en/#Embedding-Neural-Networks-in-ExpHydro-Model:-Implementation-of-[M50](https://hess.copernicus.org/articles/26/5085/2022/)-Model","page":"construct the M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"","category":"section"},{"location":"implements/build_m50_model_en/","page":"construct the M50 Model","title":"construct the M50 Model","text":"marv-in proposed the M50 and M100 models in their paper, with code stored in HydroNODE, pioneering the integration of neural networks into hydrological models (notably by replacing ExpHydro model's calculation formulas while participating in balance equation solving). This model inspired our repository, and recognizing the current complexity in model development, our primary goal is to simplify the process of embedding neural networks into hydrological models. Below, we'll compare the source code with our repository's implementation of M50 and M100 models, showcasing a new approach to model construction.","category":"page"},{"location":"implements/build_m50_model_en/#M50-Implementation-in-HydroNODE","page":"construct the M50 Model","title":"M50 Implementation in HydroNODE","text":"","category":"section"},{"location":"implements/build_m50_model_en/","page":"construct the M50 Model","title":"construct the M50 Model","text":"First, let's examine the implementation of M50 and M100 models in HydroNODE:","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct the M50 Model","title":"construct the M50 Model","text":"# define the ODE problem\nfunction NeuralODE_M50_core!(dS,S,p,t)\n\n    Tmin, Tmax, Df = (p_bucket_precal...,)\n\n    Lday = itp_Lday(t)\n    P    = itp_P(t)\n    T    = itp_T(t)\n\n    g_ET = ann_ET([norm_S0(S[1]), norm_S1(S[2]), norm_T(T)],p[:p1]) #p[idcs_params_ann_ET])\n    g_Q = ann_Q([norm_S1(S[2]), norm_P(P)],p[:p2]) #p[idcs_params_ann_Q])\n\n    melting = M(S[1], T, Df, Tmax)\n    dS[1] = Ps(P, T, Tmin) - melting\n    dS[2] = Pr(P, T, Tmin) + melting - step_fct(S[2])*Lday*exp(g_ET[1])- step_fct(S[2])*exp(g_Q[1])\n\nend\n# build and solve ODE problem\nprob = ODEProblem(NeuralODE_M50_core!, S_init, Float64.((t_out[1], maximum(t_out))), p)\nsol = solve(prob, BS3(), dt=1.0, saveat=t_out, reltol=1e-3, abstol=1e-3, sensealg=BacksolveAdjoint(autojacvec=ZygoteVJP()))\n# calculate Qout\nP_interp = norm_P.(itp_P.(t_out))\nS1_ = norm_S1.(sol[2,:])\nQout_ =  exp.(ann_Q(permutedims([S1_ P_interp]),p[:p2])[1,:])","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct the M50 Model","title":"construct the M50 Model","text":"In the HydroNODE code, we can see that model construction consists of three steps:","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct the M50 Model","title":"construct the M50 Model","text":"ODE function definition\nODE problem construction and solution\nCalculation of Qout from intermediate states","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct the M50 Model","title":"construct the M50 Model","text":"While this code follows the standard style of the DifferentialEquations.jl library, it requires manual construction of model calculation formulas (M, Ps, Pr) and their combination with state equation expressions (dS). The model has high coupling, and obtaining intermediate calculation fluxes like Qout requires additional calls to corresponding calculation formulas, making the code relatively complex to write.","category":"page"},{"location":"implements/build_m50_model_en/#M50-Implementation-in-HydroModels.jl","page":"construct the M50 Model","title":"M50 Implementation in HydroModels.jl","text":"","category":"section"},{"location":"implements/build_m50_model_en/","page":"construct the M50 Model","title":"construct the M50 Model","text":"First, we need to define the parameters and variables designed in the M50 model:","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct the M50 Model","title":"construct the M50 Model","text":"using HydroModels\n\n#! parameters in the Exp-Hydro model\n@parameters Tmin Tmax Df Smax f Qmax\n#! parameters in normalize flux\n@parameters snowpack_std snowpack_mean\n@parameters soilwater_std soilwater_mean\n@parameters prcp_std prcp_mean\n@parameters temp_std temp_mean\n\n#! hydrological flux in the Exp-Hydro model\n@variables prcp temp lday pet rainfall snowfall\n@variables snowpack soilwater lday pet\n@variables melt log_evap_div_lday log_flow flow\n@variables norm_snw norm_slw norm_temp norm_prcp\n\nstep_func(x) = (tanh(5.0 * x) + 1.0) * 0.5","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct the M50 Model","title":"construct the M50 Model","text":"Compared to conventional conceptual hydrological models, the M50 model uses neural networks to replace hydrological flux calculation formulas (ET and Q). These neural networks differ significantly from standard calculation formulas, so HydroModels.jl uses NeuralFlux to represent neural networks. The NeuralFlux for ET and Q predictions is shown below:","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct the M50 Model","title":"construct the M50 Model","text":"using Lux\nusing StableRNGs\n\n# define the ET NN and Q NN\nep_nn = Lux.Chain(\n    Lux.Dense(3 => 16, tanh),\n    Lux.Dense(16 => 16, leakyrelu),\n    Lux.Dense(16 => 1, leakyrelu),\n    name=:epnn\n)\nep_nn_params = Vector(ComponentVector(first(Lux.setup(StableRNGs.LehmerRNG(1234), ep_nn))))\nq_nn = Lux.Chain(\n    Lux.Dense(2 => 16, tanh),\n    Lux.Dense(16 => 16, leakyrelu),\n    Lux.Dense(16 => 1, leakyrelu),\n    name=:qnn\n)\nq_nn_params = Vector(ComponentVector(first(Lux.setup(StableRNGs.LehmerRNG(1234), q_nn))))\n\n\nep_nn_flux = NeuralFlux([norm_snw, norm_slw, norm_temp] => [log_evap_div_lday], ep_nn)\nq_nn_flux = NeuralFlux([norm_slw, norm_prcp] => [log_flow], q_nn)","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct the M50 Model","title":"construct the M50 Model","text":"A special aspect of building the M50 model is the need to wrap embedded neural networks using the NeuralFlux model, providing input-output information for the neural networks and converting them into expressions during construction.","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct the M50 Model","title":"construct the M50 Model","text":"Then we can build the remaining parts of the M50 model:","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct the M50 Model","title":"construct the M50 Model","text":"# define the snow pack reservoir\nsnow_fluxes = [\n    HydroFlux([temp, lday] => [pet], exprs=[29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)]),\n    HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp]),\n    HydroFlux([snowpack, temp] => [melt], [Tmax, Df], exprs=[step_func(temp - Tmax) * min(snowpack, Df * (temp - Tmax))]),\n]\nsnow_dfluxes = [StateFlux([snowfall] => [melt], snowpack)]\nsnow_ele = HydroBucket(name=:exphydro_snow, fluxes=snow_fluxes, dfluxes=snow_dfluxes)\n\n# define the soil water reservoir\nsoil_fluxes = [\n    #* normalize\n    HydroFlux([snowpack, soilwater, prcp, temp] => [norm_snw, norm_slw, norm_prcp, norm_temp],\n        [snowpack_mean, soilwater_mean, prcp_mean, temp_mean, snowpack_std, soilwater_std, prcp_std, temp_std],\n        exprs=[(var - mean) / std for (var, mean, std) in zip([snowpack, soilwater, prcp, temp],\n            [snowpack_mean, soilwater_mean, prcp_mean, temp_mean],\n            [snowpack_std, soilwater_std, prcp_std, temp_std]\n        )]),\n    ep_nn_flux,\n    q_nn_flux\n]\nstate_expr = rainfall + melt - step_func(soilwater) * lday * exp(log_evap_div_lday) - step_func(soilwater) * exp(log_flow)\nsoil_dfluxes = [StateFlux([soilwater, rainfall, melt, lday, log_evap_div_lday, log_flow], soilwater, expr=state_expr)]\nsoil_ele = HydroBucket(name=:m50_soil, fluxes=soil_fluxes, dfluxes=soil_dfluxes)\nconvert_flux = HydroFlux([log_flow] => [flow], exprs=[exp(log_flow)])\n# define the Exp-Hydro model\nm50_model = HydroModel(name=:m50, components=[snow_ele, soil_ele, convert_flux]);","category":"page"},{"location":"implements/build_m50_model_en/","page":"construct the M50 Model","title":"construct the M50 Model","text":"In the code above, we present a complete implementation of the M50 model, starting with the Snowpack Bucket implementation from ExpHydro, followed by the Soilwater Bucket implementation with neural network embedding. In the Soilwater Bucket module implementation, we can use defined NeuralFlux (ep_nn_flux and q_nn_flux) to express embedded neural networks, combining them with other HydroFlux components and using StateFlux to construct the Soilwater Bucket.","category":"page"},{"location":"extent/why_not_MTK_en/#HydroModels.jl-and-ModelingToolkit.jl","page":"Why not using ModelingToolkit.jl directly","title":"HydroModels.jl and ModelingToolkit.jl","text":"","category":"section"},{"location":"extent/why_not_MTK_en/#Why-Not-Use-[ModelingToolkit.jl](https://github.com/SciML/ModelingToolkit.jl)-Directly","page":"Why not using ModelingToolkit.jl directly","title":"Why Not Use ModelingToolkit.jl Directly","text":"","category":"section"},{"location":"extent/why_not_MTK_en/","page":"Why not using ModelingToolkit.jl directly","title":"Why not using ModelingToolkit.jl directly","text":"The design philosophy of HydroModels.jl is actually completely aligned with ModelingToolkit.jl. Both frameworks use Symbolics.jl for symbolic computation. ModelingToolkit.jl is a more general symbolic system that supports the construction of various problems, and ModelingToolkitStandardLibrary.jl provides support for basic components in specific domains.","category":"page"},{"location":"extent/why_not_MTK_en/","page":"Why not using ModelingToolkit.jl directly","title":"Why not using ModelingToolkit.jl directly","text":"However, I encountered several issues when using ModelingToolkit.jl:","category":"page"},{"location":"extent/why_not_MTK_en/","page":"Why not using ModelingToolkit.jl directly","title":"Why not using ModelingToolkit.jl directly","text":"Although ModelingToolkit.jl can express the ordinary differential equations of hydrological models through symbolic programming, its support for calculations like unit hydrograph and routing processes in hydrological models is not particularly ideal\nWithin the same module, such as evaporation calculation formulas and soil calculation modules, the modules needed for different regions may differ due to different formulas, requiring separate construction of calculation formulas to support model building\nHydrological models typically include multiple ordinary differential equations. Using a single ODESystem becomes relatively chaotic, while using multiple ODESystems becomes relatively complex\nAdditionally, ODESystem may not directly support multi-node input and spatial routing process calculations\nAlthough ModelingToolkitNeuralNets.jl exists for neural network model embedding, the integration is not as straightforward as imagined\nI also encountered issues with automatic differentiation support based on ModelingToolkit.jl, especially with Zygote.jl","category":"page"},{"location":"extent/why_not_MTK_en/","page":"Why not using ModelingToolkit.jl directly","title":"Why not using ModelingToolkit.jl directly","text":"Therefore, I decided to build my own model library, referencing the symbolic programming model construction approach, to better support the modeling needs of hydrological models.","category":"page"},{"location":"extent/why_not_MTK_en/#Future-Work","page":"Why not using ModelingToolkit.jl directly","title":"Future Work","text":"","category":"section"},{"location":"extent/why_not_MTK_en/","page":"Why not using ModelingToolkit.jl directly","title":"Why not using ModelingToolkit.jl directly","text":"It's undeniable that ModelingToolkit.jl is an excellent framework. After meeting the requirements of hydrological models, I will try to make the modules in HydroModels.jl become similar modules in ModelingToolkitStandardLibrary.jl, and inherit the support of ModelingToolkit.jl's AbstractSystem class to provide consistent functional support, thereby maintaining compatibility with more computational capabilities in the SciML ecosystem.","category":"page"},{"location":"extent/framework comparision_zh/#比较superflexpy,-MARRMoT-和-HydroModels.jl三种库对于自定义模型的编程风格","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"","category":"section"},{"location":"extent/framework comparision_zh/","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"本内容对应了论文的4.1节的内容,我们在这里希望能够讨论三种软件库对于模型计算公式的自定义的编程风格的差异. 我们以GR4J模型的实习过程为例,对模型计算公式的自定义的编程风格进行比较.","category":"page"},{"location":"extent/framework comparision_zh/#[Superflexpy](https://github.com/dalmo1991/superflexPy/tree/master)","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"Superflexpy","text":"","category":"section"},{"location":"extent/framework comparision_zh/","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"Superflexpy是基于SUPERFLEX思想下的python代码实现, 针对于水文模型中一些计算功能的实现, 该框架一般而言是直接使用python语法表述模型的计算公式, 如下所示.","category":"page"},{"location":"extent/framework comparision_zh/","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"@staticmethod\ndef _flux_function_python(S, S0, ind, P, x1, alpha, beta, ni, PET, dt):\n    if ind is None:\n        return (\n            [\n                P * (1 - (S / x1) ** alpha), # Ps\n                -PET * (2 * (S / x1) - (S / x1) ** alpha), # Evaporation\n                -((x1 ** (1 - beta)) / ((beta - 1) * dt)) * (ni ** (beta - 1)) * (S**beta), # Perc\n            ],\n            0.0,\n            S0 + P * (1 - (S / x1) ** alpha) * dt,\n        )\n    else:\n        return (\n            [\n                P[ind] * (1 - (S / x1[ind]) ** alpha[ind]), # Ps\n                -PET[ind] * (2 * (S / x1[ind]) - (S / x1[ind]) ** alpha[ind]), # Evaporation\n                -((x1[ind] ** (1 - beta[ind])) / ((beta[ind] - 1) * dt[ind]))\n                * (ni[ind] ** (beta[ind] - 1))\n                * (S ** beta[ind]), # Perc\n            ],\n            0.0,\n            S0 + P[ind] * (1 - (S / x1[ind]) ** alpha[ind]) * dt[ind],\n            [\n                -(P[ind] * alpha[ind] / x1[ind]) * ((S / x1[ind]) ** (alpha[ind] - 1)),\n                -(PET[ind] / x1[ind]) * (2 - alpha[ind] * ((S / x1[ind]) ** (alpha[ind] - 1))),\n                -beta[ind]\n                * ((x1[ind] ** (1 - beta[ind])) / ((beta[ind] - 1) * dt[ind]))\n                * (ni[ind] ** (beta[ind] - 1))\n                * (S ** (beta[ind] - 1)),\n            ],\n        )\n\n@staticmethod\n@nb.jit(\n    \"Tuple((UniTuple(f8, 3), f8, f8, UniTuple(f8, 3)))\"\n    \"(optional(f8), f8, i4, f8[:], f8[:], f8[:], f8[:], f8[:], f8[:], f8[:])\",\n    nopython=True,\n)\ndef _flux_function_numba(S, S0, ind, P, x1, alpha, beta, ni, PET, dt):\n    return (\n        (\n            P[ind] * (1 - (S / x1[ind]) ** alpha[ind]),  # Ps\n            -PET[ind] * (2 * (S / x1[ind]) - (S / x1[ind]) ** alpha[ind]),  # Evaporation\n            -((x1[ind] ** (1 - beta[ind])) / ((beta[ind] - 1) * dt[ind]))\n            * (ni[ind] ** (beta[ind] - 1))\n            * (S ** beta[ind]),  # Perc\n        ),\n        0.0,\n        S0 + P[ind] * (1 - (S / x1[ind]) ** alpha[ind]) * dt[ind],\n        (\n            -(P[ind] * alpha[ind] / x1[ind]) * ((S / x1[ind]) ** (alpha[ind] - 1)),\n            -(PET[ind] / x1[ind]) * (2 - alpha[ind] * ((S / x1[ind]) ** (alpha[ind] - 1))),\n            -beta[ind]\n            * ((x1[ind] ** (1 - beta[ind])) / ((beta[ind] - 1) * dt[ind]))\n            * (ni[ind] ** (beta[ind] - 1))\n            * (S ** (beta[ind] - 1)),\n        ),\n    )","category":"page"},{"location":"extent/framework comparision_zh/","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"可以看出, superflexpy框架在实现GR4J的production模块计算时origin code,不仅需要分别构建numpy和numba的计算代码,在函数中需要给出模型中涉及的水文通量Ps,Evaporation,Perc,同时还要给出状态变量的平衡方程,一个代码中需要耦合多个计算过程的实现代码,不仅导致代码的复用的灵活性较差(仅能在模块层面进行复用),模型编写的代码量和重复度也较高.","category":"page"},{"location":"extent/framework comparision_zh/#[MARRMoT](https://github.com/wknoben/MARRMoT)","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"MARRMoT","text":"","category":"section"},{"location":"extent/framework comparision_zh/","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"MARRMoT是一个由MATLAB语言开发的水文模型框架,该框架根据不同水文模型会分别构建模型类型,储存模型涉及的计算公式和状态变化方程,GR4J模型在该框架下的实现代码(简化了变量命名)如下所示.","category":"page"},{"location":"extent/framework comparision_zh/","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"function [dS, fluxes] = model_fun(obj, S)\n    % definitions\n    ...\n    % fluxes functions\n    flux_pn   = max(P-Ep,0);\n    flux_en   = max(Ep-P,0);\n    flux_ef   = P - flux_pn;\n    flux_ps   = saturation_4(S1,x1,flux_pn);\n    flux_es   = evap_11(S1,x1,flux_en);\n    flux_perc = percolation_3(S1,x1);\n    flux_q9   = route(.9.*(flux_pn - flux_ps + flux_perc), uh_q9);\n    flux_q1   = route(.1.*(flux_pn - flux_ps + flux_perc), uh_q1);\n    flux_fr   = recharge_2(3.5,S2,x3,x2);\n    flux_fq   = flux_fr;\n    flux_qr   = baseflow_3(S2,x3);\n    flux_qt   = flux_qr + max(flux_q1 + flux_fq,0);\n    % this flux is not included in original MARRMoT,\n    % but it is useful to calculate the water balance\n    flux_ex = flux_fr + max(flux_q1 + flux_fq,0) - flux_q1;      \n    % stores ODEs\n    dS1 = flux_ps - flux_es - flux_perc;\n    dS2 = flux_q9 + flux_fr - flux_qr;\n    % outputs\n    dS = [dS1 dS2];\n    fluxes = [flux_pn,   flux_en, flux_ef, flux_ps, flux_es,...\n                flux_perc, flux_q9, flux_q1, flux_fr, flux_fq,...\n                flux_qr,   flux_qt, flux_ex];\nend","category":"page"},{"location":"extent/framework comparision_zh/","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"可以看出,MARRMoT框架将每一个Flux计算公式由函数进行表达,因此使用者可以直接调取函数进行计算(可以根据提供的文档进行调用),这种方式相比superflexpy的确简化了很多代码编写需求. 然而MARRMoT对于模块的重复率支持性较差,不能够像superflexpy那样进行复用. 同时将变量赋值,通量计算和状态变化方程以一个函数包括,计算内容的解耦性较差.","category":"page"},{"location":"extent/framework comparision_zh/#HydroModels.jl","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"HydroModels.jl","text":"","category":"section"},{"location":"extent/framework comparision_zh/","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"#* define the production store\nprod_funcs = [\n    HydroFlux([prcp, ep] => [pn, en], exprs=[prcp - min(prcp, ep), ep - min(prcp, ep)]),\n    HydroFlux([pn, soilwater] => [ps], [x1], exprs=[max(0.0, pn * (1 - (soilwater / x1)^2))]),\n    HydroFlux([en, soilwater] => [es], [x1], exprs=[en * (2 * soilwater / x1 - (soilwater / x1)^2)]),\n    HydroFlux([soilwater] => [perc], [x1], exprs=[((x1)^(-4)) / 4 * ((4 / 9)^(4)) * (soilwater^5)]),\n    HydroFlux([pn, ps, perc] => [pr], exprs=[pn - ps + perc]),\n    HydroFlux([pr] => [slowflow, fastflow], exprs=[0.9 * pr, 0.1 * pr]),\n]\nprod_dfuncs = [StateFlux([ps] => [es, perc], soilwater)]\nprod_ele = HydroBucket(name=:gr4j_prod, funcs=prod_funcs, dfuncs=prod_dfuncs)\n\n#* uh function\nuh_flux_1 = HydroModels.UnitHydrograph([slowflow] => [slowflow_routed], x4, uhfunc=HydroModels.UHFunction(:UH_1_HALF), solvetype=:SPARSE)\nuh_flux_2 = HydroModels.UnitHydrograph([fastflow] => [fastflow_routed], x4, uhfunc=HydroModels.UHFunction(:UH_2_FULL), solvetype=:SPARSE)\n\n#* define the routing store\nrst_funcs = [\n    HydroFlux([routingstore] => [exch], [x2, x3], exprs=[x2 * abs(routingstore / x3)^3.5]),\n    HydroFlux([routingstore, slowflow, exch] => [routedflow], [x3], exprs=[x3^(-4) / 4 * (routingstore + slowflow + exch)^5]),\n    HydroFlux([routedflow, fastflow_routed, exch] => [flow], exprs=[routedflow + max(fastflow_routed + exch, 0.0)]),\n]\nrst_dfuncs = [StateFlux([exch, slowflow] => [routedflow], routingstore)]\nrst_ele = HydroBucket(name=:gr4j_rst, funcs=rst_funcs, dfuncs=rst_dfuncs)\n\ngr4j_model = HydroModel(name=:gr4j, components=[prod_ele, uh_flux_1, uh_flux_2, rst_ele])","category":"page"},{"location":"extent/framework comparision_zh/","page":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","title":"比较superflexpy, MARRMoT 和 HydroModels.jl三种库对于自定义模型的编程风格","text":"回到HydroModels.jl框架中对于GR4J模型的实现, 在该代码中我们依次对production store, unit hydrograph, routing store进行了定义, 在这个过程中,在变量对应的前提下,模型能够实现可复用的能力. 在这个搭建过程中, 包括HydroFlux, StateFlux, UnitHydrograph, HydroModel, HydroBucket等类的实例化,这些类型的实例化方式不是像前两者一样使用函数的方式构建的, 而是通过符号编程的方式对计算公式进行表达, 在模型构建完成后是通过输入数据和参数进行模型计算,可以看出这种设计思路是将模型结构与公式同参数和数据完全解耦,有着极高的可复用性.","category":"page"},{"location":"implements/build_exphydro_model_en/#Build-an-ExpHydro-Model","page":"construct the ExpHydro Model","title":"Build an ExpHydro Model","text":"","category":"section"},{"location":"implements/build_exphydro_model_en/#Introduction-to-ExpHydro-Model","page":"construct the ExpHydro Model","title":"Introduction to ExpHydro Model","text":"","category":"section"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"This section demonstrates how to build a simple hydrological model - the ExpHydro model - using HydroModels.jl, serving as an introduction to conceptual model construction. The ExpHydro model consists of two computational modules: the Snowpack Bucket and the Soilwater Bucket. Their mathematical formulations are as follows:","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"beginaligned\n textSnowpack Bucket \n pet = 298 cdot lday cdot 24 cdot 0611 cdot fracexp(173 cdot temp)temp + 2373 cdot frac1temp + 2732  (1) \n snowfall = H(T_min - temp) cdot prcp  (2) \n rainfall = H(temp - T_min) cdot prcp  (3) \n melt = H(temp - T_max) cdot H(snowpack) cdot min(snowpack D_f cdot (temp - T_max))  (4) \n fracd(snowpack)dt = snowfall - melt  (5) \n\n textSoilwater Bucket \n evap = H(soilwater) cdot pet cdot min(10 fracsoilwaterS_max)  (6) \n baseflow = H(soilwater) cdot Q_max cdot exp(-f cdot max(00 S_max - soilwater))  (7) \n surfaceflow = max(00 soilwater - S_max)  (8) \n flow = baseflow + surfaceflow  (9) \n fracd(soilwater)dt = rainfall + melt - evap - flow  (10)\nendaligned","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"Where: H(x) represents the Heaviside step function, equals 1 when x  0, otherwise 0; T_min T_max D_f S_max Q_max f are model parameters;temp lday prcp are input variables;snowpack soilwater are state variables;Other variables are intermediate calculation variables","category":"page"},{"location":"implements/build_exphydro_model_en/#Complete-Model-Construction-Process","page":"construct the ExpHydro Model","title":"Complete Model Construction Process","text":"","category":"section"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"# import packages\nusing HydroModels\n\n# define variables and parameters\n@variables temp lday pet prcp \n@variables snowfall rainfall melt evap baseflow surfaceflow flow\n@variables snowpack soilwater\n@parameters Tmin Tmax Df Smax Qmax f\n\nstep_func(x) = (tanh(5.0 * x) + 1.0) * 0.5\n\n# define snowpack bucket\nfluxes_1 = [\n    HydroFlux([temp, lday] => [pet], exprs=[29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)]),\n    HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp]),\n    HydroFlux([snowpack, temp] => [melt], [Tmax, Df], exprs=[step_func(temp - Tmax) * step_func(snowpack) * min(snowpack, Df * (temp - Tmax))]),\n]\ndfluxes_1 = [StateFlux([snowfall] => [melt], snowpack),]\nsnowpack_bucket = HydroBucket(name=:surface, fluxes=fluxes_1, dfluxes=dfluxes_1)\n\n# define soilwater bucket\nfluxes_2 = [\n    HydroFlux([soilwater, pet] => [evap], [Smax], exprs=[step_func(soilwater) * pet * min(1.0, soilwater / Smax)]),\n    HydroFlux([soilwater] => [baseflow], [Smax, Qmax, f], exprs=[step_func(soilwater) * Qmax * exp(-f * (max(0.0, Smax - soilwater)))]),\n    HydroFlux([soilwater] => [surfaceflow], [Smax], exprs=[max(0.0, soilwater - Smax)]),\n    HydroFlux([baseflow, surfaceflow] => [flow], exprs=[baseflow + surfaceflow]),\n]\ndfluxes_2 = [StateFlux([rainfall, melt] => [evap, flow], soilwater)]\nsoilwater_bucket = HydroBucket(name=:soil, fluxes=fluxes_2, dfluxes=dfluxes_2)\n\n# define the Exp-Hydro model\nexphydro_model = HydroModel(name=:exphydro, components=[snowpack_bucket, soilwater_bucket])","category":"page"},{"location":"implements/build_exphydro_model_en/#Step-by-Step-Analysis","page":"construct the ExpHydro Model","title":"Step-by-Step Analysis","text":"","category":"section"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"Let's break down the model construction process into detailed steps.","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"First, we need to import the HydroModels.jl dependency:","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"using HydroModels","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"By importing the HydroModels module, we gain direct access to types defined in HydroFlux, StateFlux, HydroBucket, and HydroModel modules. Additionally, the package exports macros from ModelingToolkit.jl such as @variables and @parameters, which are used for defining and manipulating variables and parameters in hydrological models:","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"@variables temp lday prcp \n@variables snowfall rainfall melt evap baseflow surfaceflow flow pet\n@variables snowpack soilwater\n@parameters Tmin Tmax Df Smax Qmax f","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"In this code segment, we define all variables used in the ExpHydro model, including:","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"Input variables: temperature (temp), day length (lday), and precipitation (prcp)\nIntermediate calculation variables: pet, snowfall, rainfall, melt, evap, baseflow, surfaceflow, flow\nState variables: snowpack and soilwater\nModel parameters: Tmin, Tmax, Df, Smax, Qmax, and f","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"The definition of HydroFlux requires determining input/output variables and model parameters based on calculation formulas. For example, in the rain-snow partitioning formula, the input variables are prcp and temp, output variables are snowfall and rainfall, and the model parameter is Tmin. The formula translation to HydroFlux looks like this:","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"# define the smooth function\nstep_func(x) = (tanh(5.0 * x) + 1.0) * 0.5\n# define the rain-snow partitioning flux\nsplit_flux = HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp])","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"The definition of StateFlux is based on the balance equation of state variables. Generally, the balance equation equates the rate of change of the state variable to the difference between input and output fluxes. For example, the balance equation for snowpack is the difference between snowfall and melt. The formula translation to StateFlux looks like this:","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"snowpack_dflux = StateFlux([snowfall] => [melt], snowpack)","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"Next, we define the model calculation formulas using HydroFlux and StateFlux, and integrate them into HydroBucket to create the Snowpack Bucket and Soilwater Bucket components:","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"# define snowpack bucket\nfluxes_1 = [\n    HydroFlux([temp, lday] => [pet], exprs=[29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)]),\n    HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp]),\n    HydroFlux([snowpack, temp] => [melt], [Tmax, Df], exprs=[step_func(temp - Tmax) * step_func(snowpack) * min(snowpack, Df * (temp - Tmax))]),\n]\ndfluxes_1 = [StateFlux([snowfall] => [melt], snowpack),]\nsnowpack_bucket = HydroBucket(name=:surface, fluxes=fluxes_1, dfluxes=dfluxes_1)\n\n# define soilwater bucket\nfluxes_2 = [\n    HydroFlux([soilwater, pet] => [evap], [Smax], exprs=[step_func(soilwater) * pet * min(1.0, soilwater / Smax)]),\n    HydroFlux([soilwater] => [baseflow], [Smax, Qmax, f], exprs=[step_func(soilwater) * Qmax * exp(-f * (max(0.0, Smax - soilwater)))]),\n    HydroFlux([soilwater] => [surfaceflow], [Smax], exprs=[max(0.0, soilwater - Smax)]),\n    HydroFlux([baseflow, surfaceflow] => [flow], exprs=[baseflow + surfaceflow]),\n]\ndfluxes_2 = [StateFlux([rainfall, melt] => [evap, flow], soilwater)]\nsoilwater_bucket = HydroBucket(name=:soil, fluxes=fluxes_2, dfluxes=dfluxes_2)","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"The construction of HydroBucket consists of HydroFlux and StateFlux, where HydroFlux defines the model's calculation formulas, and StateFlux defines the balance equations for state variables.","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"Finally, we combine the HydroBucket components into a HydroModel to create the complete ExpHydro model:","category":"page"},{"location":"implements/build_exphydro_model_en/","page":"construct the ExpHydro Model","title":"construct the ExpHydro Model","text":"# define the Exp-Hydro model\nexphydro_model = HydroModel(name=:exphydro, components=[snowpack_bucket, soilwater_bucket])","category":"page"},{"location":"implements/build_m50_model_zh/#Embedding-Neural-Networks-in-ExpHydro-Model:-Implementation-of-[M50](https://hess.copernicus.org/articles/26/5085/2022/)-Model","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"","category":"section"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"marv-in在论文中提出了M50和M100两个模型,代码储存于HydroNODE中,开创了神经网络嵌入水文模型的先河(重点在于实现神经网络替换了ExpHydro模型的计算公式,并参与到平衡方程的求解中),这个模型也是对该仓库的启蒙,我们发现当前模型编写仍存在一定难度,因此我们创建这个仓库的首要目的就是简化神经网络嵌入水文模型这个过程,下面我们将对比源代码与本仓库在M50和M100模型上的实现差异,为使用者展现出一种新的模型搭建方式.","category":"page"},{"location":"implements/build_m50_model_zh/#HydroNODE中M50的实现方法","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"HydroNODE中M50的实现方法","text":"","category":"section"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"首先我们展示了HydroNODE中M50和M100模型的实现:","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"# define the ODE problem\nfunction NeuralODE_M50_core!(dS,S,p,t)\n\n    Tmin, Tmax, Df = (p_bucket_precal...,)\n\n    Lday = itp_Lday(t)\n    P    = itp_P(t)\n    T    = itp_T(t)\n\n    g_ET = ann_ET([norm_S0(S[1]), norm_S1(S[2]), norm_T(T)],p[:p1]) #p[idcs_params_ann_ET])\n    g_Q = ann_Q([norm_S1(S[2]), norm_P(P)],p[:p2]) #p[idcs_params_ann_Q])\n\n    melting = M(S[1], T, Df, Tmax)\n    dS[1] = Ps(P, T, Tmin) - melting\n    dS[2] = Pr(P, T, Tmin) + melting - step_fct(S[2])*Lday*exp(g_ET[1])- step_fct(S[2])*exp(g_Q[1])\n\nend\n# build and solve ODE problem\nprob = ODEProblem(NeuralODE_M50_core!, S_init, Float64.((t_out[1], maximum(t_out))), p)\nsol = solve(prob, BS3(), dt=1.0, saveat=t_out, reltol=1e-3, abstol=1e-3, sensealg=BacksolveAdjoint(autojacvec=ZygoteVJP()))\n# calculate Qout\nP_interp = norm_P.(itp_P.(t_out))\nS1_ = norm_S1.(sol[2,:])\nQout_ =  exp.(ann_Q(permutedims([S1_ P_interp]),p[:p2])[1,:])","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"在HydroNODE的代码中可以看出,模型构建分为以下三个步骤:","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"ODE函数的定义\nODE问题的构建与求解\n以及根据求解的中间状态计算Qout","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"这个代码的构建风格遵循了最标准的DifferentialEquations.jl库的风格,然而这个代码中需要手动搭建模型的计算公式(M,Ps,Pr)并与状态方程表达式组合在一起(dS),模型的耦合性极高,同时,为获取Qout等中间计算通量,还需要额外调用对应的计算公式,代码编写的繁琐性相对较高.","category":"page"},{"location":"implements/build_m50_model_zh/#HydroModels.jl中M50的实现方法","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"HydroModels.jl中M50的实现方法","text":"","category":"section"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"首先需要定义M50模型中设计的参数和变量:","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"using HydroModels\n\n#! parameters in the Exp-Hydro model\n@parameters Tmin Tmax Df Smax f Qmax\n#! parameters in normalize flux\n@parameters snowpack_std snowpack_mean\n@parameters soilwater_std soilwater_mean\n@parameters prcp_std prcp_mean\n@parameters temp_std temp_mean\n\n#! hydrological flux in the Exp-Hydro model\n@variables prcp temp lday pet rainfall snowfall\n@variables snowpack soilwater lday pet\n@variables melt log_evap_div_lday log_flow flow\n@variables norm_snw norm_slw norm_temp norm_prcp\n\nstep_func(x) = (tanh(5.0 * x) + 1.0) * 0.5","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"相比较普通的概念式水文模型,M50模型使用神经网络模型替换了水文通量的计算公式(ET和Q),这个神经网络相比普通的计算公式有着明显的差异,因此在HydroModels.jl中采用了NeuralFlux来表示神经网络, 用于ET和Q预测的NeuralFlux如下表示:","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"# define the ET NN and Q NN\nep_nn = Lux.Chain(\n    Lux.Dense(3 => 16, tanh),\n    Lux.Dense(16 => 16, leakyrelu),\n    Lux.Dense(16 => 1, leakyrelu),\n    name=:epnn\n)\nep_nn_params = Vector(ComponentVector(first(Lux.setup(StableRNGs.LehmerRNG(1234), ep_nn))))\nq_nn = Lux.Chain(\n    Lux.Dense(2 => 16, tanh),\n    Lux.Dense(16 => 16, leakyrelu),\n    Lux.Dense(16 => 1, leakyrelu),\n    name=:qnn\n)\nq_nn_params = Vector(ComponentVector(first(Lux.setup(StableRNGs.LehmerRNG(1234), q_nn))))\n\n\nep_nn_flux = NeuralFlux([norm_snw, norm_slw, norm_temp] => [log_evap_div_lday], ep_nn)\nq_nn_flux = NeuralFlux([norm_slw, norm_prcp] => [log_flow], q_nn)","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"构建M50模型相对特殊的一点在于需要针对嵌入的神经网络使用NeuralFlux模型进行包装,为神经网络赋予输入输出的信息,并在构建过程中将神经网络转换为表达式.","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"然后我们可以构建M50模型的其余部分:","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"# define the snow pack reservoir\nsnow_fluxes = [\n    HydroFlux([temp, lday] => [pet], exprs=[29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)]),\n    HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp]),\n    HydroFlux([snowpack, temp] => [melt], [Tmax, Df], exprs=[step_func(temp - Tmax) * min(snowpack, Df * (temp - Tmax))]),\n]\nsnow_dfluxes = [StateFlux([snowfall] => [melt], snowpack)]\nsnow_ele = HydroBucket(name=:exphydro_snow, fluxes=snow_fluxes, dfluxes=snow_dfluxes)\n\n# define the soil water reservoir\nsoil_fluxes = [\n    #* normalize\n    HydroFlux([snowpack, soilwater, prcp, temp] => [norm_snw, norm_slw, norm_prcp, norm_temp],\n        [snowpack_mean, soilwater_mean, prcp_mean, temp_mean, snowpack_std, soilwater_std, prcp_std, temp_std],\n        exprs=[(var - mean) / std for (var, mean, std) in zip([snowpack, soilwater, prcp, temp],\n            [snowpack_mean, soilwater_mean, prcp_mean, temp_mean],\n            [snowpack_std, soilwater_std, prcp_std, temp_std]\n        )]),\n    ep_nn_flux,\n    q_nn_flux\n]\nstate_expr = rainfall + melt - step_func(soilwater) * lday * exp(log_evap_div_lday) - step_func(soilwater) * exp(log_flow)\nsoil_dfluxes = [StateFlux([soilwater, rainfall, melt, lday, log_evap_div_lday, log_flow], soilwater, expr=state_expr)]\nsoil_ele = HydroBucket(name=:m50_soil, fluxes=soil_fluxes, dfluxes=soil_dfluxes)\nconvert_flux = HydroFlux([log_flow] => [flow], exprs=[exp(log_flow)])\n# define the Exp-Hydro model\nm50_model = HydroModel(name=:m50, components=[snow_ele, soil_ele, convert_flux]);","category":"page"},{"location":"implements/build_m50_model_zh/","page":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","title":"Embedding Neural Networks in ExpHydro Model: Implementation of M50 Model","text":"上述代码中我们对M50模型进行了一个完整的表现,首先包括ExpHydro中Snowpack Bucket的实现,其次就是对于神经网络嵌入后Soilwater Bucket的实现. 在Soilwater Bucket模块实现中,可以通过定义的NeuralFlux(ep_nn_flux和q_nn_flux)来表达嵌入的神经网络,并与其他HydroFlux进行组合,结合StateFlux构建Soilwater Bucket.","category":"page"},{"location":"implements/build_exphydro_model_zh/#构建ExpHydro模型","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"","category":"section"},{"location":"implements/build_exphydro_model_zh/#ExpHydro模型介绍","page":"构建ExpHydro模型","title":"ExpHydro模型介绍","text":"","category":"section"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"本节将基于 HydroModels.jl 构建一个结构较为简单的水文模型-ExpHydro 模型,以此来开启概念式模型搭建的教程。 首先对 ExpHydro 模型进行介绍,该模型由 Snowpack Bucket 和 Soilwater Bucket 两个计算模块组成,其计算公式如下：","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"beginaligned\n textSnowpack Bucket \n pet = 298 cdot lday cdot 24 cdot 0611 cdot fracexp(173 cdot temp)temp + 2373 cdot frac1temp + 2732  (1) \n snowfall = H(T_min - temp) cdot prcp  (2) \n rainfall = H(temp - T_min) cdot prcp  (3) \n melt = H(temp - T_max) cdot H(snowpack) cdot min(snowpack D_f cdot (temp - T_max))  (4) \n fracd(snowpack)dt = snowfall - melt  (5) \n\n textSoilwater Bucket \n evap = H(soilwater) cdot pet cdot min(10 fracsoilwaterS_max)  (6) \n baseflow = H(soilwater) cdot Q_max cdot exp(-f cdot max(00 S_max - soilwater))  (7) \n surfaceflow = max(00 soilwater - S_max)  (8) \n flow = baseflow + surfaceflow  (9) \n fracd(soilwater)dt = rainfall + melt - evap - flow  (10)\nendaligned","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"其中:","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"H(x)\n表示Heaviside阶跃函数，当 x  0 时为1，否则为0\nT_min T_max D_f S_max Q_max f\n为模型参数\ntemp lday prcp\n为输入变量\nsnowpack soilwater\n为状态变量\n其余变量为中间计算变量","category":"page"},{"location":"implements/build_exphydro_model_zh/#完整的模型构建过程","page":"构建ExpHydro模型","title":"完整的模型构建过程","text":"","category":"section"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"# import packages\nusing HydroModels\n\n# define variables and parameters\n@variables temp lday pet prcp \n@variables snowfall rainfall melt evap baseflow surfaceflow flow\n@variables snowpack soilwater\n@parameters Tmin Tmax Df Smax Qmax f\n\n# define step function\nstep_func(x) = (tanh(5.0 * x) + 1.0) * 0.5\n\n# define snowpack bucket\nfluxes_1 = [\n    HydroFlux([temp, lday] => [pet], exprs=[29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)]),\n    HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp]),\n    HydroFlux([snowpack, temp] => [melt], [Tmax, Df], exprs=[step_func(temp - Tmax) * step_func(snowpack) * min(snowpack, Df * (temp - Tmax))]),\n]\ndfluxes_1 = [StateFlux([snowfall] => [melt], snowpack),]\nsnowpack_bucket = HydroBucket(name=:surface, fluxes=fluxes_1, dfluxes=dfluxes_1)\n\n# define soilwater bucket\nfluxes_2 = [\n    HydroFlux([soilwater, pet] => [evap], [Smax], exprs=[step_func(soilwater) * pet * min(1.0, soilwater / Smax)]),\n    HydroFlux([soilwater] => [baseflow], [Smax, Qmax, f], exprs=[step_func(soilwater) * Qmax * exp(-f * (max(0.0, Smax - soilwater)))]),\n    HydroFlux([soilwater] => [surfaceflow], [Smax], exprs=[max(0.0, soilwater - Smax)]),\n    HydroFlux([baseflow, surfaceflow] => [flow], exprs=[baseflow + surfaceflow]),\n]\ndfluxes_2 = [StateFlux([rainfall, melt] => [evap, flow], soilwater)]\nsoilwater_bucket = HydroBucket(name=:soil, fluxes=fluxes_2, dfluxes=dfluxes_2)\n\n# define the Exp-Hydro model\nexphydro_model = HydroModel(name=:exphydro, components=[snowpack_bucket, soilwater_bucket])","category":"page"},{"location":"implements/build_exphydro_model_zh/#分段剖析","page":"构建ExpHydro模型","title":"分段剖析","text":"","category":"section"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"接下来我们将分块对模型构建过程进行介绍.","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"首先需要引入HydroModels.jl的依赖:","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"using HydroModels","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"通过导入HydroModels模块,可以直接访问HydroFlux,StateFlux,HydroBucket,HydroModel等模块定义的类型,同时还该包导出了ModelingToolkit.jl包中@variables,@parameters等宏,可以用于水文模型中变量和参数的定义和操作, 如下所示:","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"@variables temp lday prcp \n@variables snowfall rainfall melt evap baseflow surfaceflow flow pet\n@variables snowpack soilwater\n@parameters Tmin Tmax Df Smax Qmax f","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"在这段代码中,需要将ExpHydro模型中所有变量进行定义,包括输入变量温度(temp),日照时长(lday)和降水(prcp),同时给出了ExpHydro模型中所有变量的中间计算变量,如pet, snowfall, rainfall, melt, evap, baseflow, surfaceflow, flow等,以及ExpHydro模型的状态变量snowpack和soilwater,以及ExpHydro模型的参数Tmin, Tmax, Df, Smax, Qmax和f.","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"HydroFlux的定义需要根据计算公式确定模型的输入输出变量和模型参数,例如在模型的雨雪划分计算公式,该公式的输入变量为prcp和temp,输出变量为snowfall和rainfall,模型参数为Tmin, 公式转译为HydroFlux的结果如下所示:","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"# 定义平滑函数\nstep_func(x) = (tanh(5.0 * x) + 1.0) * 0.5\n# 定义雨雪划分函数\nsplit_flux = HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp])","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"StateFlux的定义是根据状态变量的平衡方程, 一般来说平衡方程是状态变量的变化率等于输入输出通量的差值得到,例如snowpack的平衡方程是snowfall和melt的差值, 公式转译为StateFlux的结果如下所示:","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"snowpack_dflux = StateFlux([snowfall] => [melt], snowpack)","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"接着根据模型计算公式通过HydroFlux和StateFlux进行定义, 并将其整合为HydroBucket,得到Snowpack Bucket和Soilwater Bucket如下所示:","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"# define snowpack bucket\nfluxes_1 = [\n    HydroFlux([temp, lday] => [pet], exprs=[29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)]),\n    HydroFlux([prcp, temp] => [snowfall, rainfall], [Tmin], exprs=[step_func(Tmin - temp) * prcp, step_func(temp - Tmin) * prcp]),\n    HydroFlux([snowpack, temp] => [melt], [Tmax, Df], exprs=[step_func(temp - Tmax) * step_func(snowpack) * min(snowpack, Df * (temp - Tmax))]),\n]\ndfluxes_1 = [StateFlux([snowfall] => [melt], snowpack),]\nsnowpack_bucket = HydroBucket(name=:surface, fluxes=fluxes_1, dfluxes=dfluxes_1)\n\n# define soilwater bucket\nfluxes_2 = [\n    HydroFlux([soilwater, pet] => [evap], [Smax], exprs=[step_func(soilwater) * pet * min(1.0, soilwater / Smax)]),\n    HydroFlux([soilwater] => [baseflow], [Smax, Qmax, f], exprs=[step_func(soilwater) * Qmax * exp(-f * (max(0.0, Smax - soilwater)))]),\n    HydroFlux([soilwater] => [surfaceflow], [Smax], exprs=[max(0.0, soilwater - Smax)]),\n    HydroFlux([baseflow, surfaceflow] => [flow], exprs=[baseflow + surfaceflow]),\n]\ndfluxes_2 = [StateFlux([rainfall, melt] => [evap, flow], soilwater)]\nsoilwater_bucket = HydroBucket(name=:soil, fluxes=fluxes_2, dfluxes=dfluxes_2)","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"HydroBucket的构建由HydroFlux和StateFlux组成, 其中HydroFlux用于定义模型的计算公式,StateFlux用于定义状态变量的平衡方程.","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"最后将HydroBucket组合成HydroModel,作为components输入到模型中,得到ExpHydro模型如下所示:","category":"page"},{"location":"implements/build_exphydro_model_zh/","page":"构建ExpHydro模型","title":"构建ExpHydro模型","text":"# define the Exp-Hydro model\nexphydro_model = HydroModel(name=:exphydro, components=[snowpack_bucket, soilwater_bucket])","category":"page"},{"location":"framework_concepts/#Understanding-DeepFlex.jl-Framework-Concepts","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"","category":"section"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"This document aims to clarify the core concepts of the DeepFlex.jl framework, focusing on the three fundamental components: Flux, Element/Bucket, and Model. Understanding these components and their relationships is essential for effectively using the framework to build hydrological models.","category":"page"},{"location":"framework_concepts/#Framework-Architecture-Overview","page":"Understanding DeepFlex.jl Framework Concepts","title":"Framework Architecture Overview","text":"","category":"section"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"DeepFlex.jl is built on a modular architecture that enables flexible hydrological model construction. The framework is designed around three core components that work together to create comprehensive hydrological simulations:","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"Flux: The basic computational units that define mathematical relationships\nElement/Bucket: Storage components that integrate multiple fluxes and manage state variables\nModel: The top-level structure that combines all components into a complete simulation system","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"This hierarchical design allows for both simple conceptual models and complex physically-based or hybrid models to be constructed using the same framework.","category":"page"},{"location":"framework_concepts/#Flux:-The-Building-Blocks","page":"Understanding DeepFlex.jl Framework Concepts","title":"Flux: The Building Blocks","text":"","category":"section"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"Fluxes are the fundamental computational units in DeepFlex.jl. They define the mathematical relationships between variables in a hydrological system. There are three main types of flux components:","category":"page"},{"location":"framework_concepts/#1.-HydroFlux","page":"Understanding DeepFlex.jl Framework Concepts","title":"1. HydroFlux","text":"","category":"section"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"HydroFlux represents a simple mathematical relationship between input and output variables. It uses symbolic expressions to define how outputs are calculated from inputs.","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"Key characteristics:","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"Defines explicit mathematical formulas\nHandles parameter-based calculations\nSupports both single-node and multi-node simulations\nType-stable implementation for computational efficiency","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"Example:","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"# Define a simple rainfall-runoff relationship\nrainfall_flux = @hydroflux runoff ~ k * rainfall","category":"page"},{"location":"framework_concepts/#2.-StateFlux","page":"Understanding DeepFlex.jl Framework Concepts","title":"2. StateFlux","text":"","category":"section"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"StateFlux defines how state variables change over time. These are used to create differential equations that are solved during simulation.","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"Key characteristics:","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"Defines state variable dynamics (dS/dt)\nForms the basis of ordinary differential equations (ODEs)\nIntegrates with ODE solvers for time evolution\nEssential for water balance calculations","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"Example:","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"# Define how soil moisture changes over time\nsoil_flux = @stateflux soilwater ~ rainfall - evaporation - runoff","category":"page"},{"location":"framework_concepts/#3.-NeuralFlux","page":"Understanding DeepFlex.jl Framework Concepts","title":"3. NeuralFlux","text":"","category":"section"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"NeuralFlux integrates neural networks into the hydrological modeling framework. This allows for data-driven components to be seamlessly combined with process-based equations.","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"Key characteristics:","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"Connects neural networks to hydrological processes\nEnables hybrid modeling approaches\nMaintains the same interface as traditional fluxes\nSupports Lux.jl neural network models","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"Example:","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"# Define a neural network-based evaporation model\nevap_nn = Chain(Dense(3 => 16, tanh), Dense(16 => 1))\nevap_flux = @neuralflux evaporation ~ evap_nn([temperature, humidity, radiation])","category":"page"},{"location":"framework_concepts/#Element/Bucket:-The-Storage-Components","page":"Understanding DeepFlex.jl Framework Concepts","title":"Element/Bucket: The Storage Components","text":"","category":"section"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"Elements are higher-level components that integrate multiple fluxes and manage state variables. The primary type of element in DeepFlex.jl is the Bucket.","category":"page"},{"location":"framework_concepts/#HydroBucket","page":"Understanding DeepFlex.jl Framework Concepts","title":"HydroBucket","text":"","category":"section"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"A HydroBucket represents a storage component with state variables that change over time according to input and output fluxes. It encapsulates both water movement processes and state evolution equations.","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"Key characteristics:","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"Integrates multiple flux components\nManages state variables and their dynamics\nHandles ODE solving for time evolution\nSupports both single-node and distributed (multi-node) simulations\nAutomatically generates optimized functions for calculations","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"Example:","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"# Define a snow accumulation and melt bucket\nsnow_bucket = @hydrobucket :snow begin\n    fluxes = begin\n        @hydroflux snowfall ~ step_func(Tmin - temp) * prcp\n        @hydroflux rainfall ~ step_func(temp - Tmin) * prcp\n        @hydroflux melt ~ step_func(temp - Tmax) * step_func(snowpack) * min(snowpack, Df * (temp - Tmax))\n    end\n    dfluxes = begin\n        @stateflux snowpack ~ snowfall - melt\n    end\nend","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"In this example, the snow bucket:","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"Calculates snowfall, rainfall, and snowmelt fluxes\nDefines how the snowpack state variable changes over time\nAutomatically handles the integration of these processes during simulation","category":"page"},{"location":"framework_concepts/#HydroRoute","page":"Understanding DeepFlex.jl Framework Concepts","title":"HydroRoute","text":"","category":"section"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"Another type of element is HydroRoute, which handles water routing through a network of connected nodes.","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"Key characteristics:","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"Manages flow calculations and inter-node water transfer\nSupports network-based routing\nHandles both local flow calculations and downstream routing\nCan incorporate parameter-based or neural network-based routing schemes","category":"page"},{"location":"framework_concepts/#Model:-The-Integration-Framework","page":"Understanding DeepFlex.jl Framework Concepts","title":"Model: The Integration Framework","text":"","category":"section"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"The HydroModel is the top-level structure that integrates multiple components (fluxes and elements) into a complete simulation system.","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"Key characteristics:","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"Combines multiple components into a cohesive system\nAutomatically handles connections between components\nDetermines the correct execution order based on dependencies\nManages data flow between components\nProvides a unified interface for simulation","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"Example:","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"# Create a complete hydrological model\ncomplete_model = @hydromodel :watershed_model begin\n    snow_bucket\n    soil_bucket\n    routing_component\nend","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"The model automatically:","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"Analyzes dependencies between components\nCreates a computational graph for efficient execution\nManages state variables across the entire model\nPrepares the model for simulation with various solver options","category":"page"},{"location":"framework_concepts/#How-Components-Work-Together","page":"Understanding DeepFlex.jl Framework Concepts","title":"How Components Work Together","text":"","category":"section"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"The power of DeepFlex.jl comes from how these components work together:","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"Fluxes define the mathematical relationships and processes\nBuckets/Elements integrate these fluxes and manage state variables\nModels combine multiple elements into a complete simulation system","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"This hierarchical structure allows for:","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"Modular model construction\nFlexible component combination\nSeamless integration of process-based and data-driven approaches\nEfficient computation for both simple and complex models","category":"page"},{"location":"framework_concepts/#Execution-Process","page":"Understanding DeepFlex.jl Framework Concepts","title":"Execution Process","text":"","category":"section"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"When running a model in DeepFlex.jl, the following steps occur:","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"Data Preparation:\nInput data is organized as a matrix (features × time)\nParameters are provided as a ComponentVector\nInitial states are specified\nConfiguration:\nSolver selection (e.g., from DifferentialEquations.jl)\nInterpolation method (e.g., from DataInterpolations.jl)\nTime indices for output\nExecution:\nComponents are executed in dependency order\nState variables are integrated over time\nFluxes are calculated at each time step\nResults are collected and organized\nOutput:\nTime series of state variables\nTime series of output fluxes\nAdditional diagnostic information","category":"page"},{"location":"framework_concepts/#Practical-Example:-ExpHydro-Model","page":"Understanding DeepFlex.jl Framework Concepts","title":"Practical Example: ExpHydro Model","text":"","category":"section"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"To illustrate how these concepts work together, let's examine the ExpHydro model implementation:","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"# Define variables and parameters\n@variables temp lday prcp pet snowfall rainfall snowpack melt\n@variables soilwater evap baseflow surfaceflow flow\n@parameters Tmin Tmax Df Smax Qmax f\n\n# Define the snow component\nsnow_bucket = @hydrobucket :snow begin\n    fluxes = begin\n        @hydroflux pet ~ 29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)\n        @hydroflux snowfall ~ step_func(Tmin - temp) * prcp\n        @hydroflux rainfall ~ step_func(temp - Tmin) * prcp\n        @hydroflux melt ~ step_func(temp - Tmax) * step_func(snowpack) * min(snowpack, Df * (temp - Tmax))\n    end\n    dfluxes = begin\n        @stateflux snowpack ~ snowfall - melt\n    end\nend\n\n# Define the soil water component\nsoil_bucket = @hydrobucket :soil begin\n    fluxes = begin\n        @hydroflux evap ~ step_func(soilwater) * pet * min(1.0, soilwater / Smax)\n        @hydroflux baseflow ~ step_func(soilwater) * Qmax * exp(-f * (max(0.0, Smax - soilwater)))\n        @hydroflux surfaceflow ~ max(0.0, soilwater - Smax)\n        @hydroflux flow ~ baseflow + surfaceflow\n    end\n    dfluxes = begin\n        @stateflux soilwater ~ (rainfall + melt) - (evap + flow)\n    end\nend\n\n# Combine components into a complete model\nexphydro_model = @hydromodel :exphydro begin\n    snow_bucket\n    soil_bucket\nend","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"In this example:","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"Fluxes define processes like snowfall, rainfall, melt, evaporation, and runoff\nBuckets integrate these fluxes into snow and soil water components\nModel combines these components into a complete ExpHydro model","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"The framework automatically handles the connections between components, such as using the rainfall and melt outputs from the snow bucket as inputs to the soil bucket.","category":"page"},{"location":"framework_concepts/#Conclusion","page":"Understanding DeepFlex.jl Framework Concepts","title":"Conclusion","text":"","category":"section"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"Understanding the relationships between Flux, Element/Bucket, and Model components is essential for effectively using the DeepFlex.jl framework. These components provide a flexible and powerful system for building hydrological models of varying complexity, from simple conceptual models to complex physically-based or hybrid models.","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"By leveraging this modular architecture, modelers can:","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"Build models from reusable components\nCombine process-based and data-driven approaches\nCreate efficient and type-stable implementations\nSupport both single-node and distributed simulations","category":"page"},{"location":"framework_concepts/","page":"Understanding DeepFlex.jl Framework Concepts","title":"Understanding DeepFlex.jl Framework Concepts","text":"This framework design enables a wide range of hydrological modeling applications while maintaining computational efficiency and scientific rigor.","category":"page"},{"location":"implements/build_discharge_route_en/#Building-a-Discharge-Routing-Model","page":"construct the discharge route model","title":"Building a Discharge Routing Model","text":"","category":"section"},{"location":"implements/build_discharge_route_en/#Mathematical-Formulation","page":"construct the discharge route model","title":"Mathematical Formulation","text":"","category":"section"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"The discharge routing model is based on the following equations:","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"beginaligned\nfracdS_rfndt = Q_rfup - Q_rfn  (1) \nQ_rfn = fracS_rfntextLAG_rf + Q_rfn-1  (2) \nQ_rfup = sum_i in up(n) Q_rfi  (3) \nQ_rf = Q_rfn + (R_sw + R_gw) cdot A_gc  (4)\nendaligned","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"where n is the reach index, ranging from 1c_max; Delta S_rfn is the storage change in reach n; Q_rfn is the outflow from reach n; S_rfn is the storage in reach n; textLAG_rf is the routing lag parameter; Q_rfup is the inflow from upstream reaches; R_sw and R_gw are surface and groundwater runoff; A_gc is the grid cell area; c_max is the maximum number of reaches.","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"The equations describe: (1) storage change in the reach, (2) reach outflow calculation, (3) upstream inflow accumulation, and (4) final discharge calculation. This approach determines the inflow to each Hydrological Response Unit (HRU) based on its upstream inputs, which can be represented using two different routing functions. The outflow from the current HRU is calculated using the current reach storage S_rfn and combined with the HRU's R_sw and R_gw (after area conversion) to obtain the final discharge Q_rf.","category":"page"},{"location":"implements/build_discharge_route_en/#Implementation-in-HydroModels.jl","page":"construct the discharge route model","title":"Implementation in HydroModels.jl","text":"","category":"section"},{"location":"implements/build_discharge_route_en/#Modified-Calculation-Formula","page":"construct the discharge route model","title":"Modified Calculation Formula","text":"","category":"section"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"In the HydroModels.jl framework, this storage-based discharge calculation method is represented by the HydroRoute type, which solves the problem continuously through ODE equations. The implementation differs from the original formula in that it assumes no instantaneous changes when calculating Q_rfn, transforming equation (2) into:","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"beginaligned\nQ_rfn = S_rfn cdot frac1textLAG_rf + 1  (5)\nendaligned","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"The Q_rfn-1 term is removed because in continuous change, S_rfn is constantly evolving, making it unnecessary to consider Q_rfn-1 in calculating Q_rfn. Additionally, there are dimensional differences between S_rfn and Q_rfn, and including Q_rfn would add an instantaneous state variable, which is unsuitable as a state variable. In HydroRoute construction, the primary focus is expressing the outflow calculation formula. Like HydroBucket, HydroRoute accepts HydroFlux to represent the Q_rfn calculation formula:","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"using HydroModels\n# Define parameters and variables\n@variables q q_routed s_river\n@parameters lag\n# Define routing flux\nrflux = HydroFlux([q, s_river] => [q_routed], [lag], exprs=[s_river / (1 + lag) + q])","category":"page"},{"location":"implements/build_discharge_route_en/#Flow-Accumulation-Functions","page":"construct the discharge route model","title":"Flow Accumulation Functions","text":"","category":"section"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"The method of obtaining upstream flow inputs is another crucial component of the routing model. Flow accumulation functions are typically used to calculate the upstream inflow for each HRU. This accumulation can be represented using either Grid-Based or Vector-Based approaches, corresponding to two types of HydroRoute construction in HydroModels.jl: GridRoute and VectorRoute.","category":"page"},{"location":"implements/build_discharge_route_en/#Vector-Based-Routing-Model","page":"construct the discharge route model","title":"Vector-Based Routing Model","text":"","category":"section"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"The Vector-Based routing model is based on watershed subdivision and topological relationships, using an adjacency matrix for flow accumulation:","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"using Graphs\n# Build river network topology\nnetwork = DiGraph(9)\nadd_edge!(network, 1, 2)\nadd_edge!(network, 2, 5)\nadd_edge!(network, 3, 5)\nadd_edge!(network, 4, 5)\nadd_edge!(network, 5, 8)\nadd_edge!(network, 6, 9)\nadd_edge!(network, 7, 8)\nadd_edge!(network, 8, 9)\nvroute = HydroModels.VectorRoute(rfunc=rflux, rstate=s_river, network=network)","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"The code uses Graphs.jl's DiGraph data structure to represent watershed topology, which, along with the constructed rflux and s_river, completes the Vector-Based routing model construction.","category":"page"},{"location":"implements/build_discharge_route_en/#Grid-Based-Routing-Model","page":"construct the discharge route model","title":"Grid-Based Routing Model","text":"","category":"section"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"The Grid-Based routing model represents HRU connectivity using a D8 flow direction matrix. The construction is based on the D8 matrix and corresponding HRU coordinates:","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"# Build river network topology\nflwdir = [1 4 8; 1 4 4; 1 1 2]\npositions = [[1, 1], [1, 2], [1, 3], [2, 1], [2, 2], [2, 3], [3, 1], [3, 2], [3, 3]]\ngroute = HydroModels.GridRoute(rfunc=rflux, rstate=s_river, flwdir=flwdir, positions=positions)","category":"page"},{"location":"implements/build_discharge_route_en/","page":"construct the discharge route model","title":"construct the discharge route model","text":"The code uses matrix data to represent flow direction and HRU coordinates, which, combined with the constructed rflux and s_river, completes the Grid-Based routing model construction.","category":"page"},{"location":"tutorials/neuralnetwork_embeding/#Neural-Network-Integration-in-Hydrological-Modeling","page":"Neural Network Embedding","title":"Neural Network Integration in Hydrological Modeling","text":"","category":"section"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"A distinctive feature of the HydroModels.jl framework is its seamless integration of neural networks into hydrological model computations through the NeuralFlux type. This integration enables hybrid modeling approaches that combine process-based equations with data-driven components.","category":"page"},{"location":"tutorials/neuralnetwork_embeding/#NeuralFlux-Architecture","page":"Neural Network Embedding","title":"NeuralFlux Architecture","text":"","category":"section"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"The NeuralFlux type is a subtype of AbstractNeuralFlux in the HydroModels.jl framework, maintaining interface consistency with HydroFlux for seamless integration with HydroBucket components:","category":"page"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"AbstractNeuralFlux <: AbstractFlux","category":"page"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"Constructing a NeuralFlux requires three essential components:","category":"page"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"chain: A neural network model constructed using Lux.jl\ninputs: Input variables defined using ModelingToolkit.jl's symbolic system\noutputs: Output variables defined using ModelingToolkit.jl's symbolic system","category":"page"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"The @neuralflux macro provides a concise syntax for defining neural network fluxes:","category":"page"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"@neuralflux [output1, output2, ...] ~ chain([input1, input2, ...])","category":"page"},{"location":"tutorials/neuralnetwork_embeding/#Implementation-Methodology","page":"Neural Network Embedding","title":"Implementation Methodology","text":"","category":"section"},{"location":"tutorials/neuralnetwork_embeding/#Standalone-Usage","page":"Neural Network Embedding","title":"Standalone Usage","text":"","category":"section"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"NeuralFlux can be used independently to perform computations, functionally equivalent to direct Lux.jl neural network invocation but with the advantage of accepting ComponentVector parameters, enabling integration with Element and Model components:","category":"page"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"using HydroModels, Lux\n\n@variables i1 i2 i3 o1 o2\nchain_nm = :testnn\nchain = Lux.Chain(\n    Lux.Dense(3 => 16, tanh),\n    Lux.Dense(16 => 2, leakyrelu),\n    name=chain_nm\n)\nneuralflux = @neuralflux [o1, o2] ~ chain([i1, i2, i3])\ninput = rand(3, 100)\nnnps = ComponentVector(Lux.initialparameters(StableRNG(42), chain)) |> Vector\noutput = neuralflux(input, ComponentVector(nns=(chain_nm=nnps,)))","category":"page"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"During computation, NeuralFlux accepts a ComponentVector containing neural network parameters under the nns namespace. The chain_nm corresponds to the name assigned during chain definition, with each neural network's parameters represented as a vector. During computation, automatic conversion occurs through the recorded ComponentVector axes.","category":"page"},{"location":"tutorials/neuralnetwork_embeding/#Application-Paradigms","page":"Neural Network Embedding","title":"Application Paradigms","text":"","category":"section"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"When used with HydroBucket, NeuralFlux functions as a flux component alongside HydroFlux and StateFlux. Two primary application paradigms have emerged: process substitution and parameter estimation.","category":"page"},{"location":"tutorials/neuralnetwork_embeding/#1.-Process-Substitution","page":"Neural Network Embedding","title":"1. Process Substitution","text":"","category":"section"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"Replacing conventional hydrological formulations with neural networks represents a fundamental integration approach. The general formulation can be expressed as:","category":"page"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"flux = textNeuralNetwork(textvariables theta)","category":"page"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"This substitution can be implemented at varying levels of complexity:","category":"page"},{"location":"tutorials/neuralnetwork_embeding/#Post-Processing-Integration","page":"Neural Network Embedding","title":"Post-Processing Integration","text":"","category":"section"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"Neural networks can integrate all hydrological fluxes to predict streamflow (functioning as a post-processor, e.g., XAJ-LSTM):","category":"page"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"@neuralflux flow ~ lstm_model([soilwater, infiltration, prcp, ...])","category":"page"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"This implementation constructs an LSTM model that predicts streamflow using intermediate states (soil moisture, infiltration, etc.) calculated by a conventional hydrological model.","category":"page"},{"location":"tutorials/neuralnetwork_embeding/#Differential-Equation-Integration","page":"Neural Network Embedding","title":"Differential Equation Integration","text":"","category":"section"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"A more complex integration involves neural networks participating in ordinary differential equation (ODE) calculations, where neural network inputs include state variables and outputs contribute to state variable updates. The M50 model exemplifies this approach:","category":"page"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"@parameters snowpack_std snowpack_mean\n@parameters soilwater_std soilwater_mean\n@parameters prcp_std prcp_mean\n@parameters temp_std temp_mean\n\n# Input variables\n@variables prcp temp lday\n# State variables\n@variables snowpack soilwater\n# Process variables\n@variables pet rainfall snowfall melt\n# Neural network variables\n@variables log_evap_div_lday log_flow flow\n@variables norm_snw norm_slw norm_temp norm_prcp\n\nstep_func(x) = (tanh(5.0 * x) + 1.0) * 0.5\n\n# Neural network definitions\nep_nn = Lux.Chain(\n    Lux.Dense(3 => 16, tanh),\n    Lux.Dense(16 => 16, leakyrelu),\n    Lux.Dense(16 => 1, leakyrelu),\n    name=:epnn\n)\n\nq_nn = Lux.Chain(\n    Lux.Dense(2 => 16, tanh),\n    Lux.Dense(16 => 16, leakyrelu),\n    Lux.Dense(16 => 1, leakyrelu),\n    name=:qnn\n)\n\n# Soil water component\nsoil_bucket = @hydrobucket :m50_soil begin\n    fluxes = begin\n        @hydroflux norm_snw ~ (snowpack - snowpack_mean) / snowpack_std\n        @hydroflux norm_slw ~ (soilwater - soilwater_mean) / soilwater_std\n        @hydroflux norm_prcp ~ (prcp - prcp_mean) / prcp_std\n        @hydroflux norm_temp ~ (temp - temp_mean) / temp_std\n        @neuralflux log_evap_div_lday ~ ep_nn([norm_snw, norm_slw, norm_temp])\n        @neuralflux log_flow ~ q_nn([norm_slw, norm_prcp])\n    end\n    dfluxes = begin\n        @stateflux soilwater ~ rainfall + melt - step_func(soilwater) * lday * exp(log_evap_div_lday) - step_func(soilwater) * exp(log_flow)\n    end\nend","category":"page"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"This implementation demonstrates the M50 model replacing evaporation and runoff calculations in the ExpHydro model. Two neural networks are defined using Lux.jl for predicting evaporation and runoff. The HydroBucket first defines normalization calculations for snowpack, soil water, precipitation, and temperature, then constructs two NeuralFlux components based on these neural networks. In the dfluxes section, log_evap_div_lday and log_flow participate in soil state updates, indicating neural network integration into the hydrological model solution (this substitution approach incurs significantly higher computational costs than post-processing integration).","category":"page"},{"location":"tutorials/neuralnetwork_embeding/#2.-Parameter-Estimation","page":"Neural Network Embedding","title":"2. Parameter Estimation","text":"","category":"section"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"Using neural networks to estimate hydrological model parameters represents another significant application. The dPL-HBV model exemplifies this approach, using an LSTM model to predict sensitive HBV model parameters (BETA and GAMMA) based on forcing data and watershed static attributes, enabling dynamic parameter estimation to enhance effective rainfall and evaporation calculations:","category":"page"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"step_func(x) = (tanh(5.0 * x) + 1.0) * 0.5\n\nfunction LSTMCompact(in_dims, hidden_dims, out_dims)\n    lstm_cell = LSTMCell(in_dims => hidden_dims)\n    classifier = Dense(hidden_dims => out_dims, sigmoid)\n    return @compact(; lstm_cell, classifier) do x::AbstractArray{T,2} where {T}\n        x = reshape(x, size(x)..., 1)\n        x_init, x_rest = Iterators.peel(LuxOps.eachslice(x, Val(2)))\n        y, carry = lstm_cell(x_init)\n        output = [vec(classifier(y))]\n        for x in x_rest\n            y, carry = lstm_cell((x, carry))\n            output = vcat(output, [vec(classifier(y))])\n        end\n        @return reduce(hcat, output)\n    end\nend\n\n@variables soilwater snowpack meltwater suz slz\n@variables prcp pet temp\n@variables rainfall snowfall melt refreeze infil excess recharge evap q0 q1 q2 q perc\n@parameters TT CFMAX CFR CWH LP FC PPERC UZL k0 k1 k2 kp\n@variables BETA GAMMA\n#* parameters estimate by NN\nparams_nn = LSTMCompact(3, 10, 2)\nparams_nn_flux = NeuralFlux([prcp, temp, pet] => [BETA, GAMMA], params_nn, name=:pnn)\n\n#* snowfall and rainfall split flux\nsplit_flux = @hydroflux begin\n    snowfall ~ step_func(TT - temp) * prcp\n    rainfall ~ step_func(temp - TT) * prcp\nend\n\nsnow_bucket = @hydrobucket :hbv_snow begin\n    fluxes = begin\n        @hydroflux melt ~ min(snowpack, max(0.0, temp - TT) * CFMAX)\n        @hydroflux refreeze ~ min(max((TT - temp), 0.0) * CFR * CFMAX, meltwater)\n        @hydroflux infil ~ max(0.0, meltwater - snowpack * CWH)\n    end\n    dfluxes = begin\n        @stateflux snowpack ~ snowfall + refreeze - melt\n        @stateflux meltwater ~ melt - refreeze - infil\n    end\nend\n\nsoil_bucket = @hydrobucket :hbv_soil begin\n    fluxes = begin\n        @hydroflux recharge ~ (rainfall + infil) * clamp((max(soilwater / FC, 0.0))^(BETA * 5 + 1), 0, 1)\n        @hydroflux excess ~ max(soilwater - FC, 0.0)\n        @hydroflux evap ~ clamp(soilwater / (LP * FC), 0, 1) * pet\n    end\n    dfluxes = begin\n        @stateflux soilwater ~ (rainfall + infil) - (recharge + excess + evap)\n    end\nend\n\nzone_bucket = @hydrobucket :hbv_zone begin\n    fluxes = begin\n        @hydroflux perc ~ suz * PPERC\n        @hydroflux q0 ~ max(0.0, suz - UZL) * k0\n        @hydroflux q1 ~ suz * k1\n        @hydroflux q2 ~ slz * k2\n        @hydroflux q ~ q0 + q1 + q2\n    end\n    dfluxes = begin\n        @stateflux suz ~ recharge + excess - (perc + q0 + q1)\n        @stateflux slz ~ perc - q2\n    end\nend\n\ndpl_hbv_model = @hydromodel :dpl_hbv begin\n    params_nn_flux\n    split_flux\n    snow_bucket\n    soil_bucket\n    zone_bucket\nend","category":"page"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"This model incorporates the LSTM-based parameter estimation flux params_nn_flux while maintaining consistency with the standard HBV model structure. In params_nn_flux, a custom LSTM model predicts GAMMA and BETA parameters using forcing data (precipitation, temperature, daylight duration). These parameters function as dynamic, time-varying dimensionless fluxes, necessitating their definition as variables rather than parameters. The LSTM model's output activation function is typically sigmoid, requiring denormalization to map parameters to appropriate ranges:","category":"page"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"(rainfall + infil) * clamp((max(soilwater / FC, 0.0))^(BETA * 5 + 1), 0, 1)","category":"page"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"This expression maps BETA to a range of 1-6.","category":"page"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"This parameter estimation approach leverages LSTM to capture cumulative effects of forcing data for predicting GAMMA and BETA parameters. While this approach decouples neural network computation from hydrological model calculation, enhancing computational efficiency, the limited interpretability of LSTM models may contradict the original intent of neural network integration (as discussed in relevant literature).","category":"page"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"An alternative integration approach directly uses state variables like soil moisture as neural network inputs to represent cumulative effects:","category":"page"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"ps_nn = Lux.Chain(\n    Lux.Dense(4 => 16, tanh),\n    Lux.Dense(16 => 16, leakyrelu),\n    Lux.Dense(16 => 2, leakyrelu),\n    name=:psnn\n)\n\nsoil_bucket = @hydrobucket :hbv_soil begin\n    fluxes = begin\n        @neuralflux [BETA, GAMMA] ~ ps_nn([soilwater, prcp, pet, temp])\n        @hydroflux recharge ~ (rainfall + infil) * clamp((max(soilwater / FC, 0.0))^(BETA * 5 + 1), 0, 1)\n        @hydroflux excess ~ max(soilwater - FC, 0.0)\n        @hydroflux evap ~ clamp(soilwater / (LP * FC), 0, 1) * pet\n    end\n    dfluxes = begin\n        @stateflux soilwater ~ (rainfall + infil) - (recharge + excess + evap)\n    end\nend","category":"page"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"This implementation constructs a feedforward neural network that predicts BETA and GAMMA based on soil water, precipitation, potential evapotranspiration, and temperature, though at a significant computational cost.","category":"page"},{"location":"tutorials/neuralnetwork_embeding/#Summary","page":"Neural Network Embedding","title":"Summary","text":"","category":"section"},{"location":"tutorials/neuralnetwork_embeding/#Advancing-Hybrid-Modeling","page":"Neural Network Embedding","title":"Advancing Hybrid Modeling","text":"","category":"section"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"The integration of neural networks into hydrological models through HydroModels.jl's NeuralFlux component represents a significant advancement in hybrid modeling approaches. This framework enables seamless combination of process-based equations with data-driven components, creating models that leverage the strengths of both paradigms.","category":"page"},{"location":"tutorials/neuralnetwork_embeding/#Integration-Paradigms","page":"Neural Network Embedding","title":"Integration Paradigms","text":"","category":"section"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"The framework offers two primary integration paradigms:","category":"page"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"Process Substitution: Replacing conventional hydrological formulations with neural networks, ranging from simple post-processing to complex differential equation integration\nParameter Estimation: Using neural networks to dynamically adapt model parameters based on environmental conditions","category":"page"},{"location":"tutorials/neuralnetwork_embeding/#Technical-Implementation","page":"Neural Network Embedding","title":"Technical Implementation","text":"","category":"section"},{"location":"tutorials/neuralnetwork_embeding/","page":"Neural Network Embedding","title":"Neural Network Embedding","text":"The type-stable implementation and consistent interfaces ensure that neural network integration maintains computational efficiency while preserving the scientific rigor of traditional hydrological modeling approaches. The framework's design allows for seamless integration within the broader HydroModels.jl ecosystem.","category":"page"},{"location":"extent/flexible_and_efficent/#讨论灵活构建所牺牲的计算效率","page":"讨论灵活构建所牺牲的计算效率","title":"讨论灵活构建所牺牲的计算效率","text":"","category":"section"},{"location":"implements/build_discharge_route_zh/#构建河道汇流模型","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"","category":"section"},{"location":"implements/build_discharge_route_zh/#[discharge-route-model](https://gmd.copernicus.org/articles/14/7795/2021/)汇流模型介绍","page":"构建河道汇流模型","title":"discharge route model汇流模型介绍","text":"","category":"section"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"河道汇流模型是描述水流在河道中运动过程的数学模型，主要用于计算河道中的流量变化。下面给出了一个简单的河道汇流模型的数学表达式:","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"beginaligned\nDelta S_rfn = Q_rfn-1 - Q_rfn  (1) \nQ_rfn = (S_rfn + Q_rfn-1) cdot frac1textLAG_rf + 1  (2) \nQ_rf0 = sum Q_rfup  (3) \nQ_rf = Q_rfc_max + (R_sw + R_gw) cdot 0001 cdot A_gc  (4)\nendaligned","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"其中,n表示河段编号，取值范围为1c_max;Delta S_rfn表示第 n 段河道的蓄水量变化;Q_rfn表示第 n 段河道的出流量;S_rfn表示第 n 段河道的蓄水量;textLAG_rf 表示河道汇流滞时参数;Q_rfup表示上游河道的入流量;R_sw和R_gw分别表示地表径流和地下径流;A_gc表示栅格面积;c_max表示河道最大分段数.","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"公式(1)描述了河道蓄水量的变化，公式(2)表示河道出流量的计算，公式(3)给出了河道入流量的计算方法，公式(4)则是最终河道出流量的计算公式。 这种构建方式是根据每个 hydrological response unit(HRU)的上游输入确定当前的 HRU 入流量,这个确定方式可以由两种路由函数来表示. 当前 HRU 的出流量则是以当前的河道蓄水量S_rfn计算得到,并于 HRU 的 R{sw}和 R{gw}进行相加(经面积转换)得到最终的出流量Q_rf.","category":"page"},{"location":"implements/build_discharge_route_zh/#HydroModels.jl-框架下的河道汇流模型构建","page":"构建河道汇流模型","title":"HydroModels.jl 框架下的河道汇流模型构建","text":"","category":"section"},{"location":"implements/build_discharge_route_zh/#计算公式的改造","page":"构建河道汇流模型","title":"计算公式的改造","text":"","category":"section"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"HydroModels.jl 框架中为这种基于河道蓄水状态计算时段出流量的方法以 HydroRoute 类型进行表示,通过构建 ODE 方程的方式对这个问题进行连续性求解.与原公式实现有所不同的是,,并认为在计算Q_rfn时不存在瞬时变化,所以将公式(2)转换为如下式子:","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"beginaligned\nQ_rfn = S_rfn cdot frac1textLAG_rf + 1  (5)\nendaligned","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"式中,去掉了Q_rfn-1项.因为认为,在持续性变化中,S_rfn是一直处于变化状态的,所以在计算Q_rfn时不需要考虑Q_rfn-1的变化.此外于S_rfn与Q_rfn的量纲存在差异,同时如果将式中如果考虑Q_rfn会额外增加一个状态变量,这个变量是一个瞬时值,也不适合作为状态变量来使用. 在 HydroRoute 构造中,其首要的就是针对出流计算公式进行表达,与 HydroBucket 一样,HydroRoute 可以接受 HydroFlux 以此表示Q_rfn的计算公式,如下所示:","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"# 定义涉及的参数和变量\n@variables q q_routed s_river\n@parameters lag\n# 定义\nrflux = HydroFlux([q, s_river] => [q_routed], [lag], exprs=[s_river / (1 + lag) + q])","category":"page"},{"location":"implements/build_discharge_route_zh/#流量累积函数表示","page":"构建河道汇流模型","title":"流量累积函数表示","text":"","category":"section"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"获取 HRU 上游流量输入的方式是构成汇流模型的另一个部分,通常可以设置 Aggregation 函数来获取每个 HRU 的上游入流流量. 这个 Aggregation 函数可以由 Grid-Based 和 Vector-Based 两种方式来表示. 在 HydroModels.jl 框架中分别对应了两种 HydroRoute 的构造方式: GridRoute 和 VectorRoute.","category":"page"},{"location":"implements/build_discharge_route_zh/#表示-Vector-Based-的河道汇流模型","page":"构建河道汇流模型","title":"表示 Vector-Based 的河道汇流模型","text":"","category":"section"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"Vector-Based 的河道汇流模型是以流域子流域划分结果及其连接的拓扑关系为基础,通过构建 adjacency 矩阵得到流量累积函数:","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"# 构建河网拓扑结构\nnetwork = DiGraph(9)\nadd_edge!(network, 1, 2)\nadd_edge!(network, 2, 5)\nadd_edge!(network, 3, 5)\nadd_edge!(network, 4, 5)\nadd_edge!(network, 5, 8)\nadd_edge!(network, 6, 9)\nadd_edge!(network, 7, 8)\nadd_edge!(network, 8, 9)\nvroute = HydroModels.VectorRoute(rfunc=rflux, rstate=s_river, network=network)","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"代码中是采用 Graphs.jl 的 DiGraph 数据结构来表示流域拓扑,作为模型的输入参数,连同构建的 rflux 和 s_river,一同完成 Vector-Based 的河道汇流模型的构造.","category":"page"},{"location":"implements/build_discharge_route_zh/#表示-Grid-Based-的河道汇流模型","page":"构建河道汇流模型","title":"表示 Grid-Based 的河道汇流模型","text":"","category":"section"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"Grid-Based 的河道汇流模型是 HRU 之间的连同关系所表示的, 同常是使用 d8 流向矩阵来表示其连同关系,以此 Grid-Based 的河道汇流模型的构造便是根据 d8 流向矩阵和对应的 HRU 坐标来进行构造的:","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"# 构建河网拓扑结构\nflwdir = [1 4 8; 1 4 4; 1 1 2]\npositions = [[1, 1], [1, 2], [1, 3], [2, 1], [2, 2], [2, 3], [3, 1], [3, 2], [3, 3]]\ngroute = HydroModels.GridRoute(rfunc=rflux, rstate=s_river, flwdir=flwdir, positions=positions)","category":"page"},{"location":"implements/build_discharge_route_zh/","page":"构建河道汇流模型","title":"构建河道汇流模型","text":"代码中是采用矩阵数据表示流向矩阵和HRU 坐标,作为模型的输入参数,连同构建的 rflux 和 s_river,一同完成 Grid-Based 的河道汇流模型的构造.","category":"page"},{"location":"extent/share_parameters/#Share-parameters-in-multiple-HRUs","page":"Share parameters in multiple HRUs","title":"Share parameters in multiple HRUs","text":"","category":"section"},{"location":"extent/why_not_MTK/#HydroModels.jl与ModelingToolkit.jl","page":"HydroModels.jl与ModelingToolkit.jl","title":"HydroModels.jl与ModelingToolkit.jl","text":"","category":"section"},{"location":"extent/why_not_MTK/#为什么不直接使用[ModelingToolkit.jl](https://github.com/SciML/ModelingToolkit.jl)","page":"HydroModels.jl与ModelingToolkit.jl","title":"为什么不直接使用ModelingToolkit.jl","text":"","category":"section"},{"location":"extent/why_not_MTK/","page":"HydroModels.jl与ModelingToolkit.jl","title":"HydroModels.jl与ModelingToolkit.jl","text":"HydroModels.jl的设计理念事实上是与ModelingToolkit.jl完全一致的,两者都是使用Symbolics.jl进行符号计算的框架,ModelingToolkit.jl是一个更通用符号系统,支持多种问题的构建,同时针对特定领域ModelingToolkitStandardLibrary.jl提供了基础组件的支持. 但是我之前在ModelingToolkit.jl的使用中存在一些问题:","category":"page"},{"location":"extent/why_not_MTK/","page":"HydroModels.jl与ModelingToolkit.jl","title":"HydroModels.jl与ModelingToolkit.jl","text":"尽管ModelingToolkit.jl同样能够根据符号编程表达水文模型的常微分方程,但对水文模型中单位线计算,汇流过程计算等计算过程的支持却并不是特别理想\n在同一种模块中,比如蒸发计算公式和土壤计算模块,不同区域所需要构建的模块会因为公式的不同存在差异,需要分别构建计算公式支撑模型模型构建\n水文模型通常包括多个常微分方程,使用一个ODESystem构建会相对混乱,使用多个ODESystem会相对复杂\n同时对于多节点输入,空间汇流过程计算,ODESystem或无法直接支持.\n对于神经网络模型的嵌入,尽管存在ModelingToolkitNeuralNets.jl,然而嵌入性却没有想象的那么简单\n基于ModelingToolkit.jl对于自动微分的支持,尤其是Zygote.jl我在使用时也存在问题.","category":"page"},{"location":"extent/why_not_MTK/","page":"HydroModels.jl与ModelingToolkit.jl","title":"HydroModels.jl与ModelingToolkit.jl","text":"因此我决定自己构建一个模型库,参考了符号编程的模型构建方式,使其更能够支撑水文模型的一些建模需求.","category":"page"},{"location":"extent/why_not_MTK/#未来的工作","page":"HydroModels.jl与ModelingToolkit.jl","title":"未来的工作","text":"","category":"section"},{"location":"extent/why_not_MTK/","page":"HydroModels.jl与ModelingToolkit.jl","title":"HydroModels.jl与ModelingToolkit.jl","text":"不可否认ModelingToolkit.jl是一个非常好的框架,在满足了水文模型的需求之后,我会尽量将HydroModels.jl中的模块能够成为ModelingToolkitStandardLibrary.jl中相似的模块,并继承ModelingToolkit.jl提供的AbstractSystem类的支持,提供一致的功能支持,从而兼容更多SciML生态的计算功能.","category":"page"},{"location":"extent/framework_comparision_en/#Comparing-Programming-Styles-for-Custom-Models-in-superflexpy,-MARRMoT,-and-HydroModels.jl","page":"Framework Comparision","title":"Comparing Programming Styles for Custom Models in superflexpy, MARRMoT, and HydroModels.jl","text":"","category":"section"},{"location":"extent/framework_comparision_en/","page":"Framework Comparision","title":"Framework Comparision","text":"This content corresponds to Section 4.1 of the paper, where we discuss the differences in programming styles for custom model implementation across these three software libraries. Using the GR4J model implementation as an example, we compare the programming styles for customizing model computation formulas.","category":"page"},{"location":"extent/framework_comparision_en/#[Superflexpy](https://github.com/dalmo1991/superflexPy/tree/master)","page":"Framework Comparision","title":"Superflexpy","text":"","category":"section"},{"location":"extent/framework_comparision_en/","page":"Framework Comparision","title":"Framework Comparision","text":"Superflexpy is a Python implementation based on the SUPERFLEX concept. For implementing hydrological model computations, this framework typically uses Python syntax to express model calculation formulas, as shown below.","category":"page"},{"location":"extent/framework_comparision_en/","page":"Framework Comparision","title":"Framework Comparision","text":"@staticmethod\ndef _flux_function_python(S, S0, ind, P, x1, alpha, beta, ni, PET, dt):\n    if ind is None:\n        return (\n            [\n                P * (1 - (S / x1) ** alpha), # Ps\n                -PET * (2 * (S / x1) - (S / x1) ** alpha), # Evaporation\n                -((x1 ** (1 - beta)) / ((beta - 1) * dt)) * (ni ** (beta - 1)) * (S**beta), # Perc\n            ],\n            0.0,\n            S0 + P * (1 - (S / x1) ** alpha) * dt,\n        )\n    else:\n        return (\n            [\n                P[ind] * (1 - (S / x1[ind]) ** alpha[ind]), # Ps\n                -PET[ind] * (2 * (S / x1[ind]) - (S / x1[ind]) ** alpha[ind]), # Evaporation\n                -((x1[ind] ** (1 - beta[ind])) / ((beta[ind] - 1) * dt[ind]))\n                * (ni[ind] ** (beta[ind] - 1))\n                * (S ** beta[ind]), # Perc\n            ],\n            0.0,\n            S0 + P[ind] * (1 - (S / x1[ind]) ** alpha[ind]) * dt[ind],\n            [\n                -(P[ind] * alpha[ind] / x1[ind]) * ((S / x1[ind]) ** (alpha[ind] - 1)),\n                -(PET[ind] / x1[ind]) * (2 - alpha[ind] * ((S / x1[ind]) ** (alpha[ind] - 1))),\n                -beta[ind]\n                * ((x1[ind] ** (1 - beta[ind])) / ((beta[ind] - 1) * dt[ind]))\n                * (ni[ind] ** (beta[ind] - 1))\n                * (S ** (beta[ind] - 1)),\n            ],\n        )\n\n@staticmethod\n@nb.jit(\n    \"Tuple((UniTuple(f8, 3), f8, f8, UniTuple(f8, 3)))\"\n    \"(optional(f8), f8, i4, f8[:], f8[:], f8[:], f8[:], f8[:], f8[:], f8[:])\",\n    nopython=True,\n)\ndef _flux_function_numba(S, S0, ind, P, x1, alpha, beta, ni, PET, dt):\n    return (\n        (\n            P[ind] * (1 - (S / x1[ind]) ** alpha[ind]),  # Ps\n            -PET[ind] * (2 * (S / x1[ind]) - (S / x1[ind]) ** alpha[ind]),  # Evaporation\n            -((x1[ind] ** (1 - beta[ind])) / ((beta[ind] - 1) * dt[ind]))\n            * (ni[ind] ** (beta[ind] - 1))\n            * (S ** beta[ind]),  # Perc\n        ),\n        0.0,\n        S0 + P[ind] * (1 - (S / x1[ind]) ** alpha[ind]) * dt[ind],\n        (\n            -(P[ind] * alpha[ind] / x1[ind]) * ((S / x1[ind]) ** (alpha[ind] - 1)),\n            -(PET[ind] / x1[ind]) * (2 - alpha[ind] * ((S / x1[ind]) ** (alpha[ind] - 1))),\n            -beta[ind]\n            * ((x1[ind] ** (1 - beta[ind])) / ((beta[ind] - 1) * dt[ind]))\n            * (ni[ind] ** (beta[ind] - 1))\n            * (S ** (beta[ind] - 1)),\n        ),\n    )","category":"page"},{"location":"extent/framework_comparision_en/","page":"Framework Comparision","title":"Framework Comparision","text":"As shown, when implementing the GR4J production module calculations origin code, the superflexpy framework requires separate construction of numpy and numba computation code. The function must specify hydrological fluxes Ps, Evaporation, Perc, and state variable balance equations. This approach couples multiple computational process implementations in a single code block, resulting in reduced code reusability (only reusable at the module level) and increased code volume and redundancy.","category":"page"},{"location":"extent/framework_comparision_en/#[MARRMoT](https://github.com/wknoben/MARRMoT)","page":"Framework Comparision","title":"MARRMoT","text":"","category":"section"},{"location":"extent/framework_comparision_en/","page":"Framework Comparision","title":"Framework Comparision","text":"MARRMoT is a hydrological modeling framework developed in MATLAB. This framework constructs model types separately based on different hydrological models, storing the calculation formulas and state change equations involved. The simplified implementation code for the GR4J model in this framework is shown below.","category":"page"},{"location":"extent/framework_comparision_en/","page":"Framework Comparision","title":"Framework Comparision","text":"function [dS, fluxes] = model_fun(obj, S)\n    % definitions\n    ...\n    % fluxes functions\n    flux_pn   = max(P-Ep,0);\n    flux_en   = max(Ep-P,0);\n    flux_ef   = P - flux_pn;\n    flux_ps   = saturation_4(S1,x1,flux_pn);\n    flux_es   = evap_11(S1,x1,flux_en);\n    flux_perc = percolation_3(S1,x1);\n    flux_q9   = route(.9.*(flux_pn - flux_ps + flux_perc), uh_q9);\n    flux_q1   = route(.1.*(flux_pn - flux_ps + flux_perc), uh_q1);\n    flux_fr   = recharge_2(3.5,S2,x3,x2);\n    flux_fq   = flux_fr;\n    flux_qr   = baseflow_3(S2,x3);\n    flux_qt   = flux_qr + max(flux_q1 + flux_fq,0);\n    % this flux is not included in original MARRMoT,\n    % but it is useful to calculate the water balance\n    flux_ex = flux_fr + max(flux_q1 + flux_fq,0) - flux_q1;      \n    % stores ODEs\n    dS1 = flux_ps - flux_es - flux_perc;\n    dS2 = flux_q9 + flux_fr - flux_qr;\n    % outputs\n    dS = [dS1 dS2];\n    fluxes = [flux_pn,   flux_en, flux_ef, flux_ps, flux_es,...\n                flux_perc, flux_q9, flux_q1, flux_fr, flux_fq,...\n                flux_qr,   flux_qt, flux_ex];\nend","category":"page"},{"location":"extent/framework_comparision_en/","page":"Framework Comparision","title":"Framework Comparision","text":"As evident, the MARRMoT framework expresses each Flux calculation formula through functions, allowing users to directly call functions for calculations (according to provided documentation). This approach significantly simplifies code writing requirements compared to superflexpy. However, MARRMoT has poor support for module reusability and cannot be reused like superflexpy. Additionally, combining variable assignments, flux calculations, and state change equations in one function results in poor decoupling of computational content.","category":"page"},{"location":"extent/framework_comparision_en/#HydroModels.jl","page":"Framework Comparision","title":"HydroModels.jl","text":"","category":"section"},{"location":"extent/framework_comparision_en/","page":"Framework Comparision","title":"Framework Comparision","text":"#* define the production store\nprod_funcs = [\n    HydroFlux([prcp, ep] => [pn, en], exprs=[prcp - min(prcp, ep), ep - min(prcp, ep)]),\n    HydroFlux([pn, soilwater] => [ps], [x1], exprs=[max(0.0, pn * (1 - (soilwater / x1)^2))]),\n    HydroFlux([en, soilwater] => [es], [x1], exprs=[en * (2 * soilwater / x1 - (soilwater / x1)^2)]),\n    HydroFlux([soilwater] => [perc], [x1], exprs=[((x1)^(-4)) / 4 * ((4 / 9)^(4)) * (soilwater^5)]),\n    HydroFlux([pn, ps, perc] => [pr], exprs=[pn - ps + perc]),\n    HydroFlux([pr] => [slowflow, fastflow], exprs=[0.9 * pr, 0.1 * pr]),\n]\nprod_dfuncs = [StateFlux([ps] => [es, perc], soilwater)]\nprod_ele = HydroBucket(name=:gr4j_prod, funcs=prod_funcs, dfuncs=prod_dfuncs)\n\n#* uh function\nuh_flux_1 = HydroModels.UnitHydrograph([slowflow] => [slowflow_routed], x4, uhfunc=HydroModels.UHFunction(:UH_1_HALF), solvetype=:SPARSE)\nuh_flux_2 = HydroModels.UnitHydrograph([fastflow] => [fastflow_routed], x4, uhfunc=HydroModels.UHFunction(:UH_2_FULL), solvetype=:SPARSE)\n\n#* define the routing store\nrst_funcs = [\n    HydroFlux([routingstore] => [exch], [x2, x3], exprs=[x2 * abs(routingstore / x3)^3.5]),\n    HydroFlux([routingstore, slowflow, exch] => [routedflow], [x3], exprs=[x3^(-4) / 4 * (routingstore + slowflow + exch)^5]),\n    HydroFlux([routedflow, fastflow_routed, exch] => [flow], exprs=[routedflow + max(fastflow_routed + exch, 0.0)]),\n]\nrst_dfuncs = [StateFlux([exch, slowflow] => [routedflow], routingstore)]\nrst_ele = HydroBucket(name=:gr4j_rst, funcs=rst_funcs, dfuncs=rst_dfuncs)\n\ngr4j_model = HydroModel(name=:gr4j, components=[prod_ele, uh_flux_1, uh_flux_2, rst_ele])","category":"page"},{"location":"extent/framework_comparision_en/","page":"Framework Comparision","title":"Framework Comparision","text":"Returning to the GR4J model implementation in HydroModels.jl framework, we sequentially define the production store, unit hydrograph, and routing store. In this process, the model can achieve reusability while maintaining variable correspondence. The construction process includes instantiation of classes such as HydroFlux, StateFlux, UnitHydrograph, HydroModel, and HydroBucket. Unlike the previous two frameworks that use functional construction, these class instantiations express calculation formulas through symbolic programming. After model construction, calculations are performed through input data and parameters, demonstrating a design philosophy that completely decouples model structure and formulas from parameters and data, achieving high reusability.","category":"page"},{"location":"#HydroModels.jl","page":"Home","title":"HydroModels.jl","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HydroModels.jl is a modern hydrological modeling framework that extends and enhances SUPERFLEX's design philosophy. Built on Julia language and the SciML (Scientific Machine Learning) ecosystem, it combines flexible model construction with computational efficiency, particularly supporting deep learning integration in hydrological modeling.","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Flexible Model Construction: Supports development of lumped, semi-distributed, and distributed hydrological models\nDeep Learning Integration: Enables neural network integration for enhanced flux calculations and dynamic parameter estimation\nComputational Efficiency: Leverages Julia's high-performance capabilities and the SciML ecosystem\nGradient-Based Optimization: Supports advanced parameter optimization techniques\nComprehensive Framework: Provides tools for both traditional hydrological modeling and modern machine learning approaches","category":"page"},{"location":"#Framework-Capabilities","page":"Home","title":"Framework Capabilities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HydroModels.jl offers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Easy implementation and customization of hydrological models\nIntegration with Julia's scientific computing ecosystem\nSupport for various modeling approaches:\nTraditional conceptual models\nNeural network enhanced models\nDistributed hydrological systems","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"HydroModels\")","category":"page"},{"location":"#Important-Notations","page":"Home","title":"Important Notations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"I am not a professional full-time software developer, so the code may have imperfections. If you find any issues, please post them in the issues section, and I will respond promptly.\nThe documentation is still being improved. If you want to quickly understand how to use the software, you can refer to the dev folder on GitHub. I will integrate this into a notebook as soon as possible.\nThe software has some issues. When solving ODE files, using EnzymeVJP from SciMLSensitivity.jl generally provides more efficient gradient calculations, but there are problems with multi-node ODE solving. I will fix this as soon as possible and begin trying to calculate gradients using Enzyme.jl and compile code using Reactant.jl.\nTo be responsible, if you only want to build a hydrological model or a neural network-embedded hydrological model, I would recommend building it manually. My main purpose in writing this package is to reduce the difficulty of model development and to serve future large model generation tasks.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HydroModels.jl is an open-source project available on Github. We welcome contributions from the community to help advance deep learning applications in hydrology.","category":"page"}]
}
