<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Distribute Modeling · HydroModels.jl</title><meta name="title" content="Distribute Modeling · HydroModels.jl"/><meta property="og:title" content="Distribute Modeling · HydroModels.jl"/><meta property="twitter:title" content="Distribute Modeling · HydroModels.jl"/><meta name="description" content="Documentation for HydroModels.jl."/><meta property="og:description" content="Documentation for HydroModels.jl."/><meta property="twitter:description" content="Documentation for HydroModels.jl."/><meta property="og:url" content="https://chooron.github.io/HydroModels.jl/dev/tutorials/distribute_modeling/"/><meta property="twitter:url" content="https://chooron.github.io/HydroModels.jl/dev/tutorials/distribute_modeling/"/><link rel="canonical" href="https://chooron.github.io/HydroModels.jl/dev/tutorials/distribute_modeling/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/icon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">HydroModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../get_start_en/">Get Started with HydroModels.jl</a></li><li><span class="tocitem">tutorials</span><ul><li><a class="tocitem" href="../framework_design/">Framework Design</a></li><li><a class="tocitem" href="../neuralnetwork_embeding/">Neural Network Embedding</a></li><li class="is-active"><a class="tocitem" href>Distribute Modeling</a><ul class="internal"><li><a class="tocitem" href="#Introduction-to-Multi-Node/Distributed-Hydrological-Modeling"><span>Introduction to Multi-Node/Distributed Hydrological Modeling</span></a></li><li><a class="tocitem" href="#Implementation-of-Multi-Node-Models"><span>Implementation of Multi-Node Models</span></a></li><li><a class="tocitem" href="#Implementing-Multi-Node-Computation-with-HydroModels.jl"><span>Implementing Multi-Node Computation with HydroModels.jl</span></a></li><li><a class="tocitem" href="#Real-World-Example-(Based-on-HBVmaxbas/route-Model)"><span>Real-World Example (Based on HBV+maxbas/route Model)</span></a></li></ul></li><li><a class="tocitem" href="../optimimal_parameters/">Optimal Parameters</a></li></ul></li><li><a class="tocitem" href="../../concepts_en/">Basic Concepts</a></li><li><span class="tocitem">Model Implementations</span><ul><li><a class="tocitem" href="../../implements/build_exphydro_model_en/">construct the ExpHydro Model</a></li><li><a class="tocitem" href="../../implements/build_m50_model_en/">construct the M50 Model</a></li><li><a class="tocitem" href="../../implements/build_discharge_route_en/">construct the discharge route model</a></li></ul></li><li><span class="tocitem">Extend Contents</span><ul><li><a class="tocitem" href="../../extent/why_not_MTK_en/">Why not using ModelingToolkit.jl directly</a></li><li><a class="tocitem" href="../../extent/framework_comparision_en/">Framework Comparision</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">tutorials</a></li><li class="is-active"><a href>Distribute Modeling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Distribute Modeling</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/chooron/HydroModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/chooron/HydroModels.jl/blob/main/docs/src/tutorials/distribute_modeling.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Multi-Node/Distributed-Hydrological-Modeling"><a class="docs-heading-anchor" href="#Multi-Node/Distributed-Hydrological-Modeling">Multi-Node/Distributed Hydrological Modeling</a><a id="Multi-Node/Distributed-Hydrological-Modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-Node/Distributed-Hydrological-Modeling" title="Permalink"></a></h1><h2 id="Introduction-to-Multi-Node/Distributed-Hydrological-Modeling"><a class="docs-heading-anchor" href="#Introduction-to-Multi-Node/Distributed-Hydrological-Modeling">Introduction to Multi-Node/Distributed Hydrological Modeling</a><a id="Introduction-to-Multi-Node/Distributed-Hydrological-Modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-to-Multi-Node/Distributed-Hydrological-Modeling" title="Permalink"></a></h2><p>The hydrological models introduced earlier are primarily lumped models, which use a single model to simulate an entire watershed. This approach is typically suitable for smaller watersheds. For large watersheds with significant topographic features and river network topology, a single hydrological model is insufficient to simulate the processes accurately.</p><p>Researchers have proposed methods to build hydrological models based on watershed topographic characteristics and then integrate them using routing models. This approach is known as distributed hydrological modeling. The process begins by dividing the watershed into multiple hydrological response units (which we call multi-nodes). This division can be done either by partitioning the watershed into standard grids of fixed size (distributed approach) or by dividing it into irregularly shaped sub-watersheds based on river topology (semi-distributed approach). The runoff results from these multiple nodes are then integrated using geographic elevation information and river network topology.</p><h2 id="Implementation-of-Multi-Node-Models"><a class="docs-heading-anchor" href="#Implementation-of-Multi-Node-Models">Implementation of Multi-Node Models</a><a id="Implementation-of-Multi-Node-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-of-Multi-Node-Models" title="Permalink"></a></h2><p>All types constructed in HydroModels.jl (Flux, Bucket, Route, Model) support multi-node computation without requiring additional declarations during construction. Each module automatically allocates the appropriate computational scenario based on the input data type. This section primarily introduces the construction methods for routing modules. Using the HBV model as the runoff generation model, we have constructed three types of routing models: unit hydrograph-based routing, semi-distributed routing based on river network topology, and distributed routing based on geographic elevation information.</p><h3 id="1.-Unit-Hydrograph-Based-Routing-Model"><a class="docs-heading-anchor" href="#1.-Unit-Hydrograph-Based-Routing-Model">1. Unit Hydrograph-Based Routing Model</a><a id="1.-Unit-Hydrograph-Based-Routing-Model-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Unit-Hydrograph-Based-Routing-Model" title="Permalink"></a></h3><p>HBV-maxbas uses HBV as its foundation and a unit hydrograph model for routing. The unit hydrograph parameters are determined by the distance from the computational grid to the outlet node. The implementation is as follows:</p><pre><code class="language-julia hljs"># Define unit hydrograph using macro
uh = @unithydro :maxbas_uh begin
    uh_func = begin
        2lag =&gt; (1 - 0.5 * (2 - t / lag)^2.5)
        lag =&gt; (0.5 * (t / lag)^2.5)
    end
    uh_vars = q =&gt; q_uh  # Input =&gt; Output
end</code></pre><p>Both semi-distributed routing based on river network topology and distributed routing based on geographic elevation information can be constructed using HydroRoute. The difference between these two construction methods lies in the aggregate function.</p><p>Semi-distributed hydrological models typically describe the connectivity of sub-watersheds using directed graphs. This allows for the integration of runoff results from different sub-watersheds based on the connection relationships provided by the network:</p><pre><code class="language-julia hljs"># Define routing component with aggregation function
discharge_route = @hydroroute :exphydro_routed begin
    fluxes = begin
        @hydroflux q_routed ~ s_river / (1 + lag) + q
    end
    dfluxes = begin
        @stateflux s_river ~ q - q_routed
    end
    hru_types = collect(1:9)  # 9 nodes
    aggr_func = HydroModels.build_aggr_func(network)
end</code></pre><p>The construction of <code>fluxes</code> and <code>dfluxes</code> is similar to that of Bucket, but with some limitations:</p><ol><li>The number of <code>fluxes</code> and <code>dfluxes</code> must correspond. <code>fluxes</code> represents the flow from the current computational unit to the next, while <code>dfluxes</code> represents the storage volume of the routing module in the current computational unit. It is composed of the runoff from the current unit, inflow from other units, and outflow to other units. The complete formula should be:</li></ol><p>$</p><p>\frac{dS<em>{route}}{dt} = Q</em>{in}(t) - Q<em>{out}(t) + Q</em>{gen}(t) $</p><p>Here, we assume that <span>$Q_{in}(t)$</span> equals <span>$aggr\_func(Q_{out}(t))$</span>, meaning the inflow for the current time period equals the result of routing the outflow for the current time period (this process is continuous, so we consider this expression valid). To simplify the construction of the Route module, this calculation is relatively fixed, but more modifications can be made in the writing of <code>fluxes</code>.</p><ol><li>Compared to Bucket, the Route module also needs to provide an aggregate function. This function is constructed from the flow direction matrix calculated from the topological relationships of sub-watersheds or geographic elevation data, and is used to calculate <span>$Q_{in}(t)$</span> for the current time period.</li></ol><p>For semi-distributed hydrological models, a directed graph can be constructed based on the upstream-downstream connection relationships of the watershed (using Graphs.jl):</p><pre><code class="language-julia hljs">network = DiGraph(9)
add_edge!(network, 1, 2)
add_edge!(network, 2, 5)
add_edge!(network, 3, 5)
add_edge!(network, 4, 5)
add_edge!(network, 5, 8)
add_edge!(network, 6, 9)
add_edge!(network, 7, 8)
add_edge!(network, 8, 9)

aggr_func = HydroModels.build_aggr_func(network)</code></pre><p>The code represents the connection relationships of the watershed by constructing a directed graph, where the numbers in the directed graph represent the node numbers.</p><p>For distributed hydrological models, a flow direction matrix (d8) and a list of matrix indices representing the input node index order are needed to ensure the correctness of the input integration:</p><pre><code class="language-julia hljs">flwdir = [1 4 8; 1 4 4; 1 1 2]
positions = [[1, 1], [1, 2], [1, 3], [2, 1], [2, 2], [2, 3], [3, 1], [3, 2], [3, 3]]</code></pre><h2 id="Implementing-Multi-Node-Computation-with-HydroModels.jl"><a class="docs-heading-anchor" href="#Implementing-Multi-Node-Computation-with-HydroModels.jl">Implementing Multi-Node Computation with HydroModels.jl</a><a id="Implementing-Multi-Node-Computation-with-HydroModels.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-Multi-Node-Computation-with-HydroModels.jl" title="Permalink"></a></h2><p>All types constructed in HydroModels.jl (Flux, Bucket, Route, Model) support multi-node computation without requiring additional declarations during construction. Each module automatically allocates the appropriate computational scenario based on the input data type. Below, I will introduce the execution process of multi-node computation from three aspects: data preparation, parameter settings, and runtime configuration.</p><h3 id="1.-Data-Preparation"><a class="docs-heading-anchor" href="#1.-Data-Preparation">1. Data Preparation</a><a id="1.-Data-Preparation-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Data-Preparation" title="Permalink"></a></h3><p>For single-node input, the data format is variables × time dimensions. For multi-node input, the data format becomes variables × nodes × time dimensions, resulting in a three-dimensional matrix.</p><h3 id="2.-Parameter-Preparation"><a class="docs-heading-anchor" href="#2.-Parameter-Preparation">2. Parameter Preparation</a><a id="2.-Parameter-Preparation-1"></a><a class="docs-heading-anchor-permalink" href="#2.-Parameter-Preparation" title="Permalink"></a></h3><p>For single-node input, the parameter format is:</p><pre><code class="language-julia hljs">params = ComponentVector(
    params=(p1=0.0, p2=0.0, ...),
    nns=(nn1=[...], )
)</code></pre><p>As you can see, each parameter name corresponds to a single value.</p><p>For multi-node input, the parameter format is:</p><pre><code class="language-julia hljs">params = ComponentVector(
    params=(p1=[0.0, 0.0, ...], p2=[0.0, 0.0, ...], ...),
    nns=(nn1=[...], )
)</code></pre><p>Each parameter corresponds to an array of values, representing the parameters for each node. Note that the neural network parameters do not show significant changes. This is because constructing a neural network for each node during multi-node computation would make the computational cost relatively large and unnecessary.</p><p>Similarly, the initial states follow the same pattern as the parameters:</p><pre><code class="language-julia hljs">initstates = ComponentVector(
    s1=[0.0, 0.0, ...],
    s2=[0.0, 0.0, ...],
    ...
)</code></pre><h3 id="3.-Runtime-Configuration"><a class="docs-heading-anchor" href="#3.-Runtime-Configuration">3. Runtime Configuration</a><a id="3.-Runtime-Configuration-1"></a><a class="docs-heading-anchor-permalink" href="#3.-Runtime-Configuration" title="Permalink"></a></h3><h4 id="HydroConfig-for-Multi-Node-Models-(NEW-in-v2.0)"><a class="docs-heading-anchor" href="#HydroConfig-for-Multi-Node-Models-(NEW-in-v2.0)">HydroConfig for Multi-Node Models (NEW in v2.0)</a><a id="HydroConfig-for-Multi-Node-Models-(NEW-in-v2.0)-1"></a><a class="docs-heading-anchor-permalink" href="#HydroConfig-for-Multi-Node-Models-(NEW-in-v2.0)" title="Permalink"></a></h4><p>For multi-node models, you use the same <code>HydroConfig</code> system as single-node models:</p><pre><code class="language-julia hljs"># Create configuration for multi-node model
config = HydroConfig(
    solver = MutableSolver,          # or ImmutableSolver for AD
    interpolator = Val(DirectInterpolation),
    timeidx = 1:365,                 # Time steps
    min_value = 1e-6,
    parallel = false                  # Future: enable parallel computation
)</code></pre><h4 id="Parameter-Type-Index-(hru_types)"><a class="docs-heading-anchor" href="#Parameter-Type-Index-(hru_types)">Parameter Type Index (hru_types)</a><a id="Parameter-Type-Index-(hru_types)-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-Type-Index-(hru_types)" title="Permalink"></a></h4><p>In distributed hydrological models, some computational units have highly similar natural attributes, so it&#39;s reasonable to share parameters. This is achieved using <code>hru_types</code> during bucket/route construction:</p><pre><code class="language-julia hljs"># Define parameter types for each node
# Suppose we have 10 nodes falling into 4 terrain types
hru_types = [1, 1, 1, 2, 2, 2, 3, 3, 3, 4]

# Define bucket with hru_types
snow_bucket = @hydrobucket :snow begin
    fluxes = begin
        @hydroflux pet ~ 29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)
        # ... other fluxes
    end
    dfluxes = begin
        @stateflux snowpack ~ snowfall - melt
    end
    hru_types = [1, 1, 1, 2, 2, 2, 3, 3, 3, 4]  # Specify node types
end</code></pre><p>In the multi-node input parameters, each parameter corresponds to a parameter array with one value per terrain type:</p><pre><code class="language-julia hljs"># Parameters for 4 terrain types
params = ComponentVector(
    params = (
        Df = [2.5, 3.0, 2.0, 2.8],      # 4 values for 4 types
        Tmax = [0.5, 0.3, 0.7, 0.4],
        # ... other parameters
    )
)</code></pre><p>The framework automatically expands parameters based on <code>hru_types</code> during computation:</p><pre><code class="language-julia hljs"># Internally expands: Df[hru_types] = [2.5, 2.5, 2.5, 3.0, 3.0, 3.0, 2.0, 2.0, 2.0, 2.8]</code></pre><p>This significantly reduces the number of parameters to calibrate while maintaining spatial heterogeneity.</p><h2 id="Real-World-Example-(Based-on-HBVmaxbas/route-Model)"><a class="docs-heading-anchor" href="#Real-World-Example-(Based-on-HBVmaxbas/route-Model)">Real-World Example (Based on HBV+maxbas/route Model)</a><a id="Real-World-Example-(Based-on-HBVmaxbas/route-Model)-1"></a><a class="docs-heading-anchor-permalink" href="#Real-World-Example-(Based-on-HBVmaxbas/route-Model)" title="Permalink"></a></h2><p>To demonstrate the practical application of multi-node modeling, let&#39;s consider a real-world example using the HBV model for runoff generation combined with either maxbas or route for flow routing.</p><p>First, we&#39;ll define our watershed structure using a directed graph to represent the connectivity between sub-watersheds:</p><pre><code class="language-julia hljs"># Define watershed network structure
network = DiGraph(9)  # 9 sub-watersheds
add_edge!(network, 1, 2)  # Sub-watershed 1 flows into 2
add_edge!(network, 2, 5)
add_edge!(network, 3, 5)
add_edge!(network, 4, 5)
add_edge!(network, 5, 8)
add_edge!(network, 6, 9)
add_edge!(network, 7, 8)
add_edge!(network, 8, 9)  # Sub-watershed 8 flows into outlet 9

# Create the routing component
discharge_route = @hydroroute :hbv_routed begin
    fluxes = begin
        @hydroflux q_routed ~ s_river / (1 + lag) + q
    end
    dfluxes = begin
        @stateflux s_river ~ q - q_routed
    end
    aggr_func = HydroModels.build_aggr_func(network)
end

# Combine with HBV model
hbv_distributed = @hydromodel :hbv_distributed begin
    hbv_bucket  # Runoff generation component
    discharge_route  # Routing component
end</code></pre><p>Next, we prepare our input data and parameters for the multi-node model:</p><pre><code class="language-julia hljs"># Prepare input data (variables × nodes × time)
input_data = zeros(3, 9, 365)  # Example: 3 variables, 9 nodes, 365 days
# Fill with actual precipitation, temperature, etc. data for each node

# Define parameter types (4 types of terrain)
params = ComponentVector(
    params = (
        FC = [150.0, 200.0, 100.0, 180.0],    # Field capacity for each terrain type
        LP = [0.7, 0.8, 0.6, 0.75],
        BETA = [2.0, 3.0, 1.5, 2.5],
        # Other HBV parameters...
        lag = [1.5, 2.0, 1.0, 1.8]             # Routing lag parameter
    )
)

# Initial states for each node (9 nodes total)
initstates = ComponentVector(
    snowpack = zeros(9),
    soilwater = zeros(9),
    s_river = zeros(9)
)

# Configure model execution (NEW in v2.0)
config = HydroConfig(
    solver = MutableSolver,
    interpolator = Val(DirectInterpolation),
    timeidx = 1:365,
    min_value = 1e-6
)

# Run the distributed model
results = hbv_distributed(
    input_data,
    params,
    config;
    initstates = initstates
)</code></pre><blockquote><p><strong>Note</strong>: The <code>hru_types</code> parameter is now specified during model construction (in the bucket definition), not at runtime. This allows for better type stability and compiler optimization.</p></blockquote><p>This example demonstrates how HydroModels.jl can efficiently handle multi-node hydrological modeling with parameter sharing across similar terrain types, significantly reducing the number of parameters that need to be calibrated while maintaining the spatial heterogeneity of the watershed.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../neuralnetwork_embeding/">« Neural Network Embedding</a><a class="docs-footer-nextpage" href="../optimimal_parameters/">Optimal Parameters »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Tuesday 11 November 2025 12:13">Tuesday 11 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
