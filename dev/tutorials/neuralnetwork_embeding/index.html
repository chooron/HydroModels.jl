<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Neural Network Embedding · HydroModels.jl</title><meta name="title" content="Neural Network Embedding · HydroModels.jl"/><meta property="og:title" content="Neural Network Embedding · HydroModels.jl"/><meta property="twitter:title" content="Neural Network Embedding · HydroModels.jl"/><meta name="description" content="Documentation for HydroModels.jl."/><meta property="og:description" content="Documentation for HydroModels.jl."/><meta property="twitter:description" content="Documentation for HydroModels.jl."/><meta property="og:url" content="https://chooron.github.io/HydroModels.jl/dev/tutorials/neuralnetwork_embeding/"/><meta property="twitter:url" content="https://chooron.github.io/HydroModels.jl/dev/tutorials/neuralnetwork_embeding/"/><link rel="canonical" href="https://chooron.github.io/HydroModels.jl/dev/tutorials/neuralnetwork_embeding/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/icon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">HydroModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../get_start_en/">Get Started with HydroModels.jl</a></li><li><span class="tocitem">tutorials</span><ul><li><a class="tocitem" href="../framework_design/">Framework Design</a></li><li class="is-active"><a class="tocitem" href>Neural Network Embedding</a><ul class="internal"><li><a class="tocitem" href="#NeuralFlux-Architecture"><span>NeuralFlux Architecture</span></a></li><li><a class="tocitem" href="#Implementation-Methodology"><span>Implementation Methodology</span></a></li><li><a class="tocitem" href="#Application-Paradigms"><span>Application Paradigms</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li><li><a class="tocitem" href="../distribute_modeling/">Distribute Modeling</a></li><li><a class="tocitem" href="../optimimal_parameters/">Optimal Parameters</a></li></ul></li><li><a class="tocitem" href="../../concepts_en/">Basic Concepts</a></li><li><span class="tocitem">Model Implementations</span><ul><li><a class="tocitem" href="../../implements/build_exphydro_model_en/">construct the ExpHydro Model</a></li><li><a class="tocitem" href="../../implements/build_m50_model_en/">construct the M50 Model</a></li><li><a class="tocitem" href="../../implements/build_discharge_route_en/">construct the discharge route model</a></li></ul></li><li><span class="tocitem">Extend Contents</span><ul><li><a class="tocitem" href="../../extent/why_not_MTK_en/">Why not using ModelingToolkit.jl directly</a></li><li><a class="tocitem" href="../../extent/framework_comparision_en/">Framework Comparision</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">tutorials</a></li><li class="is-active"><a href>Neural Network Embedding</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Neural Network Embedding</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/chooron/HydroModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/chooron/HydroModels.jl/blob/main/docs/src/tutorials/neuralnetwork_embeding.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Neural-Network-Integration-in-Hydrological-Modeling"><a class="docs-heading-anchor" href="#Neural-Network-Integration-in-Hydrological-Modeling">Neural Network Integration in Hydrological Modeling</a><a id="Neural-Network-Integration-in-Hydrological-Modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Neural-Network-Integration-in-Hydrological-Modeling" title="Permalink"></a></h1><p>A distinctive feature of the HydroModels.jl framework is its seamless integration of neural networks into hydrological model computations through the <code>NeuralFlux</code> type. This integration enables hybrid modeling approaches that combine process-based equations with data-driven components.</p><h2 id="NeuralFlux-Architecture"><a class="docs-heading-anchor" href="#NeuralFlux-Architecture">NeuralFlux Architecture</a><a id="NeuralFlux-Architecture-1"></a><a class="docs-heading-anchor-permalink" href="#NeuralFlux-Architecture" title="Permalink"></a></h2><p>The <code>NeuralFlux</code> type is a subtype of <code>AbstractNeuralFlux</code> in the HydroModels.jl framework, maintaining interface consistency with <code>HydroFlux</code> for seamless integration with <code>HydroBucket</code> components:</p><pre><code class="language-julia hljs">AbstractNeuralFlux &lt;: AbstractFlux</code></pre><p>Constructing a <code>NeuralFlux</code> requires three essential components:</p><ul><li><code>chain</code>: A neural network model constructed using Lux.jl</li><li><code>inputs</code>: Input variables defined using ModelingToolkit.jl&#39;s symbolic system</li><li><code>outputs</code>: Output variables defined using ModelingToolkit.jl&#39;s symbolic system</li></ul><p>The <code>@neuralflux</code> macro provides a concise syntax for defining neural network fluxes:</p><pre><code class="language-julia hljs">@neuralflux [output1, output2, ...] ~ chain([input1, input2, ...])</code></pre><h2 id="Implementation-Methodology"><a class="docs-heading-anchor" href="#Implementation-Methodology">Implementation Methodology</a><a id="Implementation-Methodology-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-Methodology" title="Permalink"></a></h2><h3 id="Standalone-Usage"><a class="docs-heading-anchor" href="#Standalone-Usage">Standalone Usage</a><a id="Standalone-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Standalone-Usage" title="Permalink"></a></h3><p><code>NeuralFlux</code> can be used independently to perform computations, functionally equivalent to direct Lux.jl neural network invocation but with the advantage of accepting <code>ComponentVector</code> parameters, enabling integration with <code>Element</code> and <code>Model</code> components:</p><pre><code class="language-julia hljs">using HydroModels, Lux

@variables i1 i2 i3 o1 o2
chain_nm = :testnn
chain = Lux.Chain(
    Lux.Dense(3 =&gt; 16, tanh),
    Lux.Dense(16 =&gt; 2, leakyrelu),
    name=chain_nm
)
neuralflux = @neuralflux [o1, o2] ~ chain([i1, i2, i3])
input = rand(3, 100)
nnps = ComponentVector(Lux.initialparameters(StableRNG(42), chain)) |&gt; Vector
output = neuralflux(input, ComponentVector(nns=(chain_nm=nnps,)))</code></pre><p>During computation, <code>NeuralFlux</code> accepts a <code>ComponentVector</code> containing neural network parameters under the <code>nns</code> namespace. The <code>chain_nm</code> corresponds to the name assigned during chain definition, with each neural network&#39;s parameters represented as a vector. During computation, automatic conversion occurs through the recorded <code>ComponentVector</code> axes.</p><h2 id="Application-Paradigms"><a class="docs-heading-anchor" href="#Application-Paradigms">Application Paradigms</a><a id="Application-Paradigms-1"></a><a class="docs-heading-anchor-permalink" href="#Application-Paradigms" title="Permalink"></a></h2><p>When used with <code>HydroBucket</code>, <code>NeuralFlux</code> functions as a flux component alongside <code>HydroFlux</code> and <code>StateFlux</code>. Two primary application paradigms have emerged: process substitution and parameter estimation.</p><h3 id="1.-Process-Substitution"><a class="docs-heading-anchor" href="#1.-Process-Substitution">1. Process Substitution</a><a id="1.-Process-Substitution-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Process-Substitution" title="Permalink"></a></h3><p>Replacing conventional hydrological formulations with neural networks represents a fundamental integration approach. The general formulation can be expressed as:</p><p class="math-container">\[flux = \text{NeuralNetwork}(\text{variables}; \theta)\]</p><p>This substitution can be implemented at varying levels of complexity:</p><h4 id="Post-Processing-Integration"><a class="docs-heading-anchor" href="#Post-Processing-Integration">Post-Processing Integration</a><a id="Post-Processing-Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Post-Processing-Integration" title="Permalink"></a></h4><p>Neural networks can integrate all hydrological fluxes to predict streamflow (functioning as a post-processor, e.g., XAJ-LSTM):</p><pre><code class="language-julia hljs">@neuralflux flow ~ lstm_model([soilwater, infiltration, prcp, ...])</code></pre><p>This implementation constructs an LSTM model that predicts streamflow using intermediate states (soil moisture, infiltration, etc.) calculated by a conventional hydrological model.</p><h4 id="Differential-Equation-Integration"><a class="docs-heading-anchor" href="#Differential-Equation-Integration">Differential Equation Integration</a><a id="Differential-Equation-Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Differential-Equation-Integration" title="Permalink"></a></h4><p>A more complex integration involves neural networks participating in ordinary differential equation (ODE) calculations, where neural network inputs include state variables and outputs contribute to state variable updates. The M50 model exemplifies this approach:</p><pre><code class="language-julia hljs">@parameters snowpack_std snowpack_mean
@parameters soilwater_std soilwater_mean
@parameters prcp_std prcp_mean
@parameters temp_std temp_mean

# Input variables
@variables prcp temp lday
# State variables
@variables snowpack soilwater
# Process variables
@variables pet rainfall snowfall melt
# Neural network variables
@variables log_evap_div_lday log_flow flow
@variables norm_snw norm_slw norm_temp norm_prcp

step_func(x) = (tanh(5.0 * x) + 1.0) * 0.5

# Neural network definitions
ep_nn = Lux.Chain(
    Lux.Dense(3 =&gt; 16, tanh),
    Lux.Dense(16 =&gt; 16, leakyrelu),
    Lux.Dense(16 =&gt; 1, leakyrelu),
    name=:epnn
)

q_nn = Lux.Chain(
    Lux.Dense(2 =&gt; 16, tanh),
    Lux.Dense(16 =&gt; 16, leakyrelu),
    Lux.Dense(16 =&gt; 1, leakyrelu),
    name=:qnn
)

# Soil water component
soil_bucket = @hydrobucket :m50_soil begin
    fluxes = begin
        @hydroflux norm_snw ~ (snowpack - snowpack_mean) / snowpack_std
        @hydroflux norm_slw ~ (soilwater - soilwater_mean) / soilwater_std
        @hydroflux norm_prcp ~ (prcp - prcp_mean) / prcp_std
        @hydroflux norm_temp ~ (temp - temp_mean) / temp_std
        @neuralflux log_evap_div_lday ~ ep_nn([norm_snw, norm_slw, norm_temp])
        @neuralflux log_flow ~ q_nn([norm_slw, norm_prcp])
    end
    dfluxes = begin
        @stateflux soilwater ~ rainfall + melt - step_func(soilwater) * lday * exp(log_evap_div_lday) - step_func(soilwater) * exp(log_flow)
    end
end</code></pre><p>This implementation demonstrates the M50 model replacing evaporation and runoff calculations in the ExpHydro model. Two neural networks are defined using Lux.jl for predicting evaporation and runoff. The <code>HydroBucket</code> first defines normalization calculations for snowpack, soil water, precipitation, and temperature, then constructs two <code>NeuralFlux</code> components based on these neural networks. In the <code>dfluxes</code> section, <code>log_evap_div_lday</code> and <code>log_flow</code> participate in soil state updates, indicating neural network integration into the hydrological model solution (this substitution approach incurs significantly higher computational costs than post-processing integration).</p><h3 id="2.-Parameter-Estimation"><a class="docs-heading-anchor" href="#2.-Parameter-Estimation">2. Parameter Estimation</a><a id="2.-Parameter-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#2.-Parameter-Estimation" title="Permalink"></a></h3><p>Using neural networks to estimate hydrological model parameters represents another significant application. The dPL-HBV model exemplifies this approach, using an LSTM model to predict sensitive HBV model parameters (BETA and GAMMA) based on forcing data and watershed static attributes, enabling dynamic parameter estimation to enhance effective rainfall and evaporation calculations:</p><pre><code class="language-julia hljs">step_func(x) = (tanh(5.0 * x) + 1.0) * 0.5

function LSTMCompact(in_dims, hidden_dims, out_dims)
    lstm_cell = LSTMCell(in_dims =&gt; hidden_dims)
    classifier = Dense(hidden_dims =&gt; out_dims, sigmoid)
    return @compact(; lstm_cell, classifier) do x::AbstractArray{T,2} where {T}
        x = reshape(x, size(x)..., 1)
        x_init, x_rest = Iterators.peel(LuxOps.eachslice(x, Val(2)))
        y, carry = lstm_cell(x_init)
        output = [vec(classifier(y))]
        for x in x_rest
            y, carry = lstm_cell((x, carry))
            output = vcat(output, [vec(classifier(y))])
        end
        @return reduce(hcat, output)
    end
end

@variables soilwater snowpack meltwater suz slz
@variables prcp pet temp
@variables rainfall snowfall melt refreeze infil excess recharge evap q0 q1 q2 q perc
@parameters TT CFMAX CFR CWH LP FC PPERC UZL k0 k1 k2 kp
@variables BETA GAMMA
#* parameters estimate by NN
params_nn = LSTMCompact(3, 10, 2)
params_nn_flux = NeuralFlux([prcp, temp, pet] =&gt; [BETA, GAMMA], params_nn, name=:pnn)

#* snowfall and rainfall split flux
split_flux = @hydroflux begin
    snowfall ~ step_func(TT - temp) * prcp
    rainfall ~ step_func(temp - TT) * prcp
end

snow_bucket = @hydrobucket :hbv_snow begin
    fluxes = begin
        @hydroflux melt ~ min(snowpack, max(0.0, temp - TT) * CFMAX)
        @hydroflux refreeze ~ min(max((TT - temp), 0.0) * CFR * CFMAX, meltwater)
        @hydroflux infil ~ max(0.0, meltwater - snowpack * CWH)
    end
    dfluxes = begin
        @stateflux snowpack ~ snowfall + refreeze - melt
        @stateflux meltwater ~ melt - refreeze - infil
    end
end

soil_bucket = @hydrobucket :hbv_soil begin
    fluxes = begin
        @hydroflux recharge ~ (rainfall + infil) * clamp((max(soilwater / FC, 0.0))^(BETA * 5 + 1), 0, 1)
        @hydroflux excess ~ max(soilwater - FC, 0.0)
        @hydroflux evap ~ clamp(soilwater / (LP * FC), 0, 1) * pet
    end
    dfluxes = begin
        @stateflux soilwater ~ (rainfall + infil) - (recharge + excess + evap)
    end
end

zone_bucket = @hydrobucket :hbv_zone begin
    fluxes = begin
        @hydroflux perc ~ suz * PPERC
        @hydroflux q0 ~ max(0.0, suz - UZL) * k0
        @hydroflux q1 ~ suz * k1
        @hydroflux q2 ~ slz * k2
        @hydroflux q ~ q0 + q1 + q2
    end
    dfluxes = begin
        @stateflux suz ~ recharge + excess - (perc + q0 + q1)
        @stateflux slz ~ perc - q2
    end
end

dpl_hbv_model = @hydromodel :dpl_hbv begin
    params_nn_flux
    split_flux
    snow_bucket
    soil_bucket
    zone_bucket
end</code></pre><p>This model incorporates the LSTM-based parameter estimation flux <code>params_nn_flux</code> while maintaining consistency with the standard HBV model structure. In <code>params_nn_flux</code>, a custom LSTM model predicts GAMMA and BETA parameters using forcing data (precipitation, temperature, daylight duration). These parameters function as dynamic, time-varying dimensionless fluxes, necessitating their definition as <code>variables</code> rather than <code>parameters</code>. The LSTM model&#39;s output activation function is typically sigmoid, requiring denormalization to map parameters to appropriate ranges:</p><pre><code class="language-julia hljs">(rainfall + infil) * clamp((max(soilwater / FC, 0.0))^(BETA * 5 + 1), 0, 1)</code></pre><p>This expression maps BETA to a range of 1-6.</p><p>This parameter estimation approach leverages LSTM to capture cumulative effects of forcing data for predicting GAMMA and BETA parameters. While this approach decouples neural network computation from hydrological model calculation, enhancing computational efficiency, the limited interpretability of LSTM models may contradict the original intent of neural network integration (as discussed in relevant literature).</p><p>An alternative integration approach directly uses state variables like soil moisture as neural network inputs to represent cumulative effects:</p><pre><code class="language-julia hljs">ps_nn = Lux.Chain(
    Lux.Dense(4 =&gt; 16, tanh),
    Lux.Dense(16 =&gt; 16, leakyrelu),
    Lux.Dense(16 =&gt; 2, leakyrelu),
    name=:psnn
)

soil_bucket = @hydrobucket :hbv_soil begin
    fluxes = begin
        @neuralflux [BETA, GAMMA] ~ ps_nn([soilwater, prcp, pet, temp])
        @hydroflux recharge ~ (rainfall + infil) * clamp((max(soilwater / FC, 0.0))^(BETA * 5 + 1), 0, 1)
        @hydroflux excess ~ max(soilwater - FC, 0.0)
        @hydroflux evap ~ clamp(soilwater / (LP * FC), 0, 1) * pet
    end
    dfluxes = begin
        @stateflux soilwater ~ (rainfall + infil) - (recharge + excess + evap)
    end
end</code></pre><p>This implementation constructs a feedforward neural network that predicts BETA and GAMMA based on soil water, precipitation, potential evapotranspiration, and temperature, though at a significant computational cost.</p><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><h3 id="Advancing-Hybrid-Modeling"><a class="docs-heading-anchor" href="#Advancing-Hybrid-Modeling">Advancing Hybrid Modeling</a><a id="Advancing-Hybrid-Modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Advancing-Hybrid-Modeling" title="Permalink"></a></h3><p>The integration of neural networks into hydrological models through HydroModels.jl&#39;s <code>NeuralFlux</code> component represents a significant advancement in hybrid modeling approaches. This framework enables seamless combination of process-based equations with data-driven components, creating models that leverage the strengths of both paradigms.</p><h3 id="Integration-Paradigms"><a class="docs-heading-anchor" href="#Integration-Paradigms">Integration Paradigms</a><a id="Integration-Paradigms-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-Paradigms" title="Permalink"></a></h3><p>The framework offers two primary integration paradigms:</p><ul><li><strong>Process Substitution</strong>: Replacing conventional hydrological formulations with neural networks, ranging from simple post-processing to complex differential equation integration</li><li><strong>Parameter Estimation</strong>: Using neural networks to dynamically adapt model parameters based on environmental conditions</li></ul><h3 id="Technical-Implementation"><a class="docs-heading-anchor" href="#Technical-Implementation">Technical Implementation</a><a id="Technical-Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Technical-Implementation" title="Permalink"></a></h3><p>The type-stable implementation and consistent interfaces ensure that neural network integration maintains computational efficiency while preserving the scientific rigor of traditional hydrological modeling approaches. The framework&#39;s design allows for seamless integration within the broader HydroModels.jl ecosystem.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../framework_design/">« Framework Design</a><a class="docs-footer-nextpage" href="../distribute_modeling/">Distribute Modeling »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Sunday 7 September 2025 15:11">Sunday 7 September 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
