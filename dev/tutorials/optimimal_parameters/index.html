<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Optimal Parameters · HydroModels.jl</title><meta name="title" content="Optimal Parameters · HydroModels.jl"/><meta property="og:title" content="Optimal Parameters · HydroModels.jl"/><meta property="twitter:title" content="Optimal Parameters · HydroModels.jl"/><meta name="description" content="Documentation for HydroModels.jl."/><meta property="og:description" content="Documentation for HydroModels.jl."/><meta property="twitter:description" content="Documentation for HydroModels.jl."/><meta property="og:url" content="https://chooron.github.io/HydroModels.jl/dev/tutorials/optimimal_parameters/"/><meta property="twitter:url" content="https://chooron.github.io/HydroModels.jl/dev/tutorials/optimimal_parameters/"/><link rel="canonical" href="https://chooron.github.io/HydroModels.jl/dev/tutorials/optimimal_parameters/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/icon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">HydroModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../get_start_en/">Get Started with HydroModels.jl</a></li><li><span class="tocitem">tutorials</span><ul><li><a class="tocitem" href="../framework_design/">Framework Design</a></li><li><a class="tocitem" href="../neuralnetwork_embeding/">Neural Network Embedding</a></li><li><a class="tocitem" href="../distribute_modeling/">Distribute Modeling</a></li><li class="is-active"><a class="tocitem" href>Optimal Parameters</a><ul class="internal"><li><a class="tocitem" href="#Table-of-Contents"><span>Table of Contents</span></a></li><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Required-Packages"><span>Required Packages</span></a></li><li><a class="tocitem" href="#Data-Preparation"><span>Data Preparation</span></a></li><li><a class="tocitem" href="#Model-Initialization"><span>Model Initialization</span></a></li><li><a class="tocitem" href="#Preparing-Model-Inputs-and-Run-Configuration"><span>Preparing Model Inputs and Run Configuration</span></a></li><li><a class="tocitem" href="#Objective-Function-Definition"><span>Objective Function Definition</span></a></li><li><a class="tocitem" href="#Optimization-Progress-Tracking"><span>Optimization Progress Tracking</span></a></li><li><a class="tocitem" href="#Parameter-Boundary-Setup"><span>Parameter Boundary Setup</span></a></li><li><a class="tocitem" href="#Optimization-Problem-Configuration"><span>Optimization Problem Configuration</span></a></li><li><a class="tocitem" href="#Executing-Optimization"><span>Executing Optimization</span></a></li><li><a class="tocitem" href="#Result-Analysis-and-Visualization"><span>Result Analysis and Visualization</span></a></li><li><a class="tocitem" href="#Choosing-Different-Optimization-Algorithms"><span>Choosing Different Optimization Algorithms</span></a></li><li><a class="tocitem" href="#Advanced-Applications"><span>Advanced Applications</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../concepts_en/">Basic Concepts</a></li><li><span class="tocitem">Model Implementations</span><ul><li><a class="tocitem" href="../../implements/build_exphydro_model_en/">construct the ExpHydro Model</a></li><li><a class="tocitem" href="../../implements/build_m50_model_en/">construct the M50 Model</a></li><li><a class="tocitem" href="../../implements/build_discharge_route_en/">construct the discharge route model</a></li></ul></li><li><span class="tocitem">Extend Contents</span><ul><li><a class="tocitem" href="../../extent/why_not_MTK_en/">Why not using ModelingToolkit.jl directly</a></li><li><a class="tocitem" href="../../extent/framework_comparision_en/">Framework Comparision</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">tutorials</a></li><li class="is-active"><a href>Optimal Parameters</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Optimal Parameters</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/chooron/HydroModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/chooron/HydroModels.jl/blob/main/docs/src/tutorials/optimimal_parameters.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Using-Optimization-to-Calibrate-HydroModels.jl-Parameters"><a class="docs-heading-anchor" href="#Using-Optimization-to-Calibrate-HydroModels.jl-Parameters">Using Optimization to Calibrate HydroModels.jl Parameters</a><a id="Using-Optimization-to-Calibrate-HydroModels.jl-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Optimization-to-Calibrate-HydroModels.jl-Parameters" title="Permalink"></a></h1><p>This tutorial will guide you on how to use Julia&#39;s Optimization ecosystem to calibrate parameters in HydroModels.jl hydrological models. Through parameter optimization, you can improve model outputs to better fit observed data, thereby enhancing the model&#39;s predictive capabilities.</p><h2 id="Table-of-Contents"><a class="docs-heading-anchor" href="#Table-of-Contents">Table of Contents</a><a id="Table-of-Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Table-of-Contents" title="Permalink"></a></h2><ol><li><a href="#overview">Overview</a></li><li><a href="#required-packages">Required Packages</a></li><li><a href="#data-preparation">Data Preparation</a></li><li><a href="#model-initialization">Model Initialization</a></li><li><a href="#parameter-boundary-setup">Parameter Boundary Setup</a></li><li><a href="#objective-function-definition">Objective Function Definition</a></li><li><a href="#optimization-problem-configuration">Optimization Problem Configuration</a></li><li><a href="#executing-optimization">Executing Optimization</a></li><li><a href="#result-analysis-and-visualization">Result Analysis and Visualization</a></li><li><a href="#choosing-different-optimization-algorithms">Choosing Different Optimization Algorithms</a></li><li><a href="#advanced-applications">Advanced Applications</a></li></ol><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Parameter optimization is a core step in hydrological model calibration. In HydroModels.jl, we leverage Julia&#39;s Optimization ecosystem to implement efficient parameter calibration. This tutorial will demonstrate how to set up and execute the optimization process to find parameter sets that best fit observed data.</p><h2 id="Required-Packages"><a class="docs-heading-anchor" href="#Required-Packages">Required Packages</a><a id="Required-Packages-1"></a><a class="docs-heading-anchor-permalink" href="#Required-Packages" title="Permalink"></a></h2><p>First, we need to import the necessary packages:</p><pre><code class="language-julia hljs">using CSV, DataFrames, Dates, ComponentArrays
using HydroModels, HydroModelTools
using DataInterpolations
using OptimizationEvolutionary  # Evolutionary algorithms
using OptimizationGCMAES       # Covariance Matrix Adaptation Evolution Strategy
using OptimizationBBO          # Biogeography-Based Optimization
using Optimization             # Core optimization framework
using ModelingToolkit
using Distributions
using ProgressMeter
using Plots
using JLD2</code></pre><h2 id="Data-Preparation"><a class="docs-heading-anchor" href="#Data-Preparation">Data Preparation</a><a id="Data-Preparation-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Preparation" title="Permalink"></a></h2><p>The optimization process requires input data (such as precipitation, evaporation) and observed data (such as streamflow):</p><pre><code class="language-julia hljs"># Load data
file_path = &quot;data/exphydro/01013500.csv&quot;
data = CSV.File(file_path)
df = DataFrame(data)

# Select time period
ts = collect(1:10000)

# Extract necessary variables
lday_vec = df[ts, &quot;dayl(day)&quot;]           # Day length
prcp_vec = df[ts, &quot;prcp(mm/day)&quot;]        # Precipitation
temp_vec = df[ts, &quot;tmean(C)&quot;]            # Temperature
flow_vec = df[ts, &quot;flow(mm)&quot;]            # Observed streamflow

# Calculate potential evapotranspiration (PET)
pet_vec = @. 29.8 * lday_vec * 24 * 0.611 * exp((17.3 * temp_vec) / (temp_vec + 237.3)) / (temp_vec + 273.2)

# Set warm-up period and maximum iterations
warm_up = 365    # Model warm-up period (days)
max_iter = 1000  # Maximum optimization iterations</code></pre><h2 id="Model-Initialization"><a class="docs-heading-anchor" href="#Model-Initialization">Model Initialization</a><a id="Model-Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Initialization" title="Permalink"></a></h2><p>Next, we initialize the hydrological model and set up initial parameters and states:</p><pre><code class="language-julia hljs"># Select model (e.g., HBV model)
model_nm = &quot;hbv&quot;
model = HydroModelLibrary.load_model(Symbol(model_nm))

# Get parameter boundaries
param_bounds = getbounds.(get_params(model))

# Randomly generate initial parameter values (within parameter boundaries)
random_param_values = map(param_bounds) do param_bound
    rand(Uniform(param_bound[1], param_bound[2]))
end

# Create parameter vector
init_params = ComponentVector(params=NamedTuple{Tuple(get_param_names(model))}(random_param_values))
ps_axes = getaxes(init_params)

# Initialize model states (all state variables set to 0)
init_states = NamedTuple{Tuple(get_state_names(model))}(zeros(length(get_state_names(model)))) |&gt; ComponentVector</code></pre><h2 id="Preparing-Model-Inputs-and-Run-Configuration"><a class="docs-heading-anchor" href="#Preparing-Model-Inputs-and-Run-Configuration">Preparing Model Inputs and Run Configuration</a><a id="Preparing-Model-Inputs-and-Run-Configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Preparing-Model-Inputs-and-Run-Configuration" title="Permalink"></a></h2><p>Before optimization, we need to prepare model input data and run configuration:</p><pre><code class="language-julia hljs"># Prepare input data
input = (P=prcp_vec, Ep=pet_vec, T=temp_vec)
input_matrix = Matrix(reduce(hcat, collect(input[HydroModels.get_input_names(model)])&#39;))

# Set model run configuration
config = (solver=HydroModelTools.DiscreteSolver(), interp=LinearInterpolation)
run_kwargs = (config=config, initstates=init_states)</code></pre><h2 id="Objective-Function-Definition"><a class="docs-heading-anchor" href="#Objective-Function-Definition">Objective Function Definition</a><a id="Objective-Function-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Objective-Function-Definition" title="Permalink"></a></h2><p>The core of optimization is defining an objective function to evaluate the performance of model parameters. Here we use KGE (Kling-Gupta Efficiency) as the evaluation metric:</p><pre><code class="language-julia hljs"># Calculate mean for R² computation
y_mean = mean(flow_vec)

# Define R² function (coefficient of determination)
r2_func(y, y_hat) = sum((y .- y_hat) .^ 2) ./ sum((y .- y_mean) .^ 2)

# Define KGE function (Kling-Gupta Efficiency)
kge_func(y, y_hat) = sqrt((r2_func(y, y_hat))^2 + (std(y_hat) / std(y) - 1)^2 + (mean(y_hat) / mean(y) - 1)^2)

# Define optimization objective function
function obj_func(p, _)
    return kge_func(
        flow_vec[warm_up:end],  # Observed values after warm-up period
        model(input_matrix, ComponentVector(p, ps_axes); run_kwargs...)[end, warm_up:end]  # Model predictions
    )
end</code></pre><h2 id="Optimization-Progress-Tracking"><a class="docs-heading-anchor" href="#Optimization-Progress-Tracking">Optimization Progress Tracking</a><a id="Optimization-Progress-Tracking-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-Progress-Tracking" title="Permalink"></a></h2><p>To monitor the optimization process, we set up a progress bar and callback function:</p><pre><code class="language-julia hljs"># Create progress bar
progress = Progress(max_iter, desc=&quot;Optimization&quot;)

# Create recorder to save results from each iteration
recorder = []

# Define callback function
callback_func!(state, l) = begin
    push!(recorder, (iter=state.iter, loss=l, time=now(), params=state.u))
    next!(progress)  # Update progress bar
    false  # Return false to continue optimization
end</code></pre><h2 id="Parameter-Boundary-Setup"><a class="docs-heading-anchor" href="#Parameter-Boundary-Setup">Parameter Boundary Setup</a><a id="Parameter-Boundary-Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-Boundary-Setup" title="Permalink"></a></h2><p>To ensure the optimization algorithm searches within a reasonable parameter space, we need to set upper and lower bounds for parameters:</p><pre><code class="language-julia hljs"># Extract parameter lower bounds
lb_list = first.(param_bounds) .|&gt; eltype(input_matrix)

# Extract parameter upper bounds
ub_list = last.(param_bounds) .|&gt; eltype(input_matrix)</code></pre><h2 id="Optimization-Problem-Configuration"><a class="docs-heading-anchor" href="#Optimization-Problem-Configuration">Optimization Problem Configuration</a><a id="Optimization-Problem-Configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-Problem-Configuration" title="Permalink"></a></h2><p>Configure the optimization problem using the Optimization.jl framework:</p><pre><code class="language-julia hljs"># Create optimization function object
optf = Optimization.OptimizationFunction(obj_func, Optimization.AutoForwardDiff())

# Create optimization problem
optprob = Optimization.OptimizationProblem(optf, Vector(init_params), lb=lb_list, ub=ub_list)</code></pre><h2 id="Executing-Optimization"><a class="docs-heading-anchor" href="#Executing-Optimization">Executing Optimization</a><a id="Executing-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Executing-Optimization" title="Permalink"></a></h2><p>Select an optimization algorithm and execute the optimization process:</p><pre><code class="language-julia hljs"># Solve optimization problem
sol = Optimization.solve(
    optprob,
    # CMAES(),  # Covariance Matrix Adaptation Evolution Strategy
    BBO_adaptive_de_rand_1_bin_radiuslimited(),  # Adaptive Differential Evolution algorithm
    # GCMAESOpt(),  # Global Covariance Matrix Adaptation Evolution Strategy
    maxiters=max_iter,  # Maximum iteration count
    callback=callback_func!  # Callback function
)

# Save optimization process records
recorder_df = DataFrame(recorder)
CSV.write(&quot;cache/recorder_$(model_nm).csv&quot;, recorder_df)</code></pre><h2 id="Result-Analysis-and-Visualization"><a class="docs-heading-anchor" href="#Result-Analysis-and-Visualization">Result Analysis and Visualization</a><a id="Result-Analysis-and-Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Result-Analysis-and-Visualization" title="Permalink"></a></h2><p>After optimization is complete, we can run the model with the optimal parameters and analyze the results:</p><pre><code class="language-julia hljs"># Convert optimization results to ComponentVector format
params = ComponentVector(sol.u, ps_axes)

# Run model with optimal parameters
output = model(input_matrix, params; run_kwargs...)

# Extract model outputs
model_output_names = vcat(get_state_names(model), get_output_names(model)) |&gt; Tuple
output_df = DataFrame(NamedTuple{model_output_names}(eachslice(output, dims=1)))

# Calculate final KGE value
@info loss = kge_func(flow_vec, output_df[!, :q_routed])

# Visualize results
plot(output_df[!, :q_routed], label=&quot;Simulated Flow&quot;)
plot!(flow_vec, label=&quot;Observed Flow&quot;)</code></pre><h2 id="Choosing-Different-Optimization-Algorithms"><a class="docs-heading-anchor" href="#Choosing-Different-Optimization-Algorithms">Choosing Different Optimization Algorithms</a><a id="Choosing-Different-Optimization-Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Choosing-Different-Optimization-Algorithms" title="Permalink"></a></h2><p>HydroModels.jl supports multiple optimization algorithms. You can choose the most suitable algorithm based on your specific problem:</p><ol><li><p><strong>Differential Evolution Algorithm</strong> (BBO<em>adaptive</em>de<em>rand</em>1<em>bin</em>radiuslimited): Suitable for most hydrological model parameter optimization problems, with good global search capabilities.</p><pre><code class="language-julia hljs">sol = Optimization.solve(optprob, BBO_adaptive_de_rand_1_bin_radiuslimited(), maxiters=max_iter)</code></pre></li><li><p><strong>Covariance Matrix Adaptation Evolution Strategy</strong> (CMAES): Works well for complex nonlinear problems.</p><pre><code class="language-julia hljs">sol = Optimization.solve(optprob, CMAES(), maxiters=max_iter)</code></pre></li><li><p><strong>Global Covariance Matrix Adaptation Evolution Strategy</strong> (GCMAESOpt): An improved version of CMAES with better global search capabilities.</p><pre><code class="language-julia hljs">sol = Optimization.solve(optprob, GCMAESOpt(), maxiters=max_iter)</code></pre></li></ol><h2 id="Advanced-Applications"><a class="docs-heading-anchor" href="#Advanced-Applications">Advanced Applications</a><a id="Advanced-Applications-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Applications" title="Permalink"></a></h2><h3 id="Multi-Objective-Optimization"><a class="docs-heading-anchor" href="#Multi-Objective-Optimization">Multi-Objective Optimization</a><a id="Multi-Objective-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-Objective-Optimization" title="Permalink"></a></h3><p>For situations requiring simultaneous optimization of multiple objectives, you can define a composite objective function:</p><pre><code class="language-julia hljs">function multi_obj_func(p, _)
    model_output = model(input_matrix, ComponentVector(p, ps_axes); run_kwargs...)[end, warm_up:end]
    
    # Calculate multiple objectives
    kge_value = kge_func(flow_vec[warm_up:end], model_output)
    bias_value = abs(mean(model_output) / mean(flow_vec[warm_up:end]) - 1)
    
    # Combine multiple objectives
    return 0.7 * kge_value + 0.3 * bias_value
end</code></pre><h3 id="Parameter-Sensitivity-Analysis"><a class="docs-heading-anchor" href="#Parameter-Sensitivity-Analysis">Parameter Sensitivity Analysis</a><a id="Parameter-Sensitivity-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-Sensitivity-Analysis" title="Permalink"></a></h3><p>After optimization, you can conduct parameter sensitivity analysis to understand which parameters have the greatest impact on model performance:</p><pre><code class="language-julia hljs">function sensitivity_analysis(model, optimal_params, param_names)
    results = []
    
    for (i, param_name) in enumerate(param_names)
        # Create parameter perturbation sequence
        param_values = range(lb_list[i], ub_list[i], length=10)
        
        # Evaluate model performance for each perturbation value
        for val in param_values
            # Copy optimal parameters and modify current parameter
            test_params = copy(optimal_params)
            test_params[i] = val
            
            # Run model and evaluate performance
            model_output = model(input_matrix, ComponentVector(test_params, ps_axes); run_kwargs...)[end, warm_up:end]
            kge_val = kge_func(flow_vec[warm_up:end], model_output)
            
            push!(results, (param=param_name, value=val, kge=kge_val))
        end
    end
    
    return DataFrame(results)
end</code></pre><h3 id="Ensemble-of-Multiple-Optimization-Algorithms"><a class="docs-heading-anchor" href="#Ensemble-of-Multiple-Optimization-Algorithms">Ensemble of Multiple Optimization Algorithms</a><a id="Ensemble-of-Multiple-Optimization-Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Ensemble-of-Multiple-Optimization-Algorithms" title="Permalink"></a></h3><p>You can try multiple optimization algorithms and select the best result:</p><pre><code class="language-julia hljs">function ensemble_optimization(optprob, algorithms, max_iter)
    best_sol = nothing
    best_loss = Inf
    
    for alg in algorithms
        sol = Optimization.solve(optprob, alg, maxiters=max_iter)
        loss = sol.minimum
        
        if loss &lt; best_loss
            best_loss = loss
            best_sol = sol
        end
    end
    
    return best_sol
end

# Usage example
algorithms = [BBO_adaptive_de_rand_1_bin_radiuslimited(), CMAES(), GCMAESOpt()]
best_sol = ensemble_optimization(optprob, algorithms, max_iter)</code></pre><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>This tutorial demonstrates how to use Julia&#39;s Optimization ecosystem to calibrate hydrological models in HydroModels.jl. By defining appropriate objective functions, selecting suitable optimization algorithms, and setting reasonable parameter boundaries, you can effectively calibrate hydrological models to better fit observed data.</p><p>Optimization is an iterative process that may require trying different objective functions, optimization algorithms, and initial parameter values to achieve the best results. Using the methods in this tutorial, you can flexibly customize the optimization process to meet specific hydrological modeling requirements.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../distribute_modeling/">« Distribute Modeling</a><a class="docs-footer-nextpage" href="../../concepts_en/">Basic Concepts »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Sunday 28 September 2025 02:30">Sunday 28 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
