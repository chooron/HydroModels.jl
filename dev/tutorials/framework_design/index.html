<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Framework Design · HydroModels.jl</title><meta name="title" content="Framework Design · HydroModels.jl"/><meta property="og:title" content="Framework Design · HydroModels.jl"/><meta property="twitter:title" content="Framework Design · HydroModels.jl"/><meta name="description" content="Documentation for HydroModels.jl."/><meta property="og:description" content="Documentation for HydroModels.jl."/><meta property="twitter:description" content="Documentation for HydroModels.jl."/><meta property="og:url" content="https://chooron.github.io/HydroModels.jl/dev/tutorials/framework_design/"/><meta property="twitter:url" content="https://chooron.github.io/HydroModels.jl/dev/tutorials/framework_design/"/><link rel="canonical" href="https://chooron.github.io/HydroModels.jl/dev/tutorials/framework_design/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/icon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">HydroModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../get_start_en/">Get Started with HydroModels.jl</a></li><li><span class="tocitem">tutorials</span><ul><li class="is-active"><a class="tocitem" href>Framework Design</a><ul class="internal"><li><a class="tocitem" href="#Framework-Architecture"><span>Framework Architecture</span></a></li><li><a class="tocitem" href="#Flux-Components"><span>Flux Components</span></a></li><li><a class="tocitem" href="#Element/Bucket-Components"><span>Element/Bucket Components</span></a></li><li><a class="tocitem" href="#Specialized-Structures"><span>Specialized Structures</span></a></li><li><a class="tocitem" href="#Model:-The-Integration-Framework"><span>Model: The Integration Framework</span></a></li><li><a class="tocitem" href="#How-Components-Work-Together"><span>How Components Work Together</span></a></li><li><a class="tocitem" href="#Execution-Process"><span>Execution Process</span></a></li><li><a class="tocitem" href="#Conclusion"><span>Conclusion</span></a></li></ul></li><li><a class="tocitem" href="../neuralnetwork_embeding/">Neural Network Embedding</a></li><li><a class="tocitem" href="../distribute_modeling/">Distribute Modeling</a></li></ul></li><li><a class="tocitem" href="../../concepts_en/">Basic Concepts</a></li><li><span class="tocitem">Model Implementations</span><ul><li><a class="tocitem" href="../../implements/build_exphydro_model_en/">construct the ExpHydro Model</a></li><li><a class="tocitem" href="../../implements/build_m50_model_en/">construct the M50 Model</a></li><li><a class="tocitem" href="../../implements/build_discharge_route_en/">construct the discharge route model</a></li></ul></li><li><span class="tocitem">Extend Contents</span><ul><li><a class="tocitem" href="../../extent/why_not_MTK_en/">Why not using ModelingToolkit.jl directly</a></li><li><a class="tocitem" href="../../extent/framework_comparision_en/">Framework Comparision</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">tutorials</a></li><li class="is-active"><a href>Framework Design</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Framework Design</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/chooron/HydroModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/chooron/HydroModels.jl/blob/main/docs/src/tutorials/framework_design.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Understanding-DeepFlex.jl-Core-Concepts"><a class="docs-heading-anchor" href="#Understanding-DeepFlex.jl-Core-Concepts">Understanding DeepFlex.jl Core Concepts</a><a id="Understanding-DeepFlex.jl-Core-Concepts-1"></a><a class="docs-heading-anchor-permalink" href="#Understanding-DeepFlex.jl-Core-Concepts" title="Permalink"></a></h1><p>This document explains the core concepts of the DeepFlex.jl framework, focusing on the three fundamental components: Flux, Element/Bucket, and Model. We&#39;ll use examples from the ExpHydro model to illustrate these concepts in practice.</p><h2 id="Framework-Architecture"><a class="docs-heading-anchor" href="#Framework-Architecture">Framework Architecture</a><a id="Framework-Architecture-1"></a><a class="docs-heading-anchor-permalink" href="#Framework-Architecture" title="Permalink"></a></h2><p>DeepFlex.jl is built on a modular architecture with three core components:</p><ol><li><strong>Flux</strong>: Basic computational units that define mathematical relationships</li><li><strong>Element/Bucket</strong>: Storage components that integrate fluxes and manage state variables</li><li><strong>Model</strong>: The top-level structure that combines all components into a complete system</li></ol><p>This architecture allows you to build models ranging from simple conceptual models to complex physically-based or hybrid models using the same framework.</p><h2 id="Flux-Components"><a class="docs-heading-anchor" href="#Flux-Components">Flux Components</a><a id="Flux-Components-1"></a><a class="docs-heading-anchor-permalink" href="#Flux-Components" title="Permalink"></a></h2><p>Fluxes are the fundamental building blocks in DeepFlex.jl. They define the mathematical relationships between variables in your hydrological system.</p><h3 id="HydroFlux"><a class="docs-heading-anchor" href="#HydroFlux">HydroFlux</a><a id="HydroFlux-1"></a><a class="docs-heading-anchor-permalink" href="#HydroFlux" title="Permalink"></a></h3><p>A <code>HydroFlux</code> defines a mathematical relationship between input and output variables using symbolic expressions.</p><p>In the ExpHydro model, several HydroFlux components are used to calculate processes like snowfall, rainfall, and potential evapotranspiration:</p><pre><code class="language-julia hljs">@hydroflux begin
    snowfall ~ step_func(Tmin - temp) * prcp
    rainfall ~ step_func(temp - Tmin) * prcp
end
@hydroflux pet ~ 29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)</code></pre><pre><code class="language-text hljs">┌ HydroFlux{##hydro_flux#7684448861079742687}
│ Inputs:  [prcp, temp]
│ Outputs: [snowfall, rainfall]
│ Params:  [Tmin]
│ Expressions:
│   snowfall = 0.5prcp*(1.0 + tanh(5.0(Tmin - temp)))
│   rainfall = 0.5prcp*(1.0 + tanh(5.0(-Tmin + temp)))
└─</code></pre><pre><code class="language-text hljs">┌ HydroFlux{##hydro_flux#3326951609664340984}
│ Inputs:  [temp, lday]
│ Outputs: [pet]
│ Params:  []
│ Expressions:
│   pet = (436.98720000000003lday*exp((17.3temp) / (237.3 + temp))) / (273.2 + temp)
└─</code></pre><h3 id="Structure-of-HydroFlux-Components"><a class="docs-heading-anchor" href="#Structure-of-HydroFlux-Components">Structure of HydroFlux Components</a><a id="Structure-of-HydroFlux-Components-1"></a><a class="docs-heading-anchor-permalink" href="#Structure-of-HydroFlux-Components" title="Permalink"></a></h3><p>As shown in the printed output above, each HydroFlux has a well-defined internal structure that includes several key elements:</p><ol><li><p><strong>Unique Identifier</strong>: Each flux component has a unique hash identifier (e.g., <code>##hydro_flux#7684448861079742687</code>), which allows the system to track and reference specific flux components within the model.</p></li><li><p><strong>Input Variables</strong>: Listed under <code>Inputs:</code>, these are the variables required to calculate the flux. In the first example, the precipitation partitioning component requires precipitation (<code>prcp</code>) and temperature (<code>temp</code>).</p></li><li><p><strong>Output Variables</strong>: Listed under <code>Outputs:</code>, these are the variables produced by the flux calculations. The first component outputs both <code>snowfall</code> and <code>rainfall</code>.</p></li><li><p><strong>Parameters</strong>: Listed under <code>Params:</code>, these are the model parameters used in the calculations. The temperature threshold <code>Tmin</code> is a parameter in the precipitation partitioning component.</p></li><li><p><strong>Mathematical Expressions</strong>: The actual equations that define how outputs are calculated from inputs and parameters. In the first component, the <code>step_func(Tmin - temp)</code> from the original code is expanded to <code>0.5*(1.0 + tanh(5.0(Tmin - temp)))</code>, which creates a smooth step function around the threshold temperature <code>Tmin</code>.</p></li></ol><h3 id="Transformation-from-Code-to-Internal-Representation"><a class="docs-heading-anchor" href="#Transformation-from-Code-to-Internal-Representation">Transformation from Code to Internal Representation</a><a id="Transformation-from-Code-to-Internal-Representation-1"></a><a class="docs-heading-anchor-permalink" href="#Transformation-from-Code-to-Internal-Representation" title="Permalink"></a></h3><p>When you define a flux using the <code>@hydroflux</code> macro, the system:</p><ol><li>Parses the expressions and identifies inputs, outputs, and parameters</li><li>Converts the expressions into a symbolic representation using ModelingToolkit.jl</li><li>Optimizes and simplifies the expressions where possible</li><li>Creates a structured HydroFlux object with all necessary metadata</li></ol><h3 id="Advantages-of-This-Representation"><a class="docs-heading-anchor" href="#Advantages-of-This-Representation">Advantages of This Representation</a><a id="Advantages-of-This-Representation-1"></a><a class="docs-heading-anchor-permalink" href="#Advantages-of-This-Representation" title="Permalink"></a></h3><p>This structured representation offers several benefits:</p><ol><li><strong>Modularity</strong>: Each flux component is self-contained with clear inputs, outputs, and parameters</li><li><strong>Transparency</strong>: The mathematical relationships are explicitly defined and easily inspectable</li><li><strong>Automatic Differentiation</strong>: The symbolic expressions can be automatically differentiated, enabling gradient-based optimization</li><li><strong>Computational Efficiency</strong>: The expressions can be compiled into efficient computational code</li><li><strong>Connectivity</strong>: The system can automatically determine how components connect based on matching variable names</li></ol><p>These expressions define:</p><ul><li>How precipitation is partitioned into snowfall and rainfall based on temperature</li><li>How potential evapotranspiration is calculated from temperature and day length</li></ul><p>HydroFlux components are used for processes that can be expressed as explicit mathematical formulas.</p><h3 id="StateFlux"><a class="docs-heading-anchor" href="#StateFlux">StateFlux</a><a id="StateFlux-1"></a><a class="docs-heading-anchor-permalink" href="#StateFlux" title="Permalink"></a></h3><p>A <code>StateFlux</code> defines how state variables change over time. These are used to create differential equations that are solved during simulation.</p><p>In the ExpHydro model, StateFlux components define how the snowpack and soil water storage change:</p><pre><code class="language-julia hljs">@stateflux snowpack ~ snowfall - melt
@stateflux soilwater ~ (rainfall + melt) - (evap + flow)</code></pre><pre><code class="language-text hljs">┌ StateFlux{##state_flux#7140258851200262205}
│ Inputs:  [melt, snowfall]
│ States:  [snowpack]
│ Params:  []
│ Expressions:
│   snowpack = -melt + snowfall
└─

julia&gt; @stateflux soilwater ~ (rainfall + melt) - (evap + flow)
┌ StateFlux{##state_flux#7046604567730147152}
│ Inputs:  [melt, rainfall, evap, flow]
│ States:  [soilwater]
│ Params:  []
│ Expressions:
│   soilwater = -evap - flow + melt + rainfall
└─</code></pre><p>These expressions define:</p><ul><li>The snowpack increases with snowfall and decreases with snowmelt</li><li>The soil water increases with rainfall and snowmelt, and decreases with evapotranspiration and streamflow</li></ul><p>StateFlux components are essential for water balance calculations and form the basis of the ordinary differential equations (ODEs) that are solved during simulation.</p><h2 id="Element/Bucket-Components"><a class="docs-heading-anchor" href="#Element/Bucket-Components">Element/Bucket Components</a><a id="Element/Bucket-Components-1"></a><a class="docs-heading-anchor-permalink" href="#Element/Bucket-Components" title="Permalink"></a></h2><p>Elements are higher-level components that integrate multiple fluxes and manage state variables. The primary type of element in DeepFlex.jl is the <code>Bucket</code>.</p><h3 id="HydroBucket"><a class="docs-heading-anchor" href="#HydroBucket">HydroBucket</a><a id="HydroBucket-1"></a><a class="docs-heading-anchor-permalink" href="#HydroBucket" title="Permalink"></a></h3><p>A <code>HydroBucket</code> represents a storage component with state variables that change over time according to input and output fluxes. It encapsulates both water movement processes and state evolution equations.</p><p>In the ExpHydro model, two buckets are defined:</p><ol><li><strong>Snow Bucket</strong>: Handles snow accumulation and melt processes</li></ol><pre><code class="language-julia hljs">snow_bucket = @hydrobucket :snow begin
    fluxes = begin
        @hydroflux pet ~ 29.8 * lday * 24 * 0.611 * exp((17.3 * temp) / (temp + 237.3)) / (temp + 273.2)
        @hydroflux snowfall ~ step_func(Tmin - temp) * prcp
        @hydroflux rainfall ~ step_func(temp - Tmin) * prcp
        @hydroflux melt ~ step_func(temp - Tmax) * step_func(snowpack) * min(snowpack, Df * (temp - Tmax))
    end
    dfluxes = begin
        @stateflux snowpack ~ snowfall - melt
    end
end</code></pre><pre><code class="language-text hljs">┌ HydroBucket{snow}
│ Inputs:  [temp, lday, prcp]
│ States:  [snowpack]
│ Outputs: [pet, snowfall, rainfall, melt]
│ Params:  []
│ NNs:     []
│
│ Fluxes:
│   Num[pet] ~ (436.98720000000003lday*exp((17.3temp) / (237.3 + temp))) / (273.2 + temp)
│   Num[snowfall] ~ 0.5prcp*(1.0 + tanh(5.0(-2.092959084 - temp)))
│   Num[rainfall] ~ 0.5prcp*(1.0 + tanh(5.0(2.092959084 + temp)))
│   Num[melt] ~ 0.25(1.0 + tanh(5.0snowpack))*min(snowpack, 2.674548848(-0.175739196 + temp))*(1.0 + tanh(5.0(-0.175739196 + temp)))
│
│ State Fluxes:
│   snowpack ~ -melt + snowfall
└─</code></pre><ol><li><strong>Soil Water Bucket</strong>: Manages soil moisture, evapotranspiration, and runoff generation</li></ol><pre><code class="language-julia hljs">soil_bucket = @hydrobucket :soil begin
    fluxes = begin
        @hydroflux evap ~ step_func(soilwater) * pet * min(1.0, soilwater / Smax)
        @hydroflux baseflow ~ step_func(soilwater) * Qmax * exp(-f * (max(0.0, Smax - soilwater)))
        @hydroflux surfaceflow ~ max(0.0, soilwater - Smax)
        @hydroflux flow ~ baseflow + surfaceflow
    end
    dfluxes = begin
        @stateflux soilwater ~ (rainfall + melt) - (evap + flow)
    end
end</code></pre><pre><code class="language-text hljs">┌ HydroBucket{soil}
│ Inputs:  [pet, melt, rainfall]
│ States:  [soilwater]
│ Outputs: [evap, baseflow, surfaceflow, flow]
│ Params:  [Smax, f, Qmax]
│ NNs:     []
│
│ Fluxes:
│   Num[evap] ~ 0.5pet*min(1.0, 0.0005849797048457405soilwater)*(1.0 + tanh(5.0soilwater))
│   Num[baseflow] ~ 9.234980875exp(-0.01674478max(0.0, 1709.461015 - soilwater))*(1.0 + tanh(5.0soilwater)) 
│   Num[surfaceflow] ~ max(0.0, -1709.461015 + soilwater)
│   Num[flow] ~ baseflow + surfaceflow
│
│ State Fluxes:
│   soilwater ~ -evap - flow + melt + rainfall
└─</code></pre><p>Each bucket:</p><ul><li>Integrates multiple flux components</li><li>Manages state variables and their dynamics</li><li>Handles ODE solving for time evolution</li><li>Supports both single-node and multi-nodes simulations</li></ul><p>The bucket structure allows for modular model construction, where each bucket represents a distinct hydrological process or storage component.</p><h3 id="HydroRoute"><a class="docs-heading-anchor" href="#HydroRoute">HydroRoute</a><a id="HydroRoute-1"></a><a class="docs-heading-anchor-permalink" href="#HydroRoute" title="Permalink"></a></h3><p>Another type of element is <code>HydroRoute</code>, which handles water routing through a network of connected nodes. While not used in the basic ExpHydro model, routing components are essential for distributed hydrological modeling:</p><pre><code class="language-julia hljs"># Example routing component
route = @hydroroute :river_routing begin
    fluxes = begin
        @hydroflux outflow ~ inflow * (1 - exp(-k * travel_time))
    end
    dfluxes = begin
        @stateflux channel_storage ~ inflow - outflow
    end
    aggr_func = network_aggregation_function
end</code></pre><p>Routing components manage flow calculations and inter-node water transfer in network-based models.</p><h2 id="Specialized-Structures"><a class="docs-heading-anchor" href="#Specialized-Structures">Specialized Structures</a><a id="Specialized-Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Specialized-Structures" title="Permalink"></a></h2><p>Hydrological models incorporate several specialized structures, with the unit hydrograph being the most typical example. The unit hydrograph is a module used to describe hillslope routing, simulating the process of runoff concentration after runoff generation through convolution calculations.</p><p class="math-container">\[Q(t) = \sum_{i=1}^{t} P(t-i+1) \cdot UH(i)\]</p><p>To represent this concept, HydroModels.jl has designed two types: <code>UHFunction</code> and <code>UnitHydrograph</code>. These represent the unit hydrograph function and the unit hydrograph model, respectively.</p><p>The unit hydrograph function calculates the distribution weights for different time periods in the runoff process, while the unit hydrograph model describes which flux is used for unit hydrograph routing calculations. Here, we use the unit hydrographs for slow flow and fast flow routing calculations in the GR4J model as implementation examples.</p><pre><code class="language-julia hljs"># Unit hydrograph components for GR4J model
uh = @unithydro :maxbas_uh begin
    uh_func = begin
        2lag =&gt; (1 - 0.5 * (2 - t / lag)^2.5)
        lag =&gt; (0.5 * (t / lag)^2.5)
    end
    uh_vars = [q]
    configs = (solvetype=:DISCRETE, suffix=:_lag)
end</code></pre><h2 id="Model:-The-Integration-Framework"><a class="docs-heading-anchor" href="#Model:-The-Integration-Framework">Model: The Integration Framework</a><a id="Model:-The-Integration-Framework-1"></a><a class="docs-heading-anchor-permalink" href="#Model:-The-Integration-Framework" title="Permalink"></a></h2><p>The <code>HydroModel</code> is the top-level structure that integrates multiple components into a complete simulation system.</p><p>In the ExpHydro model, the snow and soil buckets are combined into a complete model:</p><pre><code class="language-julia hljs">exphydro_model = @hydromodel :exphydro begin
    snow_bucket
    soil_bucket
end</code></pre><pre><code class="language-text hljs">┌ HydroModel: exphydro
│ Components: snow, soil
│ Inputs:     [temp, lday, prcp]
│ States:     [snowpack, soilwater]
│ Outputs:    [pet, snowfall, rainfall, melt, evap, baseflow, surfaceflow, flow]
│ Parameters: [Tmin, Df, Tmax, Smax, f, Qmax]
│ Summary:
│   Fluxes:  0 fluxes
│   Buckets: 2 buckets
│   Routes:  0 routes
└─</code></pre><p>The model automatically:</p><ul><li>Analyzes dependencies between components</li><li>Creates a computational graph for efficient execution</li><li>Manages state variables across the entire model</li><li>Prepares the model for simulation with various solver options</li></ul><p>The model provides a unified interface for simulation, allowing you to run the model with different input data, parameters, and configuration options:</p><pre><code class="language-julia hljs"># Run the model
results = exphydro_model(
    input_matrix,   # Input data matrix
    params,         # Parameters
    initstates = init_states,  # Initial states
    config = config  # Configuration
)</code></pre><h2 id="How-Components-Work-Together"><a class="docs-heading-anchor" href="#How-Components-Work-Together">How Components Work Together</a><a id="How-Components-Work-Together-1"></a><a class="docs-heading-anchor-permalink" href="#How-Components-Work-Together" title="Permalink"></a></h2><p>The power of DeepFlex.jl comes from how these components work together:</p><ol><li><strong>Fluxes</strong> define the mathematical relationships and processes</li><li><strong>Buckets/Elements</strong> integrate these fluxes and manage state variables</li><li><strong>Models</strong> combine multiple elements into a complete simulation system</li></ol><p>In the ExpHydro model:</p><ul><li>HydroFlux components define processes like snowfall, rainfall, and potential evapotranspiration</li><li>StateFlux components define how snowpack and soil water storage change over time</li><li>HydroBucket components integrate these fluxes into snow and soil water components</li><li>HydroModel combines these components into a complete ExpHydro model</li></ul><p>The framework automatically handles the connections between components. For example, the rainfall and melt outputs from the snow bucket are used as inputs to the soil bucket without requiring explicit connections.</p><h2 id="Execution-Process"><a class="docs-heading-anchor" href="#Execution-Process">Execution Process</a><a id="Execution-Process-1"></a><a class="docs-heading-anchor-permalink" href="#Execution-Process" title="Permalink"></a></h2><p>When running a model in DeepFlex.jl, the following steps occur:</p><ol><li><p><strong>Data Preparation</strong>:</p><ul><li>Input data is organized as a matrix (features × time)</li><li>Parameters are provided as a ComponentVector</li><li>Initial states are specified</li></ul></li><li><p><strong>Configuration</strong>:</p><ul><li>Solver selection (e.g., ManualSolver for explicit Euler method)</li><li>Interpolation method (e.g., LinearInterpolation)</li><li>Time indices for output</li></ul></li><li><p><strong>Execution</strong>:</p><ul><li>Components are executed in dependency order</li><li>State variables are integrated over time</li><li>Fluxes are calculated at each time step</li><li>Results are collected and organized</li></ul></li><li><p><strong>Output</strong>:</p><ul><li>Time series of state variables (e.g., snowpack, soil moisture)</li><li>Time series of output fluxes (e.g., streamflow)</li></ul></li></ol><h2 id="Conclusion"><a class="docs-heading-anchor" href="#Conclusion">Conclusion</a><a id="Conclusion-1"></a><a class="docs-heading-anchor-permalink" href="#Conclusion" title="Permalink"></a></h2><p>Understanding the relationships between Flux, Element/Bucket, and Model components is essential for effectively using the HydroModels.jl framework. These components provide a flexible and powerful system for building hydrological models of varying complexity.</p><p>The ExpHydro model demonstrates how these components work together to create a complete hydrological model:</p><ul><li>Flux components define the mathematical relationships</li><li>Bucket components integrate these fluxes and manage state variables</li><li>The Model combines these components into a complete simulation system</li></ul><p>By leveraging this modular architecture, you can:</p><ul><li>Build models from reusable components</li><li>Combine process-based and data-driven approaches</li></ul><p>This framework design enables a wide range of hydrological modeling applications while maintaining computational efficiency and scientific rigor.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../get_start_en/">« Get Started with HydroModels.jl</a><a class="docs-footer-nextpage" href="../neuralnetwork_embeding/">Neural Network Embedding »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Monday 14 April 2025 01:16">Monday 14 April 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
